<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="generator" content="intranetr/0.10.0">
<title>OEFENINGEN: C++14 en binaire bomen | iii intranet</title>    <link rel="stylesheet" type="text/css" media="screen,handheld" href="OEFENINGEN%20%20C++14%20en%20binaire%20bomen%20%20%20iii%20intranet_files/default.css">
    <link rel="stylesheet" type="text/css" media="print" href="OEFENINGEN%20%20C++14%20en%20binaire%20bomen%20%20%20iii%20intranet_files/print.css">
    <link rel="stylesheet" type="text/css" media="screen,handheld" href="OEFENINGEN%20%20C++14%20en%20binaire%20bomen%20%20%20iii%20intranet_files/default_002.css">
    <script type="text/javascript" async="" src="OEFENINGEN%20%20C++14%20en%20binaire%20bomen%20%20%20iii%20intranet_files/ga.js"></script><script type="text/javascript" src="OEFENINGEN%20%20C++14%20en%20binaire%20bomen%20%20%20iii%20intranet_files/0d6197553acf19ea859c96f7caf7d8fa6c6519b8.js"></script><style>#header + #content > #left > #rlblock_left,
#content > #center > .dose > .dosesingle,
#content > #right > .dose > .dosesingle
{display:none !important;}</style>
<!--[if lt IE 8]>
<link rel="stylesheet" type="text/css" href="/css/ie.css">
<![endif]-->
    <script type="text/javascript">
    (function() {
        var month = 5;
        iii.semester = month == 1 ? 1
            : month <= 6 ? 2
            : month <= 9 ? 0 : 1;
        if (iii.semester > 0) {
            var hideOtherSemester = function() {
                var other = iii.semester == 1 ? 2 : 1;
                $('#breadcrumbs li.group-sem'
                        + other
                        + ':not(.group-sem'
                        + iii.semester + '):not(.active)')
                    .hide();
            };
            $(document)
                .ready(hideOtherSemester)
                .on("contentUpdate.iii", hideOtherSemester);
        }
    })();
    </script>
</head>

<body>
    <h2>OEFENINGEN: C++14 en binaire bomen</h2>
    <div id="page-content">
        <h4>LES 1 - 27 sept 2016</h4>
<h3>ZOEKBOMEN</h3>
<h4>Inleiding C++14</h4>
In <a href="opgave_files/zoekboom14.h">zoekboom14.h</a> vind je de
basisdefinities en de toevoegfunctie van een binaire zoekboom.
<ol>
<li>De noodzakelijke constructoren, move- en copyoperaties
ontbreken. Voeg ze toe. Controleer of je toevoegcode nu werkt.
Daarvoor zal je uiteraard een uitschrijfoperatie moeten maken. Let
erop dat de knopen ouderpointers hebben: om je uitschrijfoperatie
bruikbaar te maken bij debuggen moet je dus bij elke knoop de
sleutel uitschrijven van de knoop zelf, maar ook van de ouder en de
twee kinderen. Anders heb je geen zicht op de structuur van de
boom!</li>
<li>We gaan ons dit jaar bezighouden met evenwichtige bomen. Dus ga
je een paar maten implementeren die aanduiden hoe evenwichtig een
boom is:
<ol>
<li>Maak een functie die de totale diepte van een boom
teruggeeft.</li>
</ol>
</li>
<li>Een basisoperatie bij het evenwichtig maken van bomen is de
rotatie. Hierbij neemt een kind van een knoop de plaats van zijn
ouder in; de oorspronkelijke ouder wordt dan kind van het vroegere
kind. Omdat het om een zoekboom gaat moeten de deelbomen onder deze
twee knopen verplaatst worden als op de onderstaande afbeelding:
<p><img src="opgave_files/Rotaties.gif"></p>
<p>Ontwerp eerst je functiehoofding: welke info heb je nodig om een
bepaalde knoop te roteren? Hoe geef je die mee aan de functie?
Schrijf je antwoord op en laat het controleren voor je aan de
implementatie begint.</p>
<p><strong>Implementatietip:</strong> het is handig als je aan een
knoop een functie geeft die een referentie naar zijn linker- of
rechterdeelboom geeft op basis van een <tt>bool</tt>-argument.</p>
</li>
<li>Schrijf nu een functie <tt>maakOnevenwichtig()</tt> die een
boom zo onevenwichtig mogelijk maakt.</li>
<li>Schrijf nu een functie <tt>maakEvenwichtig()</tt> die een boom
zo evenwichtig mogelijk maakt <em>zonder ooit een sleutel of een
datum te kopiëen of te moven</em>. Tip: dit is vrij eenvoudig als
je de vorige functie gebruikt, anders niet.</li>
</ol>
<h4>Testen</h4>
Als je code schrijft moet je die ook <em>testen</em>. Dat is meer
dan alleen maar nagaan of je code compileert en niet crasht op één
klein voorbeeldje. Vaak is het zo dat je meer testcode hebt dan
code die getest moet worden. Dat lijkt veel werk met weinig
opbrengst, maar dat is het niet: alleen zo kan je zeker zijn dat je
code werkt zoals het hoort.
<p>Kleine boompjes kan je inspecteren met een uitschrijfoperatie.
Die is voorzien in de code. Wie liever een <a href="http://users.ugent.be/~marsaele/voorbeeld.png">tekening</a> heeft
kan gebruik maken van het <a href="http://graphviz.org/">dot-pakket</a> (op labo-computers download
je best de zip-versie). Voorbeeldcode om een boom om te zetten naar
een tekening in het dot-formaat vind je in <a href="https://intranet.tiwi.ugent.be/Algoritmen-II/vorigJaar/reeks01/dot.h">dot.h</a>. Een scriptje om .dot-bestanden om te zetten naar
een afbeelding vind je in <a href="https://intranet.tiwi.ugent.be/Algoritmen-II/vorigJaar/reeks01/genereer-dot.sh">genereer-dot.sh</a> (je kan de dot-code ook
online een grafiek laten genereren via <a href="http://webgraphviz.com/">http://webgraphviz.com/</a>).</p>
<p>Een belangrijk concept bij testen is de <em>rep-invariant</em>.
Dit staat voor representatie-invariant. Het is het geheel van
voorwaarden waaraan de representatie in het geheugen van een object
moet voldoen om de een geldig object voor te stellen. Voor een
binaire zoekboom zijn de in het oog springende voorwaarden:</p>
<ol>
<li>Het moet een geldige binaire boom zijn.</li>
<li>De sleutels moeten in volgorde staan.</li>
</ol>
Het eerste aspect houdt in dat alle pointers oké moeten zijn. Nu
werken we met <tt>unique_ptr</tt>s. Bij normaal gebruik staat een
<tt>unique_ptr</tt> op nul ofwel wijst hij naar een object terwijl
hij de enige <tt>unique_ptr</tt> is die naar dat object wijst. Als
dat om een of andere reden niet het geval is merken we dat meestal
gauw genoeg, zodat we dat in dit geval niet moeten testen. (Er kan
soms een probleem zijn met een circuit van <tt>unique_ptr</tt>s,
maar zo'n circuit hangt dan per definitie nergens meer aan. Het
leidt dan wel tot een geheugenlek, maar niet tot een verbreking van
de rep-invariant). Onze binaire boom heeft ook ouderpointers. Dit
zijn gewone pointers en het behoort natuurlijk tot de rep-invariant
dat deze pointers naar de juiste knopen wijzen.
<p>De rep-invariant van alle betrokken objecten maakt deel uit van
pre- en postconditie van alle publiek toegankelijke functies
(interne functies kunnen soms de rep-invariant doorbreken of een
gebroken rep-invariant herstellen). Bij testen moet je hem dus
regelmatig controleren. Het is gebruikelijk een te testen klasse
een lidfunctie <tt>bool repOK()</tt> te geven. Deze gaat na of de
rep-invariant voldaan is. Het eerste punt van de bovenstaande
opdracht is dus het schrijven van de <tt>repOK()</tt>-functie voor
de zoekboomklasse die de bovenstaande voorwaarden controleert. Tip:
dit kan in O(<em>n</em>).</p>
<p>Als volgende punt moet je kunnen nagaan of de operaties die je
programmeert wel degelijk doen wat ze moeten doen. Eén element
daarbij is dat de operaties niets mogen veranderen aan de
sleutelverzameling. Hiervoor is het nodig dat je</p>
<ol>
<li>Een kopie kan nemen van de begintoestand voor het uitvoeren van
de operatie. Noteer dat dit alleen maar mogelijk is als sleutels en
data kopieerbaar zijn (is dat eigenlijk een voorwaarde die moet
altijd moet voldaan zijn als je een zoekboom wil gebruiken?)</li>
<li>Van twee zoekbomen kan nagaan of ze dezelfde sleutelverzameling
hebben en dezelfde data bij de gelijke sleutels. Nu heeft de
zoekboom een <tt>inorder</tt>-functie die gemakkelijk kan gebruikt
kan worden met λ-functies. Zijn er alternatieve manieren om een
boom te doorlopen? Welke is het meest geschikt bij dit
probleem?</li>
</ol>
<p>De rotatie-operatie kan je nu gemakkelijk testen op kleine
voorbeeldjes door middel van de uitschrijfoperatie. Zorg er zeker
voor dat je alle speciale gevallen bekijkt:</p>
<ul>
<li>Roteer zowel deelbomen als basisbomen.</li>
<li>Probeer alle mogelijke combinatie van aan- en afwezige
kinderen. Als p de ouderknoop is van de knoop c en c moet geroteerd
worden met p, dan kan p al of niet een tweede kind hebben en c kan
geen of twee kinderen hebben, of alleen een linker- en een
rechterkind.</li>
<li>Roteer zowel naar links als naar rechts.</li>
<li>Combineer de bovenstaande mogelijkheden.</li>
</ul>
De functies <tt>maakOnevenwichtig()</tt> en
<tt>maakEvenwichtig()</tt> kan je nu gemakkelijk testen. Je kan
nagaan of ze hun werk goed doen door de diepte van het resultaat te
controleren. Zorg er zeker voor dat je alle speciale gevallen
bekijkt:
<ul>
<li>Een lege boom.</li>
<li>Een zeer onvenwichtige en een zeer evenwichtige boom, maar ook
random bomen.</li>
<li>Voor <tt>maakEvenwichtig()</tt>: bomen die het maximum aantal
knopen bevatten dat met een bepaalde diepte kan bereikt worden en
bomen met 1 knoop extra.</li>
<li><tt>maakEvenwichtig()</tt> moet een efficiëntie hebben van O(n
lg n). Probeer dat eens uit met waarden voor n die redelijk groot
zijn: een boom met 16383 of 16384 (wat is er speciaal aan deze
getallen?) elementen moet binnen de seconde evenwichtig gemaakt
worden.</li>
</ul>

        <div id="page-content-end"></div>
    </div>

</div>
</div>

<!-- 39 ms / 492 KB -->
</div>





<div id="popout"><div id="popout-panel"><div id="popout-grow" class="popout-button"></div><div id="popout-shrink" class="popout-button"></div><div id="popout-close" class="popout-button"></div><div id="popout-contents"></div></div></div><img src="OEFENINGEN%20%20C++14%20en%20binaire%20bomen%20%20%20iii%20intranet_files/throbber.gif" style="position: absolute; left: 50%; top: 50%;margin: -15px 0 0 -15px; z-index: 100; display: none;"></body></html>
<!-- 25 ms / 515 KB -->