<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="generator" content="intranetr/0.10.0">
<title>pugixml 1.7 quick start guide | iii intranet</title>    <link rel="stylesheet" type="text/css" media="screen,handheld" href="/css/default.css?0.10.0">
    <link rel="stylesheet" type="text/css" media="print" href="/css/print.css?0.10.0">
    <link rel="stylesheet" type="text/css" media="screen,handheld" href="/css/sites/default.css">
    <script type="text/javascript" src="/js/cache/0d6197553acf19ea859c96f7caf7d8fa6c6519b8.js?0.10.0"></script>
<!--[if lt IE 8]>
<link rel="stylesheet" type="text/css" href="/css/ie.css">
<![endif]-->
    <script type="text/javascript">
    (function() {
        var month = 5;
        iii.semester = month == 1 ? 1
            : month <= 6 ? 2
            : month <= 9 ? 0 : 1;
        if (iii.semester > 0) {
            var hideOtherSemester = function() {
                var other = iii.semester == 1 ? 2 : 1;
                $('#breadcrumbs li.group-sem'
                        + other
                        + ':not(.group-sem'
                        + iii.semester + '):not(.active)')
                    .hide();
            };
            $(document)
                .ready(hideOtherSemester)
                .on("contentUpdate.iii", hideOtherSemester);
        }
    })();
    </script>
</head>

<body>
    <div id="header"><h1>
    <a href="/" title="Naar de thuispagina">
        intranet
    </a>
</h1>
</div>
<div id="main">    <div id="node-children">
    <ul>
            <li><a href="/Algoritmen-II/vorigJaar/reeks09/pugixml/docs/"><span style="float: right">&#8593;</span>Omhoog</a></li>
            </ul>
    </div>

<div id="content" class="">
        <div id="breadcrumbs-container">
    <span id="you-are-here">Je bent hier:</span>
    <ul id="breadcrumbs">
                            <li class="breadcrumb first"><a href="/" class="breadcrumb first">Intranet</a>
                </li>
                            <li class="breadcrumb"><a href="/Algoritmen-II/" class="breadcrumb">Algoritmen-II</a>
                    <ul class="breadcrumb-siblings">
                                                <li class="separator"><span>Eerste bachelor</span></li>
                                                                                                                                                                                                                                                            <li class="breadcrumb-sibling group-sem1 group-sem2"><a class="breadcrumb-sibling group-sem1 group-sem2" href="/OpenLes/">Informatica I - Open Les</a></li>
                                                                <li class="separator"><span>Tweede bachelor</span></li>
                                                                                                                                                                                                                <li class="breadcrumb-sibling group-sem2"><a class="breadcrumb-sibling group-sem2" href="/Besturingssystemen-I/">Besturingssystemen I</a></li>
                                                                                                                                                                                                                <li class="breadcrumb-sibling group-sem1 leaf"><a class="breadcrumb-sibling group-sem1 leaf" href="/Computernetwerken-I/">Computernetwerken I</a></li>
                                                                <li class="separator"><span>Derde bachelor</span></li>
                                                                                                                                                                                                                <li class="breadcrumb-sibling group-sem2"><a class="breadcrumb-sibling group-sem2" href="/Algoritmen-I/">Algoritmen I</a></li>
                                                                                                                                                                                                                <li class="breadcrumb-sibling group-sem2"><a class="breadcrumb-sibling group-sem2" href="/Besturingssystemen-II/">Besturingssystemen II</a></li>
                                                                                                                                                                                                                <li class="breadcrumb-sibling group-sem2"><a class="breadcrumb-sibling group-sem2" href="/Computernetwerken-II/">Computernetwerken II</a></li>
                                                                                                                                                                                                                <li class="breadcrumb-sibling group-sem1"><a class="breadcrumb-sibling group-sem1" href="/Databanken/">Databanken</a></li>
                                                                                                                                                                                                                <li class="breadcrumb-sibling group-sem1"><a class="breadcrumb-sibling group-sem1" href="/Discrete-Wiskunde/">Discrete wiskunde</a></li>
                                                                <li class="separator"><span>Master</span></li>
                                                                                                                                                                                                                <li class="breadcrumb-sibling group-sem1 active"><a class="breadcrumb-sibling group-sem1 active" href="/Algoritmen-II/">Algoritmen-II</a></li>
                                                                                                                                                                                                                <li class="breadcrumb-sibling group-sem1 leaf"><a class="breadcrumb-sibling group-sem1 leaf" href="/Computergrafiek/">Computergrafiek</a></li>
                                                                                                                                                                                                                                                            <li class="breadcrumb-sibling group-sem1 group-sem2 leaf"><a class="breadcrumb-sibling group-sem1 group-sem2 leaf" href="/Masterproef/">Masterproef</a></li>
                                                                                                                                                                                                                <li class="breadcrumb-sibling group-sem1"><a class="breadcrumb-sibling group-sem1" href="/Besturingssystemen-III/">Windows</a></li>
                                        </ul>
                </li>
                            <li class="breadcrumb"><a href="/Algoritmen-II/vorigJaar/" class="breadcrumb">vorigJaar</a>
                </li>
                            <li class="breadcrumb"><a href="/Algoritmen-II/vorigJaar/reeks09/" class="breadcrumb">reeks09</a>
                </li>
                            <li class="breadcrumb"><a href="/Algoritmen-II/vorigJaar/reeks09/pugixml/" class="breadcrumb">pugixml</a>
                </li>
                            <li class="breadcrumb"><a href="/Algoritmen-II/vorigJaar/reeks09/pugixml/docs/" class="breadcrumb">docs</a>
                </li>
                            <li class="breadcrumb"><a href="/Algoritmen-II/vorigJaar/reeks09/pugixml/docs/quickstart.html" class="breadcrumb">pugixml 1.7 quick start guide</a>
                </li>
        </ul>
    </div>
    <h2>pugixml 1.7 quick start guide</h2>
    <div id="page-content">
        <div id="header">
<h3>pugixml 1.7 quick start guide</h3>
<div class="details"><span id="author" class=
"author">website</span><br>
<span id="email" class="email"><a href="http://pugixml.org" class=
"bare">http://pugixml.org</a></span><br>
<span id="author2" class="author">repository</span><br>
<span id="email2" class="email"><a href=
"http://github.com/zeux/pugixml" class=
"bare">http://github.com/zeux/pugixml</a></span><br></div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#install">Installation</a></li>
<li><a href="#dom">Document object model</a></li>
<li><a href="#loading">Loading document</a></li>
<li><a href="#access">Accessing document data</a></li>
<li><a href="#modify">Modifying document data</a></li>
<li><a href="#saving">Saving document</a></li>
<li><a href="#feedback">Feedback</a></li>
<li><a href="#license">License</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h4 id="introduction"><a class="anchor" href=
"#introduction"></a>Introduction</h4>
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://pugixml.org/">pugixml</a> is a light-weight C++
XML processing library. It consists of a DOM-like interface with
rich traversal/modification capabilities, an extremely fast XML
parser which constructs the DOM tree from an XML file/buffer, and
an XPath 1.0 implementation for complex data-driven tree queries.
Full Unicode support is also available, with two Unicode interface
variants and conversions between different Unicode encodings (which
happen automatically during parsing/saving). The library is
extremely portable and easy to integrate and use. pugixml is
developed and maintained since 2006 and has many users. All code is
distributed under the <a href="#license">MIT license</a>, making it
completely free to use in both open-source and proprietary
applications.</p>
</div>
<div class="paragraph">
<p>pugixml enables very fast, convenient and memory-efficient XML
document processing. However, since pugixml has a DOM parser, it
can’t process XML documents that do not fit in memory; also the
parser is a non-validating one, so if you need DTD/Schema
validation, the library is not for you.</p>
</div>
<div class="paragraph">
<p>This is the quick start guide for pugixml, which purpose is to
enable you to start using the library quickly. Many important
library features are either not described at all or only mentioned
briefly; for more complete information you <a href=
"manual.html">should read the complete manual</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">No documentation is perfect; neither is this
one. If you find errors or omissions, please don’t hesitate to
<a href="https://github.com/zeux/pugixml/issues/new">submit an
issue or open a pull request</a> with a fix.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h4 id="install"><a class="anchor" href=
"#install"></a>Installation</h4>
<div class="sectionbody">
<div class="paragraph">
<p>You can download the latest source distribution as an
archive:</p>
</div>
<div class="paragraph">
<p><a href=
"https://github.com/zeux/pugixml/releases/download/v1.7/pugixml-1.7.zip">
pugixml-1.7.zip</a> (Windows line endings) / <a href=
"https://github.com/zeux/pugixml/releases/download/v1.7/pugixml-1.7.tar.gz">
pugixml-1.7.tar.gz</a> (Unix line endings)</p>
</div>
<div class="paragraph">
<p>The distribution contains library source, documentation (the
guide you’re reading now and the manual) and some code examples.
After downloading the distribution, install pugixml by extracting
all files from the compressed archive.</p>
</div>
<div class="paragraph">
<p>The complete pugixml source consists of three files - one source
file, <code>pugixml.cpp</code>, and two header files,
<code>pugixml.hpp</code> and <code>pugiconfig.hpp</code>.
<code>pugixml.hpp</code> is the primary header which you need to
include in order to use pugixml classes/functions. The rest of this
guide assumes that <code>pugixml.hpp</code> is either in the
current directory or in one of include directories of your
projects, so that <code>#include "pugixml.hpp"</code> can find the
header; however you can also use relative path (i.e. <code>#include
"../libs/pugixml/src/pugixml.hpp"</code>) or include
directory-relative path (i.e. <code>#include
&lt;xml/thirdparty/pugixml/src/pugixml.hpp&gt;</code>).</p>
</div>
<div class="paragraph">
<p>The easiest way to build pugixml is to compile the source file,
<code>pugixml.cpp</code>, along with the existing
library/executable. This process depends on the method of building
your application; for example, if you’re using Microsoft Visual
Studio <span class="footnote">[<a id="_footnoteref_1" class=
"footnote" href="#_footnote_1" title=
"View footnote.">1</a>]</span>, Apple Xcode, Code::Blocks or any
other IDE, just add <code>pugixml.cpp</code> to one of your
projects. There are other building methods available, including
building pugixml as a standalone static/shared library; <a href=
"manual/install.html#install.building">read the manual</a> for
further information.</p>
</div>
</div>
</div>
<div class="sect1">
<h4 id="dom"><a class="anchor" href="#dom"></a>Document object
model</h4>
<div class="sectionbody">
<div class="paragraph">
<p>pugixml stores XML data in DOM-like way: the entire XML document
(both document structure and element data) is stored in memory as a
tree. The tree can be loaded from character stream (file, string,
C++ I/O stream), then traversed via special API or XPath
expressions. The whole tree is mutable: both node structure and
node/attribute data can be changed at any time. Finally, the result
of document transformations can be saved to a character stream
(file, C++ I/O stream or custom transport).</p>
</div>
<div class="paragraph">
<p>The root of the tree is the document itself, which corresponds
to C++ type <code>xml_document</code>. Document has one or more
child nodes, which correspond to C++ type <code>xml_node</code>.
Nodes have different types; depending on a type, a node can have a
collection of child nodes, a collection of attributes, which
correspond to C++ type <code>xml_attribute</code>, and some
additional data (i.e. name).</p>
</div>
<div class="paragraph">
<p>The most common node types are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Document node (<code>node_document</code>) - this is the root of
the tree, which consists of several child nodes. This node
corresponds to <code>xml_document</code> class; note that
<code>xml_document</code> is a sub-class of <code>xml_node</code>,
so the entire node interface is also available.</p>
</li>
<li>
<p>Element/tag node (<code>node_element</code>) - this is the most
common type of node, which represents XML elements. Element nodes
have a name, a collection of attributes and a collection of child
nodes (both of which may be empty). The attribute is a simple
name/value pair.</p>
</li>
<li>
<p>Plain character data nodes (<code>node_pcdata</code>) represent
plain text in XML. PCDATA nodes have a value, but do not have name
or children/attributes. Note that <strong>plain character data is
not a part of the element node but instead has its own
node</strong>; for example, an element node can have several child
PCDATA nodes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Despite the fact that there are several node types, there are
only three C++ types representing the tree
(<code>xml_document</code>, <code>xml_node</code>,
<code>xml_attribute</code>); some operations on
<code>xml_node</code> are only valid for certain node types. They
are described below.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">All pugixml classes and functions are located
in <code>pugi</code> namespace; you have to either use explicit
name qualification (i.e. <code>pugi::xml_node</code>), or to gain
access to relevant symbols via <code>using</code> directive (i.e.
<code>using pugi::xml_node;</code> or <code>using namespace
pugi;</code>).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>xml_document</code> is the owner of the entire document
structure; destroying the document destroys the whole tree. The
interface of <code>xml_document</code> consists of loading
functions, saving functions and the entire interface of
<code>xml_node</code>, which allows for document inspection and/or
modification. Note that while <code>xml_document</code> is a
sub-class of <code>xml_node</code>, <code>xml_node</code> is not a
polymorphic type; the inheritance is present only to simplify
usage.</p>
</div>
<div class="paragraph">
<p><code>xml_node</code> is the handle to document node; it can
point to any node in the document, including document itself. There
is a common interface for nodes of all types. Note that
<code>xml_node</code> is only a handle to the actual node, not the
node itself - you can have several <code>xml_node</code> handles
pointing to the same underlying object. Destroying
<code>xml_node</code> handle does not destroy the node and does not
remove it from the tree.</p>
</div>
<div class="paragraph">
<p>There is a special value of <code>xml_node</code> type, known as
null node or empty node. It does not correspond to any node in any
document, and thus resembles null pointer. However, all operations
are defined on empty nodes; generally the operations don’t do
anything and return empty nodes/attributes or empty strings as
their result. This is useful for chaining calls; i.e. you can get
the grandparent of a node like so:
<code>node.parent().parent()</code>; if a node is a null node or it
does not have a parent, the first <code>parent()</code> call
returns null node; the second <code>parent()</code> call then also
returns null node, so you don’t have to check for errors twice. You
can test if a handle is null via implicit boolean cast: <code>if
(node) { …​ }</code> or <code>if (!node) { …​ }</code>.</p>
</div>
<div class="paragraph">
<p><code>xml_attribute</code> is the handle to an XML attribute; it
has the same semantics as <code>xml_node</code>, i.e. there can be
several <code>xml_attribute</code> handles pointing to the same
underlying object and there is a special null attribute value,
which propagates to function results.</p>
</div>
<div class="paragraph">
<p>There are two choices of interface and internal representation
when configuring pugixml: you can either choose the UTF-8 (also
called char) interface or UTF-16/32 (also called wchar_t) one. The
choice is controlled via <code>PUGIXML_WCHAR_MODE</code> define;
you can set it via <code>pugiconfig.hpp</code> or via preprocessor
options. All tree functions that work with strings work with either
C-style null terminated strings or STL strings of the selected
character type. <a href="manual/dom.html#dom.unicode">Read the
manual</a> for additional information on Unicode interface.</p>
</div>
</div>
</div>
<div class="sect1">
<h4 id="loading"><a class="anchor" href="#loading"></a>Loading
document</h4>
<div class="sectionbody">
<div class="paragraph">
<p>pugixml provides several functions for loading XML data from
various places - files, C++ iostreams, memory buffers. All
functions use an extremely fast non-validating parser. This parser
is not fully W3C conformant - it can load any valid XML document,
but does not perform some well-formedness checks. While
considerable effort is made to reject invalid XML documents, some
validation is not performed because of performance reasons. XML
data is always converted to internal character format before
parsing. pugixml supports all popular Unicode encodings (UTF-8,
UTF-16 (big and little endian), UTF-32 (big and little endian);
UCS-2 is naturally supported since it’s a strict subset of UTF-16)
and handles all encoding conversions automatically.</p>
</div>
<div class="paragraph">
<p>The most common source of XML data is files; pugixml provides a
separate function for loading XML document from file. This function
accepts file path as its first argument, and also two optional
arguments, which specify parsing options and input data encoding,
which are described in the manual.</p>
</div>
<div class="paragraph">
<p>This is an example of loading XML document from file (<a href=
"samples/load_file.cpp" class=
"bare">samples/load_file.cpp</a>):</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class=
"tok-n">xml_document</span> <span class=
"tok-n">doc</span><span class="tok-p">;</span>

<span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class=
"tok-n">xml_parse_result</span> <span class=
"tok-n">result</span> <span class="tok-o">=</span> <span class=
"tok-n">doc</span><span class="tok-p">.</span><span class=
"tok-n">load_file</span><span class="tok-p">(</span><span class=
"tok-s">"tree.xml"</span><span class="tok-p">);</span>

<span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"Load result: "</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-n">result</span><span class="tok-p">.</span><span class=
"tok-n">description</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-s">", mesh name: "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class=
"tok-p">.</span><span class="tok-n">child</span><span class=
"tok-p">(</span><span class="tok-s">"mesh"</span><span class=
"tok-p">).</span><span class="tok-n">attribute</span><span class=
"tok-p">(</span><span class="tok-s">"name"</span><span class=
"tok-p">).</span><span class="tok-n">value</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-n">std</span><span class="tok-o">::</span><span class=
"tok-n">endl</span><span class="tok-p">;</span></code>
</pre></div>
<div class="paragraph">
<p><code>load_file</code>, as well as other loading functions,
destroys the existing document tree and then tries to load the new
tree from the specified file. The result of the operation is
returned in an <code>xml_parse_result</code> object; this object
contains the operation status, and the related information (i.e.
last successfully parsed position in the input file, if parsing
fails).</p>
</div>
<div class="paragraph">
<p>Parsing result object can be implicitly converted to
<code>bool</code>; if you do not want to handle parsing errors
thoroughly, you can just check the return value of load functions
as if it was a <code>bool</code>: <code>if
(doc.load_file("file.xml")) { …​ } else { …​ }</code>. Otherwise
you can use the <code>status</code> member to get parsing status,
or the <code>description()</code> member function to get the status
in a string form.</p>
</div>
<div class="paragraph">
<p>This is an example of handling loading errors (<a href=
"samples/load_error_handling.cpp" class=
"bare">samples/load_error_handling.cpp</a>):</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class=
"tok-n">xml_document</span> <span class=
"tok-n">doc</span><span class="tok-p">;</span>
<span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class=
"tok-n">xml_parse_result</span> <span class=
"tok-n">result</span> <span class="tok-o">=</span> <span class=
"tok-n">doc</span><span class="tok-p">.</span><span class=
"tok-n">load_string</span><span class="tok-p">(</span><span class=
"tok-n">source</span><span class="tok-p">);</span>

<span class="tok-k">if</span> <span class=
"tok-p">(</span><span class="tok-n">result</span><span class=
"tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"XML ["</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-n">source</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"] parsed without errors, attr value: ["</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class="tok-p">.</span><span class="tok-n">child</span><span class="tok-p">(</span><span class="tok-s">"node"</span><span class="tok-p">).</span><span class="tok-n">attribute</span><span class="tok-p">(</span><span class="tok-s">"attr"</span><span class="tok-p">).</span><span class="tok-n">value</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">"]</span><span class="tok-se">\n\n</span><span class="tok-s">"</span><span class="tok-p">;</span>
<span class="tok-p">}</span>
<span class="tok-k">else</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"XML ["</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-n">source</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"] parsed with errors, attr value: ["</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class=
"tok-p">.</span><span class="tok-n">child</span><span class=
"tok-p">(</span><span class="tok-s">"node"</span><span class=
"tok-p">).</span><span class="tok-n">attribute</span><span class=
"tok-p">(</span><span class="tok-s">"attr"</span><span class=
"tok-p">).</span><span class="tok-n">value</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-s">"]</span><span class="tok-se">\n</span><span class=
"tok-s">"</span><span class="tok-p">;</span>
    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"Error description: "</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-n">result</span><span class="tok-p">.</span><span class=
"tok-n">description</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-s">"</span><span class="tok-se">\n</span><span class=
"tok-s">"</span><span class="tok-p">;</span>
    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"Error offset: "</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-n">result</span><span class="tok-p">.</span><span class=
"tok-n">offset</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">" (error at [..."</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-p">(</span><span class=
"tok-n">source</span> <span class="tok-o">+</span> <span class=
"tok-n">result</span><span class="tok-p">.</span><span class=
"tok-n">offset</span><span class="tok-p">)</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-s">"]</span><span class=
"tok-se">\n\n</span><span class="tok-s">"</span><span class=
"tok-p">;</span>
<span class="tok-p">}</span></code>
</pre></div>
<div class="paragraph">
<p>Sometimes XML data should be loaded from some other source than
file, i.e. HTTP URL; also you may want to load XML data from file
using non-standard functions, i.e. to use your virtual file system
facilities or to load XML from gzip-compressed files. These
scenarios either require loading document from memory, in which
case you should prepare a contiguous memory block with all XML data
and to pass it to one of buffer loading functions, or loading
document from C++ IOstream, in which case you should provide an
object which implements <code>std::istream</code> or
<code>std::wistream</code> interface.</p>
</div>
<div class="paragraph">
<p>There are different functions for loading document from memory;
they treat the passed buffer as either an immutable one
(<code>load_buffer</code>), a mutable buffer which is owned by the
caller (<code>load_buffer_inplace</code>), or a mutable buffer
which ownership belongs to pugixml
(<code>load_buffer_inplace_own</code>). There is also a simple
helper function, <code>xml_document::load</code>, for cases when
you want to load the XML document from null-terminated character
string.</p>
</div>
<div class="paragraph">
<p>This is an example of loading XML document from memory using one
of these functions (<a href="samples/load_memory.cpp" class=
"bare">samples/load_memory.cpp</a>); read the sample code for more
examples:</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-k">const</span> <span class=
"tok-kt">char</span> <span class="tok-n">source</span><span class=
"tok-p">[]</span> <span class="tok-o">=</span> <span class=
"tok-s">"&lt;mesh name='sphere'&gt;&lt;bounds&gt;0 0 1 1&lt;/bounds&gt;&lt;/mesh&gt;"</span><span class="tok-p">;</span>
<span class="tok-kt">size_t</span> <span class=
"tok-n">size</span> <span class="tok-o">=</span> <span class=
"tok-k">sizeof</span><span class="tok-p">(</span><span class=
"tok-n">source</span><span class="tok-p">);</span></code>
</pre></div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class=
"tok-c1">// You can use load_buffer_inplace to load document from mutable memory block; the block's lifetime must exceed that of document</span>
<span class="tok-kt">char</span><span class=
"tok-o">*</span> <span class="tok-n">buffer</span> <span class=
"tok-o">=</span> <span class="tok-k">new</span> <span class=
"tok-kt">char</span><span class="tok-p">[</span><span class=
"tok-n">size</span><span class="tok-p">];</span>
<span class="tok-n">memcpy</span><span class=
"tok-p">(</span><span class="tok-n">buffer</span><span class=
"tok-p">,</span> <span class="tok-n">source</span><span class=
"tok-p">,</span> <span class="tok-n">size</span><span class=
"tok-p">);</span>

<span class=
"tok-c1">// The block can be allocated by any method; the block is modified during parsing</span>
<span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class=
"tok-n">xml_parse_result</span> <span class=
"tok-n">result</span> <span class="tok-o">=</span> <span class=
"tok-n">doc</span><span class="tok-p">.</span><span class=
"tok-n">load_buffer_inplace</span><span class=
"tok-p">(</span><span class="tok-n">buffer</span><span class=
"tok-p">,</span> <span class="tok-n">size</span><span class=
"tok-p">);</span>

<span class=
"tok-c1">// You have to destroy the block yourself after the document is no longer used</span>
<span class="tok-k">delete</span><span class=
"tok-p">[]</span> <span class="tok-n">buffer</span><span class=
"tok-p">;</span></code>
</pre></div>
<div class="paragraph">
<p>This is a simple example of loading XML document from file using
streams (<a href="samples/load_stream.cpp" class=
"bare">samples/load_stream.cpp</a>); read the sample code for more
complex examples involving wide streams and locales:</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">ifstream</span> <span class=
"tok-n">stream</span><span class="tok-p">(</span><span class=
"tok-s">"weekly-utf-8.xml"</span><span class="tok-p">);</span>
<span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class=
"tok-n">xml_parse_result</span> <span class=
"tok-n">result</span> <span class="tok-o">=</span> <span class=
"tok-n">doc</span><span class="tok-p">.</span><span class=
"tok-n">load</span><span class="tok-p">(</span><span class=
"tok-n">stream</span><span class="tok-p">);</span></code>
</pre></div>
</div>
</div>
<div class="sect1">
<h4 id="access"><a class="anchor" href="#access"></a>Accessing
document data</h4>
<div class="sectionbody">
<div class="paragraph">
<p>pugixml features an extensive interface for getting various
types of data from the document and for traversing the document.
You can use various accessors to get node/attribute data, you can
traverse the child node/attribute lists via accessors or iterators,
you can do depth-first traversals with <code>xml_tree_walker</code>
objects, and you can use XPath for complex data-driven queries.</p>
</div>
<div class="paragraph">
<p>You can get node or attribute name via <code>name()</code>
accessor, and value via <code>value()</code> accessor. Note that
both functions never return null pointers - they either return a
string with the relevant content, or an empty string if name/value
is absent or if the handle is null. Also there are two notable
things for reading values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is common to store data as text contents of some node - i.e.
<code>&lt;node&gt;&lt;description&gt;This is a
node&lt;/description&gt;&lt;/node&gt;</code>. In this case,
<code>&lt;description&gt;</code> node does not have a value, but
instead has a child of type <code>node_pcdata</code> with value
<code>"This is a node"</code>. pugixml provides
<code>child_value()</code> and <code>text()</code> helper functions
to parse such data.</p>
</li>
<li>
<p>In many cases attribute values have types that are not strings -
i.e. an attribute may always contain values that should be treated
as integers, despite the fact that they are represented as strings
in XML. pugixml provides several accessors that convert attribute
value to some other type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is an example of using these functions (<a href=
"samples/traverse_base.cpp" class=
"bare">samples/traverse_base.cpp</a>):</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-k">for</span> <span class=
"tok-p">(</span><span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">xml_node</span> <span class=
"tok-n">tool</span> <span class="tok-o">=</span> <span class=
"tok-n">tools</span><span class="tok-p">.</span><span class=
"tok-n">child</span><span class="tok-p">(</span><span class=
"tok-s">"Tool"</span><span class="tok-p">);</span> <span class=
"tok-n">tool</span><span class="tok-p">;</span> <span class=
"tok-n">tool</span> <span class="tok-o">=</span> <span class=
"tok-n">tool</span><span class="tok-p">.</span><span class=
"tok-n">next_sibling</span><span class="tok-p">(</span><span class=
"tok-s">"Tool"</span><span class="tok-p">))</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"Tool "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">tool</span><span class=
"tok-p">.</span><span class="tok-n">attribute</span><span class=
"tok-p">(</span><span class="tok-s">"Filename"</span><span class=
"tok-p">).</span><span class="tok-n">value</span><span class=
"tok-p">();</span>
    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">": AllowRemote "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">tool</span><span class=
"tok-p">.</span><span class="tok-n">attribute</span><span class=
"tok-p">(</span><span class=
"tok-s">"AllowRemote"</span><span class="tok-p">).</span><span class="tok-n">as_bool</span><span class="tok-p">();</span>
    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">", Timeout "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">tool</span><span class=
"tok-p">.</span><span class="tok-n">attribute</span><span class=
"tok-p">(</span><span class="tok-s">"Timeout"</span><span class=
"tok-p">).</span><span class="tok-n">as_int</span><span class=
"tok-p">();</span>
    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">", Description '"</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">tool</span><span class=
"tok-p">.</span><span class="tok-n">child_value</span><span class=
"tok-p">(</span><span class=
"tok-s">"Description"</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">"'</span><span class="tok-se">\n</span><span class="tok-s">"</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code>
</pre></div>
<div class="paragraph">
<p>Since a lot of document traversal consists of finding the
node/attribute with the correct name, there are special functions
for that purpose. For example, <code>child("Tool")</code> returns
the first node which has the name <code>"Tool"</code>, or null
handle if there is no such node. This is an example of using such
functions (<a href="samples/traverse_base.cpp" class=
"bare">samples/traverse_base.cpp</a>):</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"Tool for *.dae generation: "</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-n">tools</span><span class="tok-p">.</span><span class=
"tok-n">find_child_by_attribute</span><span class=
"tok-p">(</span><span class="tok-s">"Tool"</span><span class=
"tok-p">,</span> <span class=
"tok-s">"OutputFileMasks"</span><span class=
"tok-p">,</span> <span class="tok-s">"*.dae"</span><span class=
"tok-p">).</span><span class="tok-n">attribute</span><span class=
"tok-p">(</span><span class="tok-s">"Filename"</span><span class=
"tok-p">).</span><span class="tok-n">value</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-s">"</span><span class="tok-se">\n</span><span class=
"tok-s">"</span><span class="tok-p">;</span>

<span class="tok-k">for</span> <span class=
"tok-p">(</span><span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">xml_node</span> <span class=
"tok-n">tool</span> <span class="tok-o">=</span> <span class=
"tok-n">tools</span><span class="tok-p">.</span><span class=
"tok-n">child</span><span class="tok-p">(</span><span class=
"tok-s">"Tool"</span><span class="tok-p">);</span> <span class=
"tok-n">tool</span><span class="tok-p">;</span> <span class=
"tok-n">tool</span> <span class="tok-o">=</span> <span class=
"tok-n">tool</span><span class="tok-p">.</span><span class=
"tok-n">next_sibling</span><span class="tok-p">(</span><span class=
"tok-s">"Tool"</span><span class="tok-p">))</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"Tool "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">tool</span><span class=
"tok-p">.</span><span class="tok-n">attribute</span><span class=
"tok-p">(</span><span class="tok-s">"Filename"</span><span class=
"tok-p">).</span><span class="tok-n">value</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-s">"</span><span class="tok-se">\n</span><span class=
"tok-s">"</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code>
</pre></div>
<div class="paragraph">
<p>Child node lists and attribute lists are simply double-linked
lists; while you can use
<code>previous_sibling</code>/<code>next_sibling</code> and other
such functions for iteration, pugixml additionally provides node
and attribute iterators, so that you can treat nodes as containers
of other nodes or attributes. All iterators are bidirectional and
support all usual iterator operations. The iterators are
invalidated if the node/attribute objects they’re pointing to are
removed from the tree; adding nodes/attributes does not invalidate
any iterators.</p>
</div>
<div class="paragraph">
<p>Here is an example of using iterators for document traversal
(<a href="samples/traverse_iter.cpp" class=
"bare">samples/traverse_iter.cpp</a>):</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-k">for</span> <span class=
"tok-p">(</span><span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class=
"tok-n">xml_node_iterator</span> <span class=
"tok-n">it</span> <span class="tok-o">=</span> <span class=
"tok-n">tools</span><span class="tok-p">.</span><span class=
"tok-n">begin</span><span class="tok-p">();</span> <span class=
"tok-n">it</span> <span class="tok-o">!=</span> <span class=
"tok-n">tools</span><span class="tok-p">.</span><span class=
"tok-n">end</span><span class="tok-p">();</span> <span class=
"tok-o">++</span><span class="tok-n">it</span><span class=
"tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"Tool:"</span><span class="tok-p">;</span>

    <span class="tok-k">for</span> <span class=
"tok-p">(</span><span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class=
"tok-n">xml_attribute_iterator</span> <span class=
"tok-n">ait</span> <span class="tok-o">=</span> <span class=
"tok-n">it</span><span class="tok-o">-&gt;</span><span class=
"tok-n">attributes_begin</span><span class=
"tok-p">();</span> <span class="tok-n">ait</span> <span class=
"tok-o">!=</span> <span class="tok-n">it</span><span class=
"tok-o">-&gt;</span><span class=
"tok-n">attributes_end</span><span class=
"tok-p">();</span> <span class="tok-o">++</span><span class=
"tok-n">ait</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-s">" "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">ait</span><span class=
"tok-o">-&gt;</span><span class="tok-n">name</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-s">"="</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-n">ait</span><span class="tok-o">-&gt;</span><span class=
"tok-n">value</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>

    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">endl</span><span class=
"tok-p">;</span>
<span class="tok-p">}</span></code>
</pre></div>
<div class="paragraph">
<p>If your C++ compiler supports range-based for-loop (this is a
C++11 feature, at the time of writing it’s supported by Microsoft
Visual Studio 11 Beta, GCC 4.6 and Clang 3.0), you can use it to
enumerate nodes/attributes. Additional helpers are provided to
support this; note that they are also compatible with <a href=
"http://www.boost.org/libs/foreach/">Boost Foreach</a>, and
possibly other pre-C++11 foreach facilities.</p>
</div>
<div class="paragraph">
<p>Here is an example of using C++11 range-based for loop for
document traversal (<a href="samples/traverse_rangefor.cpp" class=
"bare">samples/traverse_rangefor.cpp</a>):</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-k">for</span> <span class=
"tok-p">(</span><span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">xml_node</span> <span class=
"tok-nl">tool</span><span class="tok-p">:</span> <span class=
"tok-n">tools</span><span class="tok-p">.</span><span class=
"tok-n">children</span><span class="tok-p">(</span><span class=
"tok-s">"Tool"</span><span class="tok-p">))</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"Tool:"</span><span class="tok-p">;</span>

    <span class="tok-k">for</span> <span class=
"tok-p">(</span><span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class=
"tok-n">xml_attribute</span> <span class=
"tok-nl">attr</span><span class="tok-p">:</span> <span class=
"tok-n">tool</span><span class="tok-p">.</span><span class=
"tok-n">attributes</span><span class="tok-p">())</span>
    <span class="tok-p">{</span>
        <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-s">" "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class=
"tok-p">.</span><span class="tok-n">name</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-s">"="</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-n">attr</span><span class="tok-p">.</span><span class=
"tok-n">value</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>

    <span class="tok-k">for</span> <span class=
"tok-p">(</span><span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">xml_node</span> <span class=
"tok-nl">child</span><span class="tok-p">:</span> <span class=
"tok-n">tool</span><span class="tok-p">.</span><span class=
"tok-n">children</span><span class="tok-p">())</span>
    <span class="tok-p">{</span>
        <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">", child "</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-n">child</span><span class="tok-p">.</span><span class=
"tok-n">name</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>

    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">endl</span><span class=
"tok-p">;</span>
<span class="tok-p">}</span></code>
</pre></div>
<div class="paragraph">
<p>The methods described above allow traversal of immediate
children of some node; if you want to do a deep tree traversal,
you’ll have to do it via a recursive function or some equivalent
method. However, pugixml provides a helper for depth-first
traversal of a subtree. In order to use it, you have to implement
<code>xml_tree_walker</code> interface and to call
<code>traverse</code> function.</p>
</div>
<div class="paragraph">
<p>This is an example of traversing tree hierarchy with
xml_tree_walker (<a href="samples/traverse_walker.cpp" class=
"bare">samples/traverse_walker.cpp</a>):</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-k">struct</span> <span class=
"tok-nl">simple_walker</span><span class=
"tok-p">:</span> <span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">xml_tree_walker</span>
<span class="tok-p">{</span>
    <span class="tok-k">virtual</span> <span class=
"tok-kt">bool</span> <span class=
"tok-n">for_each</span><span class="tok-p">(</span><span class=
"tok-n">pugi</span><span class="tok-o">::</span><span class=
"tok-n">xml_node</span><span class=
"tok-o">&amp;</span> <span class="tok-n">node</span><span class=
"tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-k">for</span> <span class=
"tok-p">(</span><span class="tok-kt">int</span> <span class=
"tok-n">i</span> <span class="tok-o">=</span> <span class=
"tok-mi">0</span><span class="tok-p">;</span> <span class=
"tok-n">i</span> <span class="tok-o">&lt;</span> <span class=
"tok-n">depth</span><span class="tok-p">();</span> <span class=
"tok-o">++</span><span class="tok-n">i</span><span class=
"tok-p">)</span> <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-s">"  "</span><span class=
"tok-p">;</span> <span class="tok-c1">// indentation</span>

        <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-n">node_types</span><span class="tok-p">[</span><span class=
"tok-n">node</span><span class="tok-p">.</span><span class=
"tok-n">type</span><span class="tok-p">()]</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">": name='"</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">node</span><span class=
"tok-p">.</span><span class="tok-n">name</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-s">"', value='"</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">node</span><span class=
"tok-p">.</span><span class="tok-n">value</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-s">"'</span><span class="tok-se">\n</span><span class=
"tok-s">"</span><span class="tok-p">;</span>

        <span class="tok-k">return</span> <span class=
"tok-nb">true</span><span class="tok-p">;</span> <span class=
"tok-c1">// continue traversal</span>
    <span class="tok-p">}</span>
<span class="tok-p">};</span></code>
</pre></div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-n">simple_walker</span> <span class=
"tok-n">walker</span><span class="tok-p">;</span>
<span class="tok-n">doc</span><span class=
"tok-p">.</span><span class="tok-n">traverse</span><span class=
"tok-p">(</span><span class="tok-n">walker</span><span class=
"tok-p">);</span></code>
</pre></div>
<div class="paragraph">
<p>Finally, for complex queries often a higher-level DSL is needed.
pugixml provides an implementation of XPath 1.0 language for such
queries. The complete description of XPath usage can be found in
the manual, but here are some examples:</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class=
"tok-n">xpath_node_set</span> <span class=
"tok-n">tools</span> <span class="tok-o">=</span> <span class=
"tok-n">doc</span><span class="tok-p">.</span><span class=
"tok-n">select_nodes</span><span class="tok-p">(</span><span class=
"tok-s">"/Profile/Tools/Tool[@AllowRemote='true' and @DeriveCaptionFrom='lastparam']"</span><span class="tok-p">);</span>

<span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"Tools:</span><span class="tok-se">\n</span><span class=
"tok-s">"</span><span class="tok-p">;</span>

<span class="tok-k">for</span> <span class=
"tok-p">(</span><span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class=
"tok-n">xpath_node_set</span><span class=
"tok-o">::</span><span class=
"tok-n">const_iterator</span> <span class=
"tok-n">it</span> <span class="tok-o">=</span> <span class=
"tok-n">tools</span><span class="tok-p">.</span><span class=
"tok-n">begin</span><span class="tok-p">();</span> <span class=
"tok-n">it</span> <span class="tok-o">!=</span> <span class=
"tok-n">tools</span><span class="tok-p">.</span><span class=
"tok-n">end</span><span class="tok-p">();</span> <span class=
"tok-o">++</span><span class="tok-n">it</span><span class=
"tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">xpath_node</span> <span class=
"tok-n">node</span> <span class="tok-o">=</span> <span class=
"tok-o">*</span><span class="tok-n">it</span><span class=
"tok-p">;</span>
    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">node</span><span class=
"tok-p">.</span><span class="tok-n">node</span><span class=
"tok-p">().</span><span class="tok-n">attribute</span><span class=
"tok-p">(</span><span class="tok-s">"Filename"</span><span class=
"tok-p">).</span><span class="tok-n">value</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-s">"</span><span class="tok-se">\n</span><span class=
"tok-s">"</span><span class="tok-p">;</span>
<span class="tok-p">}</span>

<span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">xpath_node</span> <span class=
"tok-n">build_tool</span> <span class="tok-o">=</span> <span class=
"tok-n">doc</span><span class="tok-p">.</span><span class=
"tok-n">select_node</span><span class="tok-p">(</span><span class=
"tok-s">"//Tool[contains(Description, 'build system')]"</span><span class="tok-p">);</span>

<span class="tok-k">if</span> <span class=
"tok-p">(</span><span class="tok-n">build_tool</span><span class=
"tok-p">)</span>
    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"Build tool: "</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-n">build_tool</span><span class="tok-p">.</span><span class=
"tok-n">node</span><span class="tok-p">().</span><span class=
"tok-n">attribute</span><span class="tok-p">(</span><span class=
"tok-s">"Filename"</span><span class="tok-p">).</span><span class=
"tok-n">value</span><span class="tok-p">()</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-s">"</span><span class=
"tok-se">\n</span><span class="tok-s">"</span><span class=
"tok-p">;</span></code>
</pre></div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">XPath functions throw
<code>xpath_exception</code> objects on error; the sample above
does not catch these exceptions.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h4 id="modify"><a class="anchor" href="#modify"></a>Modifying
document data</h4>
<div class="sectionbody">
<div class="paragraph">
<p>The document in pugixml is fully mutable: you can completely
change the document structure and modify the data of
nodes/attributes. All functions take care of memory management and
structural integrity themselves, so they always result in
structurally valid tree - however, it is possible to create an
invalid XML tree (for example, by adding two attributes with the
same name or by setting attribute/node name to empty/invalid
string). Tree modification is optimized for performance and for
memory consumption, so if you have enough memory you can create
documents from scratch with pugixml and later save them to
file/stream instead of relying on error-prone manual text writing
and without too much overhead.</p>
</div>
<div class="paragraph">
<p>All member functions that change node/attribute data or
structure are non-constant and thus can not be called on constant
handles. However, you can easily convert constant handle to
non-constant one by simple assignment: <code>void foo(const
pugi::xml_node&amp; n) { pugi::xml_node nc = n; }</code>, so
const-correctness here mainly provides additional
documentation.</p>
</div>
<div class="paragraph">
<p>As discussed before, nodes can have name and value, both of
which are strings. Depending on node type, name or value may be
absent. You can use <code>set_name</code> and
<code>set_value</code> member functions to set them. Similar
functions are available for attributes; however, the
<code>set_value</code> function is overloaded for some other types
except strings, like floating-point numbers. Also, attribute value
can be set using an assignment operator. This is an example of
setting node/attribute name and value (<a href=
"samples/modify_base.cpp" class=
"bare">samples/modify_base.cpp</a>):</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">xml_node</span> <span class=
"tok-n">node</span> <span class="tok-o">=</span> <span class=
"tok-n">doc</span><span class="tok-p">.</span><span class=
"tok-n">child</span><span class="tok-p">(</span><span class=
"tok-s">"node"</span><span class="tok-p">);</span>

<span class="tok-c1">// change node name</span>
<span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">node</span><span class=
"tok-p">.</span><span class="tok-n">set_name</span><span class=
"tok-p">(</span><span class="tok-s">"notnode"</span><span class=
"tok-p">);</span>
<span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">", new node name: "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">node</span><span class=
"tok-p">.</span><span class="tok-n">name</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-n">std</span><span class="tok-o">::</span><span class=
"tok-n">endl</span><span class="tok-p">;</span>

<span class="tok-c1">// change comment text</span>
<span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class=
"tok-p">.</span><span class="tok-n">last_child</span><span class=
"tok-p">().</span><span class="tok-n">set_value</span><span class=
"tok-p">(</span><span class=
"tok-s">"useless comment"</span><span class="tok-p">);</span>
<span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">", new comment text: "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class=
"tok-p">.</span><span class="tok-n">last_child</span><span class=
"tok-p">().</span><span class="tok-n">value</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-n">std</span><span class="tok-o">::</span><span class=
"tok-n">endl</span><span class="tok-p">;</span>

<span class=
"tok-c1">// we can't change value of the element or name of the comment</span>
<span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">node</span><span class=
"tok-p">.</span><span class="tok-n">set_value</span><span class=
"tok-p">(</span><span class="tok-s">"1"</span><span class=
"tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-s">", "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class=
"tok-p">.</span><span class="tok-n">last_child</span><span class=
"tok-p">().</span><span class="tok-n">set_name</span><span class=
"tok-p">(</span><span class="tok-s">"2"</span><span class=
"tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-n">std</span><span class="tok-o">::</span><span class=
"tok-n">endl</span><span class="tok-p">;</span></code>
</pre></div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class=
"tok-n">xml_attribute</span> <span class=
"tok-n">attr</span> <span class="tok-o">=</span> <span class=
"tok-n">node</span><span class="tok-p">.</span><span class=
"tok-n">attribute</span><span class="tok-p">(</span><span class=
"tok-s">"id"</span><span class="tok-p">);</span>

<span class="tok-c1">// change attribute name/value</span>
<span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class=
"tok-p">.</span><span class="tok-n">set_name</span><span class=
"tok-p">(</span><span class="tok-s">"key"</span><span class=
"tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-s">", "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class=
"tok-p">.</span><span class="tok-n">set_value</span><span class=
"tok-p">(</span><span class="tok-s">"345"</span><span class=
"tok-p">);</span>
<span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">", new attribute: "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class=
"tok-p">.</span><span class="tok-n">name</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-s">"="</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-n">attr</span><span class="tok-p">.</span><span class=
"tok-n">value</span><span class="tok-p">()</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">endl</span><span class=
"tok-p">;</span>

<span class="tok-c1">// we can use numbers or booleans</span>
<span class="tok-n">attr</span><span class=
"tok-p">.</span><span class="tok-n">set_value</span><span class=
"tok-p">(</span><span class="tok-mf">1.234</span><span class=
"tok-p">);</span>
<span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"new attribute value: "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class=
"tok-p">.</span><span class="tok-n">value</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-n">std</span><span class="tok-o">::</span><span class=
"tok-n">endl</span><span class="tok-p">;</span>

<span class=
"tok-c1">// we can also use assignment operators for more concise code</span>
<span class="tok-n">attr</span> <span class=
"tok-o">=</span> <span class="tok-nb">true</span><span class=
"tok-p">;</span>
<span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"final attribute value: "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">attr</span><span class=
"tok-p">.</span><span class="tok-n">value</span><span class=
"tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-n">std</span><span class="tok-o">::</span><span class=
"tok-n">endl</span><span class="tok-p">;</span></code>
</pre></div>
<div class="paragraph">
<p>Nodes and attributes do not exist without a document tree, so
you can’t create them without adding them to some document. A node
or attribute can be created at the end of node/attribute list or
before/after some other node. All insertion functions return the
handle to newly created object on success, and null handle on
failure. Even if the operation fails (for example, if you’re trying
to add a child node to PCDATA node), the document remains in
consistent state, but the requested node/attribute is not
added.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content"><code>attribute()</code> and
<code>child()</code> functions do not add attributes or nodes to
the tree, so code like <code>node.attribute("id") = 123;</code>
will not do anything if <code>node</code> does not have an
attribute with name <code>"id"</code>. Make sure you’re operating
with existing attributes/nodes by adding them if necessary.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is an example of adding new attributes/nodes to the
document (<a href="samples/modify_add.cpp" class=
"bare">samples/modify_add.cpp</a>):</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-c1">// add node with some name</span>
<span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">xml_node</span> <span class=
"tok-n">node</span> <span class="tok-o">=</span> <span class=
"tok-n">doc</span><span class="tok-p">.</span><span class=
"tok-n">append_child</span><span class="tok-p">(</span><span class=
"tok-s">"node"</span><span class="tok-p">);</span>

<span class="tok-c1">// add description node with text child</span>
<span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">xml_node</span> <span class=
"tok-n">descr</span> <span class="tok-o">=</span> <span class=
"tok-n">node</span><span class="tok-p">.</span><span class=
"tok-n">append_child</span><span class="tok-p">(</span><span class=
"tok-s">"description"</span><span class="tok-p">);</span>
<span class="tok-n">descr</span><span class=
"tok-p">.</span><span class="tok-n">append_child</span><span class=
"tok-p">(</span><span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">node_pcdata</span><span class=
"tok-p">).</span><span class="tok-n">set_value</span><span class=
"tok-p">(</span><span class=
"tok-s">"Simple node"</span><span class="tok-p">);</span>

<span class=
"tok-c1">// add param node before the description</span>
<span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">xml_node</span> <span class=
"tok-n">param</span> <span class="tok-o">=</span> <span class=
"tok-n">node</span><span class="tok-p">.</span><span class=
"tok-n">insert_child_before</span><span class=
"tok-p">(</span><span class="tok-s">"param"</span><span class=
"tok-p">,</span> <span class="tok-n">descr</span><span class=
"tok-p">);</span>

<span class="tok-c1">// add attributes to param node</span>
<span class="tok-n">param</span><span class=
"tok-p">.</span><span class=
"tok-n">append_attribute</span><span class=
"tok-p">(</span><span class="tok-s">"name"</span><span class=
"tok-p">)</span> <span class="tok-o">=</span> <span class=
"tok-s">"version"</span><span class="tok-p">;</span>
<span class="tok-n">param</span><span class=
"tok-p">.</span><span class=
"tok-n">append_attribute</span><span class=
"tok-p">(</span><span class="tok-s">"value"</span><span class=
"tok-p">)</span> <span class="tok-o">=</span> <span class=
"tok-mf">1.1</span><span class="tok-p">;</span>
<span class="tok-n">param</span><span class=
"tok-p">.</span><span class=
"tok-n">insert_attribute_after</span><span class=
"tok-p">(</span><span class="tok-s">"type"</span><span class=
"tok-p">,</span> <span class="tok-n">param</span><span class=
"tok-p">.</span><span class="tok-n">attribute</span><span class=
"tok-p">(</span><span class="tok-s">"name"</span><span class=
"tok-p">))</span> <span class="tok-o">=</span> <span class=
"tok-s">"float"</span><span class="tok-p">;</span></code>
</pre></div>
<div class="paragraph">
<p>If you do not want your document to contain some node or
attribute, you can remove it with <code>remove_attribute</code> and
<code>remove_child</code> functions. Removing the attribute or node
invalidates all handles to the same underlying object, and also
invalidates all iterators pointing to the same object. Removing
node also invalidates all past-the-end iterators to its attribute
or child node list. Be careful to ensure that all such handles and
iterators either do not exist or are not used after the
attribute/node is removed.</p>
</div>
<div class="paragraph">
<p>This is an example of removing attributes/nodes from the
document (<a href="samples/modify_remove.cpp" class=
"bare">samples/modify_remove.cpp</a>):</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class=
"tok-c1">// remove description node with the whole subtree</span>
<span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">xml_node</span> <span class=
"tok-n">node</span> <span class="tok-o">=</span> <span class=
"tok-n">doc</span><span class="tok-p">.</span><span class=
"tok-n">child</span><span class="tok-p">(</span><span class=
"tok-s">"node"</span><span class="tok-p">);</span>
<span class="tok-n">node</span><span class=
"tok-p">.</span><span class="tok-n">remove_child</span><span class=
"tok-p">(</span><span class=
"tok-s">"description"</span><span class="tok-p">);</span>

<span class="tok-c1">// remove id attribute</span>
<span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">xml_node</span> <span class=
"tok-n">param</span> <span class="tok-o">=</span> <span class=
"tok-n">node</span><span class="tok-p">.</span><span class=
"tok-n">child</span><span class="tok-p">(</span><span class=
"tok-s">"param"</span><span class="tok-p">);</span>
<span class="tok-n">param</span><span class=
"tok-p">.</span><span class=
"tok-n">remove_attribute</span><span class=
"tok-p">(</span><span class="tok-s">"value"</span><span class=
"tok-p">);</span>

<span class=
"tok-c1">// we can also remove nodes/attributes by handles</span>
<span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class=
"tok-n">xml_attribute</span> <span class=
"tok-n">id</span> <span class="tok-o">=</span> <span class=
"tok-n">param</span><span class="tok-p">.</span><span class=
"tok-n">attribute</span><span class="tok-p">(</span><span class=
"tok-s">"name"</span><span class="tok-p">);</span>
<span class="tok-n">param</span><span class=
"tok-p">.</span><span class=
"tok-n">remove_attribute</span><span class=
"tok-p">(</span><span class="tok-n">id</span><span class=
"tok-p">);</span></code>
</pre></div>
</div>
</div>
<div class="sect1">
<h4 id="saving"><a class="anchor" href="#saving"></a>Saving
document</h4>
<div class="sectionbody">
<div class="paragraph">
<p>Often after creating a new document or loading the existing one
and processing it, it is necessary to save the result back to file.
Also it is occasionally useful to output the whole document or a
subtree to some stream; use cases include debug printing,
serialization via network or other text-oriented medium, etc.
pugixml provides several functions to output any subtree of the
document to a file, stream or another generic transport interface;
these functions allow to customize the output format, and also
perform necessary encoding conversions.</p>
</div>
<div class="paragraph">
<p>Before writing to the destination the node/attribute data is
properly formatted according to the node type; all special XML
symbols, such as &lt; and &amp;, are properly escaped. In order to
guard against forgotten node/attribute names, empty node/attribute
names are printed as <code>":anonymous"</code>. For well-formed
output, make sure all node and attribute names are set to
meaningful values.</p>
</div>
<div class="paragraph">
<p>If you want to save the whole document to a file, you can use
the <code>save_file</code> function, which returns
<code>true</code> on success. This is a simple example of saving
XML document to file (<a href="samples/save_file.cpp" class=
"bare">samples/save_file.cpp</a>):</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-c1">// save document to file</span>
<span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"Saving result: "</span> <span class=
"tok-o">&lt;&lt;</span> <span class="tok-n">doc</span><span class=
"tok-p">.</span><span class="tok-n">save_file</span><span class=
"tok-p">(</span><span class=
"tok-s">"save_file_output.xml"</span><span class=
"tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class=
"tok-n">std</span><span class="tok-o">::</span><span class=
"tok-n">endl</span><span class="tok-p">;</span></code>
</pre></div>
<div class="paragraph">
<p>To enhance interoperability pugixml provides functions for
saving document to any object which implements C++
<code>std::ostream</code> interface. This allows you to save
documents to any standard C++ stream (i.e. file stream) or any
third-party compliant implementation (i.e. Boost Iostreams). Most
notably, this allows for easy debug output, since you can use
<code>std::cout</code> stream as saving target. There are two
functions, one works with narrow character streams, another handles
wide character ones.</p>
</div>
<div class="paragraph">
<p>This is a simple example of saving XML document to standard
output (<a href="samples/save_stream.cpp" class=
"bare">samples/save_stream.cpp</a>):</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class=
"tok-c1">// save document to standard output</span>
<span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span> <span class=
"tok-o">&lt;&lt;</span> <span class=
"tok-s">"Document:</span><span class="tok-se">\n</span><span class=
"tok-s">"</span><span class="tok-p">;</span>
<span class="tok-n">doc</span><span class=
"tok-p">.</span><span class="tok-n">save</span><span class=
"tok-p">(</span><span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">cout</span><span class=
"tok-p">);</span></code>
</pre></div>
<div class="paragraph">
<p>All of the above saving functions are implemented in terms of
writer interface. This is a simple interface with a single
function, which is called several times during output process with
chunks of document data as input. In order to output the document
via some custom transport, for example sockets, you should create
an object which implements <code>xml_writer_file</code> interface
and pass it to <code>xml_document::save</code> function.</p>
</div>
<div class="paragraph">
<p>This is a simple example of custom writer for saving document
data to STL string (<a href="samples/save_custom_writer.cpp" class=
"bare">samples/save_custom_writer.cpp</a>); read the sample code
for more complex examples:</p>
</div>
<div class="listingblock content">
<pre class="pygments highlight">
<code><span class="tok-k">struct</span> <span class=
"tok-nl">xml_string_writer</span><span class=
"tok-p">:</span> <span class="tok-n">pugi</span><span class=
"tok-o">::</span><span class="tok-n">xml_writer</span>
<span class="tok-p">{</span>
    <span class="tok-n">std</span><span class=
"tok-o">::</span><span class="tok-n">string</span> <span class=
"tok-n">result</span><span class="tok-p">;</span>

    <span class="tok-k">virtual</span> <span class=
"tok-kt">void</span> <span class="tok-nf">write</span><span class=
"tok-p">(</span><span class="tok-k">const</span> <span class=
"tok-kt">void</span><span class="tok-o">*</span> <span class=
"tok-n">data</span><span class="tok-p">,</span> <span class=
"tok-kt">size_t</span> <span class="tok-n">size</span><span class=
"tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-n">result</span><span class=
"tok-p">.</span><span class="tok-n">append</span><span class=
"tok-p">(</span><span class="tok-k">static_cast</span><span class=
"tok-o">&lt;</span><span class="tok-k">const</span> <span class=
"tok-kt">char</span><span class="tok-o">*&gt;</span><span class=
"tok-p">(</span><span class="tok-n">data</span><span class=
"tok-p">),</span> <span class="tok-n">size</span><span class=
"tok-p">);</span>
    <span class="tok-p">}</span>
<span class="tok-p">};</span></code>
</pre></div>
<div class="paragraph">
<p>While the previously described functions save the whole document
to the destination, it is easy to save a single subtree. Instead of
calling <code>xml_document::save</code>, just call
<code>xml_node::print</code> function on the target node. You can
save node contents to C++ IOstream object or custom writer in this
way. Saving a subtree slightly differs from saving the whole
document; <a href="manual/saving.html#saving.subtree">read the
manual</a> for more information.</p>
</div>
</div>
</div>
<div class="sect1">
<h4 id="feedback"><a class="anchor" href=
"#feedback"></a>Feedback</h4>
<div class="sectionbody">
<div class="paragraph">
<p>If you believe you’ve found a bug in pugixml, please file an
issue via <a href=
"https://github.com/zeux/pugixml/issues/new">issue submission
form</a>. Be sure to include the relevant information so that the
bug can be reproduced: the version of pugixml, compiler version and
target architecture, the code that uses pugixml and exhibits the
bug, etc. Feature requests and contributions can be filed as
issues, too.</p>
</div>
<div class="paragraph">
<p>If filing an issue is not possible due to privacy or other
concerns, you can contact pugixml author by e-mail directly:
<a href=
"mailto:arseny.kapoulkine@gmail.com">arseny.kapoulkine@gmail.com</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h4 id="license"><a class="anchor" href="#license"></a>License</h4>
<div class="sectionbody">
<div class="paragraph">
<p>The pugixml library is distributed under the MIT license:</p>
</div>
<div class="literalblock content">
<pre>
Copyright (c) 2006-2015 Arseny Kapoulkine

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
</pre></div>
<div class="paragraph">
<p>This means that you can freely use pugixml in your applications,
both open-source and proprietary. If you use pugixml in a product,
it is sufficient to add an acknowledgment like this to the product
distribution:</p>
</div>
<div class="literalblock content">
<pre>
This software is based on pugixml library (http://pugixml.org).
pugixml is Copyright (C) 2006-2015 Arseny Kapoulkine.
</pre></div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1"><a href=
"#_footnoteref_1">1</a>. All trademarks used are properties of
their respective owners.</div>
</div>
<div id="footer">
<div id="footer-text">Last updated 2015-10-10 13:43:12 PDT</div>
</div>

        <div id="page-content-end"></div>
    </div>
    <div id="footer">    <div id="metadata">
    Laatst gewijzigd
            op
        19-10-2015
        om
        05:14
        
                door
                    <a href="mailto:Jan.Cnops@UGent.be">Jan Cnops</a>
                
        
    </div>
<div id="tag">intranetr/0.10.0</div>
<div id="footer-end"></div>
</div>
</div>
</div>
</body>

</html>

<!-- 91 ms / 893 KB -->
