\chapter{Uitwendige gegevensstructuren}
\begin{itemize}
    \item Als de grootte van de gegevens de capaciteit van het intern geheugen overschrijdt, moeten deze gegevens opgeslagen worden in extern geheugen.
    \item We willen dat woordenboekoperaties nog steeds efficiënt uitgevoerd worden.
    \item Een harde schijf is veel trager dan een processor.
    \item Daarom moet het aantal schijfoperaties geminimaliseerd worden.
\end{itemize}

\section{B-trees}
\begin{itemize}
    \item Uitwendige evenwichte zoekboom.
    \item Heeft een zeer kleine hoogte.
    \item Het aantal sleutels $n$ is wel zeer groot.
    \item Er worden dus meerdere kinderen per knoop opgeslagen.
    \item Knopen kunnen best een volledige schijfpagina benutten.
\end{itemize}

\subsection{Definitie}
\begin{itemize}
    \item Een B-tree heeft een orde $m$ waarbij $m > 2$.
    \begin{itemize}
        \item Elke inwendige knoop heeft hoogstens $m$ kinderen.
        \item Elke inwendige knoop, behalve de wortel, heeft minstens $\lceil m/2 \rceil$ kinderen.
        \item Elke inwendige knoop met $k + 1$ kinderen bevat $k$ sleutels. 
        \item Elk blad bevat hoogstens $m - 1$ en minstens $\lceil m/2 \rceil - 1$  sleutels.
        \item De wortel bevat tenminste 2 kinderen, tenzij hij een blad is.
        \item Als de wortel een blad is bevat hij minstens 1 sleutel.
        \item Alle bladeren bevinden zich op hetzelfde niveau.
    \end{itemize}
    \item Elke knoop bevat het volgende:
    \begin{itemize}
        \item Een geheel getal $k$ dan het huidig aantal sleutels in de knoop aanduidt.
        \item Een tabel voor maximaal $m$ pointers naar de kinderen van de knoop.
        \item Een tabel voor maximaal $m - 1$ sleutels, die stijgend gerangschikt zijn.
        \begin{itemize}
            \item Er is ook een tabel die bijhorende informatie per sleutel bijhoudt.
            \item De $k$ geordende sleutels van de inwendige knoop verdelen het sleutelbereik in $k + 1$ deelgebieden.
            \item De sleutels uit de deelboom van het $i$-de kind $c_i$ liggen tussen de sleutels $s_{i - 1}$ en $s_i$.
        \end{itemize} 
        \item Een logische waarde $b$ die aanduidt of de knoop een blad is of niet.
    \end{itemize}
    \item $2-3$ bomen ($m=3$) of $2-3-4$ bomen ($m=4$) zijn eenvoudige voorbeelden van B-trees. Normaal is $m$ wel groter.
\end{itemize}

\subsection{Eigenschappen}
\begin{itemize}
    \item Het minimaal aantal knopen voor een boom met hoogte $h$ is
    $$1 + 2 + 2g + \dots + 2g^{h - 1} = 1 + 2\sum_{i=0}^{h - 1}g^i = 1 + 2\bigg(\frac{1-g^h}{1-g}\bigg) $$
    \begin{itemize}
        \item De wortel van een minimale boom heeft slechts 1 sleutel en twee kinderen.
        \item Elk kind heeft minimum $g = \lceil m/2 \rceil$ kinderen.
    \end{itemize}
    \item De hoogte is bijgevolg $O(\lg n)$.
    \begin{itemize}
        \item Elke knoop heeft minstens $g - 1$ sleutels, behalve de wortel, die er minstens één heeft.
        \begin{align*}
            & n \geq 1 + 2(g - 1)\bigg(\frac{g^h - 1}{g - 1} \bigg) \\
            \rightarrow \;& n \geq 2g^h - 1 \\
            \rightarrow \;& h \leq log_g\bigg(\frac{n+1}{2}\bigg)
        \end{align*}
    \end{itemize}
    \item Een B-tree met $n$ uniform verdeelde sleutels gebruikt ongeveer $\frac{n}{m\ln 2}$ schijfpaginas. 
\end{itemize}

\subsection{Woordenboekoperaties}

\subsubsection{Zoeken}
\begin{itemize}
    \item In elke knoop moet een meerwegsbeslissing genomen worden.
    \item De knoop moet eerst in het geheugen ingelezen worden.
    \item De sleutel wordt opgezocht in de gerangschikte tabel met sleutels.
    \begin{itemize}
        \item Normaal zou binair zoeken efficiënter zijn, maar deze winst is vrij onbelangrijk.
        \item Lineair zoeken kan bij kleine tabellen efficiënter uitvallen door het aantal cachefouten te minimaliseren.
    \end{itemize}
    \item Er kunnen zich nu drie situaties voordoen:
    \begin{enumerate}
        \item Als de sleutel in de tabel zit stopt het zoeken, met als resultaat een verwijzing naar de knoop op de schijf.
        \item Als de sleutel niet gevonden is en is de knoop een blad, dan zit de sleutel niet in de boom.
        \item Als de sleutel niet gevonden is en de knoop is inwendig, wordt een nieuwe knoop in het geheugen ingelezen waarvan de wortel een kind is van de huidige knoop. Het zoekproces start opnieuw met deze knoop.
    \end{enumerate}
    \item Performantie:
    \begin{itemize}
        \item Het aantal schijfoperaties is $O(h) = O(log_g n)$.
        \item De processortijd per knoop is $O(m)$.
        \item De totale performantie is $O(m\log_g n)$.
    \end{itemize}

\end{itemize}
\subsubsection{Toevoegen}
\begin{itemize}
    \item Toevoegen gebeurt \textbf{bottom-up}. Een top-down implementatie is ook mogelijk maar wordt minder gebruikt.
    \item De structuur van de boom kan gewijzigd worden.
    \item Toevoegen gebeurt altijd aan een blad.
    \item Vanuit de wortel wordt eerst het blad gezocht waarin de sleutel zou moeten zitten.
    \item Drie gevallen:
    \begin{itemize}
        \item \textbf{De B-tree is ledig.}
        \begin{itemize}
            \item De wortelknoop moet in het geheugen aangemaakt worden en gedeeltelijk ingevuld worden.
            \item De knoop wordt dan naar de schijf gekopieërd.
        \end{itemize}
        \item \textbf{De B-tree is niet ledig.}
        \begin{itemize}
            \item Het blad waarin de sleutel moet zitten wordt opgezocht. Er zijn dan twee gevallen.
        \end{itemize}
        \begin{itemize}
            \item \textbf{Het blad bevat minder dan $m$ sleutels.}
            \begin{itemize}
                \item De sleutel wordt in de juiste volgorde toegevoegd aan de tabel met sleutels.
            \end{itemize}
            \item \textbf{Het blad bevat $m$ sleutels.}
            \begin{itemize}
                \item Het blad wordt opgeslitst bij de middelste seutel.
                \item Er wordt een nieuwe knoop op hetzelfde niveau aangemaakt, waarin de gegevens rechts van de middelste sleutel terechtkomen.
                \item De middelste sleutel gaat naar de ouder.
                \item Normaal gezien heeft de ouder plaats voor deze knoop, anders wordt er opnieuw geplitst.
            \end{itemize}
        \end{itemize}
    \end{itemize}
    \item Performantie:
    \begin{itemize}
        \item In het slechtste geval worden er $h + 1$ knopen gesplitst. 
        \item Een knoop splitsen vereist drie schijfoperaties en een processortijd van $O(m)$.
        \item In het slechtste geval moet de boom tweemaal doorlopen worden.
        \begin{itemize}
            \item Eerst om de sleutel te vinden.
            \item Daarna eventueel tot de wortel splitsen.
            \good Maar het aantal schijfoperaties per niveau is constant.
        \end{itemize}
        \item Het totaal aantal schijfoperaties is dan $\Theta(h)$.
        \item De totale performantie is dan $O(mh) = O(m \log_g n)$.
    \end{itemize}
   
\end{itemize}

\subsubsection{Verwijderen}
\begin{itemize}
    \item Ook hier wordt enkel de \textbf{bottom-up} versie besproken.
    \item De gezochte sleutel kan zowel in een blad als in een inwendige knoop zitten.
    \begin{itemize}
        \item \textbf{De sleutel zit in een blad.}
        \begin{itemize}
            \item Er zijn geen kinderen meer dus kan de sleutel verwijderd worden.
            \item Het kan zijn dat het blad nu te weinig sleutels heeft (minder dan $\lceil m/2 \rceil - 1$).
            \item Er wordt een sleutel geleend van de ouder.
            \item In het slechtste geval gaat dit ontlenen door tot aan de wortel.
            \item Een sleutel ontlenen van een wortel die slechts één sleutel bevat maakt hem ledig, zodat de wortel verwijdert wordt.
        \end{itemize}
        \item \textbf{De sleutel zit in een inwendige knoop.}
        \begin{itemize}
            \item De sleutel wordt vervangen door zijn voorloper of opvolger.
            \item Als een knoop nu te weinig sleutels overhoudt, gebeurt er een \textbf{rotatie}.
            \begin{itemize}
                \item De sleutel van zijn broer gaat naar zijn ouder.
                \item De sleutel van de ouder gaat naar de knoop, die ook een kindwijzer van de broer overneemt.
                \item Dit kan enkel als er een broer is die sleutels kan missen.
                \item Als geen enkele broer een sleutel kan missen, wordt de knoop samengevoegd met een broer.
            \end{itemize}
        \end{itemize}
    \end{itemize}
    \item Performantie:
    \begin{itemize}
        \item Analoog aan toevoegen en is dan $O(m\log_g n)$.
    \end{itemize}
\end{itemize}
\subsection{Varianten van B-trees}
\begin{itemize}
    \item Nadelen van een gewone B-tree:
    \begin{itemize}
        \item De bladeren moeten plaats reserveren voor kindwijzers die toch niet gebruikt worden.
        \item Inwendige knopen kunnen gegevens bevatten en dat maakt verwijderen veel ingewikkelder.
        \item Zoeken naar een opvolger van een sleutel kan $O(\log_g n)$ schijfoperaties vereisen.
    \end{itemize}
\end{itemize}
\subsubsection{$B^+$-tree}
\begin{itemize}
    \item Alle gegevens en bijhorende informatie zitten in de bladeren.
    \item Inwendige knopen worden gebruikt als index om de gegevens snel te lokaliseren.
    \item Bladeren en inwendige knopen hebben dus een verschillende structuur.
    \item Er is ook een \textbf{sequence set}, een gelinkte lijst van alle bladeren in stijgende sleutelvolgorde.
    \item De inwendige knopen moeten enkel sleutels bevatten en geen bijhorende informatie zodat de maximale graad groter is dan de bladeren.
    \item De bladeren moeten geen plaats reserveren voor kindwijzers, zodat ze meer gegevens kunnen bevatten.
\end{itemize}
\subsubsection{Prefix $B^+$-tree}
\begin{itemize}
    \item Een variant van een $B^+$-tree voor strings.
    \item Strings kunnen echter veel plaats innemen.
    \item Om twee deelbomen van elkaar te onderscheiden wordt de kleinst mogelijke prefix bijgehouden.
\end{itemize}
\subsubsection{$B^*$-tree}
\begin{itemize}
    \item In plaats van enkel gegevens over te brengen naar een buur tijdens het splitsen, worden de gegevens verdeeld over \textbf{drie} knopen.
    \item Beter gevulde knopen betekent een minder hoge boom.
\end{itemize}
\section{Uitwendige hashing}
\begin{itemize}
    \item Waneer de volgorde van de sleutels niet belangreijk is.
    \item De woordenboekoperaties vereisen gemiddeld slechts $O(1)$.
    \item Er wordt een binaire trie (hoofdstuk 10) gebruikt.
    \begin{itemize}
        \item Wanneer een sleutel gezocht wordt, worden de sleutels niet vergeleken maar wel de opeenvolgende bits van de sleutel.
        \item Elke deelboom van een trie bevat alle sleutels met een gemeenschappelijk prefix.
        \item Alle sleutels van een deelboom kan in één pagina ondergebracht worden.
        \item Als de pagina vol geraakt, wordt de knoop (en dus de pagina) gesplitst, en beide pagina's krijgen een nieuwe trieknoop als ouder.
        \item De vorm van een trie is onafhankelijk van de toevoegvolgorde.
        \item Daarom wordt niet de bits van de sleutels gebruikt, maar de hashwaarde.
    \end{itemize}
    \item Dit hoofdstuk bespreekt twee methoden: \textbf{extendible hashing} en \textbf{linear hashing} die beiden het zoeken in de trie elimineren.

\end{itemize}

\subsection{Extendible hashing}
\begin{itemize}
    \item Het zoeken in de trie wordt geëlimineerd door de langst mogelijke prefix uit de trie als index te gebruiken in een hashtabel.
    \item Kortere prefixen komen overeen met meerdere tabelelementen die allemaal een verwijzing naar dezelfde pagina moet bevatten.
    \item 
\end{itemize}

\subsubsection{Voorbeeld}
\begin{itemize}
    \item Veronderstel een hashfunctie $h(k)$.
    \item De eerste $i$ bits van elke hashwaarde wordt gebruikt als index in de hashtabel. 
    \item De waarde van $i$ is het kleinste getal zodanig dat elk item in de hashtabel uniek is.
    \item De volgende hashwaarden worden gebruikt:
    \begin{itemize}
        \item $h(k_1) = 100100$
        \item $h(k_2) = 010110$
        \item $h(k_3) = 110110$
        \item $h(k_4) = 011110$
    \end{itemize}
    \item \textbf{$k_1$ en $k_2$ worden toegevoegd.}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.5\textwidth]{extendible_hashing_ex1}
        \caption{}
        \label{fig:extendible_hashing_ex1}
    \end{figure}
    \begin{itemize}
        \item Deze hashwaarden kunnen onderscheiden worden door het eerste bit.
    \end{itemize}
\end{itemize}

\subsection{Linear hashing}