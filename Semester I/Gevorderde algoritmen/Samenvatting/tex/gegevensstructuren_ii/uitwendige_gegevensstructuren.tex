\chapter{Uitwendige gegevensstructuren}
\begin{itemize}
    \item Als de grootte van de gegevens de capaciteit van het intern geheugen overschrijdt, moeten deze gegevens opgeslagen worden in extern geheugen.
    \item We willen dat woordenboekoperaties nog steeds efficiënt uitgevoerd worden.
    \item Een harde schijf is veel trager dan een processor.
    \item Daarom moet het aantal schijfoperaties geminimaliseerd worden.
\end{itemize}

\section{B-trees}
\begin{itemize}
    \item Uitwendige evenwichte zoekboom.
    \item Heeft een zeer kleine hoogte.
    \item Het aantal sleutels $n$ is wel zeer groot.
    \item Er worden dus meerdere kinderen per knoop opgeslagen.
    \item Knopen kunnen best een volledige schijfpagina benutten.
\end{itemize}

\subsection{Definitie}
\begin{itemize}
    \item Een B-tree heeft een orde $m$ waarbij $m > 2$.
    \begin{itemize}
        \item Elke inwendige knoop heeft hoogstens $m$ kinderen.
        \item Elke inwendige knoop, behalve de wortel, heeft minstens $\lceil m/2 \rceil$ kinderen.
        \item Elke inwendige knoop met $k + 1$ kinderen bevat $k$ sleutels. 
        \item Elk blad bevat hoogstens $m - 1$ en minstens $\lceil m/2 \rceil - 1$  sleutels.
        \item De wortel bevat tenminste 2 kinderen, tenzij hij een blad is.
        \item Als de wortel een blad is bevat hij minstens 1 sleutel.
        \item Alle bladeren bevinden zich op hetzelfde niveau.
    \end{itemize}
    \item Elke knoop bevat het volgende:
    \begin{itemize}
        \item Een geheel getal $k$ dan het huidig aantal sleutels in de knoop aanduidt.
        \item Een tabel voor maximaal $m$ pointers naar de kinderen van de knoop.
        \item Een tabel voor maximaal $m - 1$ sleutels, die stijgend gerangschikt zijn.
        \begin{itemize}
            \item Er is ook een tabel die bijbehorende informatie per sleutel bijhoudt.
            \item De $k$ geordende sleutels van de inwendige knoop verdelen het sleutelbereik in $k + 1$ deelgebieden.
            \item De sleutels uit de deelboom van het $i$-de kind $c_i$ liggen tussen de sleutels $s_{i - 1}$ en $s_i$.
        \end{itemize} 
        \item Een logische waarde $b$ die aanduidt of de knoop een blad is of niet.
    \end{itemize}
    \item $2-3$ bomen ($m=3$) of $2-3-4$ bomen ($m=4$) zijn eenvoudige voorbeelden van B-trees. Normaal is $m$ wel groter.
\end{itemize}

\subsection{Eigenschappen}
\begin{itemize}
    \item Het minimaal aantal knopen voor een boom met hoogte $h$ is
    $$1 + 2 + 2g + \dots + 2g^{h - 1} = 1 + 2\sum_{i=0}^{h - 1}g^i = 1 + 2\bigg(\frac{1-g^h}{1-g}\bigg) $$
    \begin{itemize}
        \item De wortel van een minimale boom heeft slechts 1 sleutel en twee kinderen.
        \item Elk kind heeft minimum $g = \lceil m/2 \rceil$ kinderen.
    \end{itemize}
    \item De hoogte is bijgevolg $O(\lg n)$.
    \begin{itemize}
        \item Elke knoop heeft minstens $g - 1$ sleutels, behalve de wortel, die er minstens één heeft.
        \begin{align*}
            & n \geq 1 + 2(g - 1)\bigg(\frac{g^h - 1}{g - 1} \bigg) \\
            \rightarrow \;& n \geq 2g^h - 1 \\
            \rightarrow \;& h \leq log_g\bigg(\frac{n+1}{2}\bigg)
        \end{align*}
    \end{itemize}
    \item Een B-tree met $n$ uniform verdeelde sleutels gebruikt ongeveer $\frac{n}{m\ln 2}$ schijfpaginas. 
\end{itemize}

\subsection{Woordenboekoperaties}

\subsubsection{Zoeken}
\begin{itemize}
    \item In elke knoop moet een meerwegsbeslissing genomen worden.
    \item De knoop moet eerst in het geheugen ingelezen worden.
    \item De sleutel wordt opgezocht in de gerangschikte tabel met sleutels.
    \begin{itemize}
        \item Normaal zou binair zoeken efficiënter zijn, maar deze winst is vrij onbelangrijk.
        \item Lineair zoeken kan bij kleine tabellen efficiënter uitvallen door het aantal cachefouten te minimaliseren.
    \end{itemize}
    \item Er kunnen zich nu drie situaties voordoen:
    \begin{enumerate}
        \item Als de sleutel in de tabel zit stopt het zoeken, met als resultaat een verwijzing naar de knoop op de schijf.
        \item Als de sleutel niet gevonden is en is de knoop een blad, dan zit de sleutel niet in de boom.
        \item Als de sleutel niet gevonden is en de knoop is inwendig, wordt een nieuwe knoop in het geheugen ingelezen waarvan de wortel een kind is van de huidige knoop. Het zoekproces start opnieuw met deze knoop.
    \end{enumerate}
    \item Performantie:
    \begin{itemize}
        \item Het aantal schijfoperaties is $O(h) = O(log_g n)$.
        \item De processortijd per knoop is $O(m)$.
        \item De totale performantie is $O(m\log_g n)$.
    \end{itemize}

\end{itemize}
\subsubsection{Toevoegen}
\begin{itemize}
    \item Toevoegen gebeurt \textbf{bottom-up}. Een top-down implementatie is ook mogelijk maar wordt minder gebruikt.
    \item De structuur van de boom kan gewijzigd worden.
    \item Toevoegen gebeurt altijd aan een blad.
    \item Vanuit de wortel wordt eerst het blad gezocht waarin de sleutel zou moeten zitten.
    \item Drie gevallen:
    \begin{itemize}
        \item \textbf{De B-tree is ledig.}
        \begin{itemize}
            \item De wortelknoop moet in het geheugen aangemaakt worden en gedeeltelijk ingevuld worden.
            \item De knoop wordt dan naar de schijf gekopieërd.
        \end{itemize}
        \item \textbf{De B-tree is niet ledig.}
        \begin{itemize}
            \item Het blad waarin de sleutel moet zitten wordt opgezocht. Er zijn dan twee gevallen.
        \end{itemize}
        \begin{itemize}
            \item \textbf{Het blad bevat minder dan $m$ sleutels.}
            \begin{itemize}
                \item De sleutel wordt in de juiste volgorde toegevoegd aan de tabel met sleutels.
            \end{itemize}
            \item \textbf{Het blad bevat $m$ sleutels.}
            \begin{itemize}
                \item Het blad wordt opgeslitst bij de middelste seutel.
                \item Er wordt een nieuwe knoop op hetzelfde niveau aangemaakt, waarin de gegevens rechts van de middelste sleutel terechtkomen.
                \item De middelste sleutel gaat naar de ouder.
                \item Normaal gezien heeft de ouder plaats voor deze knoop, anders wordt er opnieuw geplitst.
            \end{itemize}
        \end{itemize}
    \end{itemize}
    \item Performantie:
    \begin{itemize}
        \item In het slechtste geval worden er $h + 1$ knopen gesplitst. 
        \item Een knoop splitsen vereist drie schijfoperaties en een processortijd van $O(m)$.
        \item In het slechtste geval moet de boom tweemaal doorlopen worden.
        \begin{itemize}
            \item Eerst om de sleutel te vinden.
            \item Daarna eventueel tot de wortel splitsen.
            \good Maar het aantal schijfoperaties per niveau is constant.
        \end{itemize}
        \item Het totaal aantal schijfoperaties is $\Theta(h)$.
        \item De totale performantie is dan $O(mh) = O(m \log_g n)$.
    \end{itemize}
   
\end{itemize}

\subsubsection{Verwijderen}
\begin{itemize}
    \item Ook hier wordt enkel de \textbf{bottom-up} versie besproken.
    \item De gezochte sleutel kan zowel in een blad als in een inwendige knoop zitten.
    \begin{itemize}
        \item \textbf{De sleutel zit in een blad.}
        \begin{itemize}
            \item Er zijn geen kinderen meer dus kan de sleutel verwijderd worden.
            \item Het kan zijn dat het blad nu te weinig sleutels heeft (minder dan $\lceil m/2 \rceil - 1$).
            \item Er wordt een sleutel geleend van de ouder.
            \item In het slechtste geval gaat dit ontlenen door tot aan de wortel.
            \item Een sleutel ontlenen van een wortel die slechts één sleutel bevat maakt hem ledig, zodat de wortel verwijdert wordt.
        \end{itemize}
        \item \textbf{De sleutel zit in een inwendige knoop.}
        \begin{itemize}
            \item De sleutel wordt vervangen door zijn voorloper of opvolger.
            \item Als een knoop nu te weinig sleutels overhoudt, gebeurt er een \textbf{rotatie}.
            \begin{itemize}
                \item Een sleutel van zijn broer gaat naar zijn ouder.
                \item Een sleutel van de ouder gaat naar de knoop, die ook een kindwijzer van de broer overneemt.
                \item Dit kan enkel als er een broer is die sleutels kan missen.
                \item Als geen enkele broer een sleutel kan missen, wordt de knoop samengevoegd met een broer.
            \end{itemize}
        \end{itemize}
    \end{itemize}
    \item Performantie:
    \begin{itemize}
        \item Analoog aan toevoegen en is dan $O(m\log_g n)$.
    \end{itemize}
\end{itemize}
\subsection{Varianten van B-trees}
\begin{itemize}
    \item Nadelen van een gewone B-tree:
    \begin{itemize}
        \item De bladeren moeten plaats reserveren voor kindwijzers die toch niet gebruikt worden.
        \item Inwendige knopen kunnen gegevens bevatten en dat maakt verwijderen veel ingewikkelder.
        \item Zoeken naar een opvolger van een sleutel kan $O(\log_g n)$ schijfoperaties vereisen.
    \end{itemize}
\end{itemize}
\subsubsection{$B^+$-tree}
\begin{itemize}
    \item Alle gegevens en bijhorende informatie zitten in de bladeren.
    \item Inwendige knopen worden gebruikt als index om de gegevens snel te lokaliseren.
    \item Bladeren en inwendige knopen hebben dus een verschillende structuur.
    \item Er is ook een \textbf{sequence set}, een gelinkte lijst van alle bladeren in stijgende sleutelvolgorde.
    \item De inwendige knopen moeten enkel sleutels bevatten en geen bijhorende informatie zodat de maximale graad groter is dan de bladeren.
    \item De bladeren moeten geen plaats reserveren voor kindwijzers, zodat ze meer gegevens kunnen bevatten.
\end{itemize}
\subsubsection{Prefix $B^+$-tree}
\begin{itemize}
    \item Een variant van een $B^+$-tree voor strings.
    \item Strings kunnen echter veel plaats innemen.
    \item Om twee deelbomen van elkaar te onderscheiden wordt de kleinst mogelijke prefix bijgehouden.
\end{itemize}
\subsubsection{$B^*$-tree}
\begin{itemize}
    \item In plaats van enkel gegevens over te brengen naar een buur tijdens het splitsen, worden de gegevens verdeeld over \textbf{drie} knopen.
    \item Beter gevulde knopen betekent een minder hoge boom.
\end{itemize}
\section{Uitwendige hashing}
\begin{itemize}
    \item Waneer de volgorde van de sleutels niet belangreijk is.
    \item De woordenboekoperaties vereisen gemiddeld slechts $O(1)$.
    \item Er wordt een binaire trie (hoofdstuk 10) gebruikt.
    \begin{itemize}
        \item Wanneer een sleutel gezocht wordt, worden de sleutels niet vergeleken maar wel de opeenvolgende bits van de sleutel.
        \item Elke deelboom van een trie bevat alle sleutels met een gemeenschappelijk prefix.
        \item Alle sleutels van een deelboom kan in één pagina ondergebracht worden.
        \item Als de pagina vol geraakt, wordt de knoop (en dus de pagina) gesplitst, en beide pagina's krijgen een nieuwe trieknoop als ouder.
        \item De vorm van een trie is onafhankelijk van de toevoegvolgorde.
        \item Daarom wordt niet de bits van de sleutels gebruikt, maar de hashwaarde.
    \end{itemize}
    \item Dit hoofdstuk bespreekt twee methoden: \textbf{extendible hashing} en \textbf{linear hashing} die beiden het zoeken in de trie elimineren.

\end{itemize}

\subsection{Extendible hashing}
\begin{itemize}
    \item Het zoeken in de trie wordt geëlimineerd door de langst mogelijke prefix uit de trie als index te gebruiken in een hashtabel.
    \item Kortere prefixen komen overeen met meerdere tabelelementen die allemaal een verwijzing naar dezelfde pagina moet bevatten.
    \item Implementatie:
    \begin{itemize}
        \item Er is een hashtabel die wijzers naar schijfpagina's bevat, waarbij elke schijfpagina maximaal $m$ sleutels met bijbehorende gegevens bevat.
        \item De hashwaarden zijn gehele getallen, waarvan het bereik bepaald wordt door de breedte $w$ van een processorwoord.
        \item De laatste $d$ bits van die getallen dienen als indices in de hashtabel, zodat de tabel $2^d$ elementen bevat.
        \item De \textbf{globale diepte} is $d$ en is de lengte van het langste prefix in de trie.
        \item Alle sleutels waarvan de hashwaarde met dezelfde $d$ bits eindigt komen bij hetzelfde tabelelement terecht.
        \item Een pagina kan sleutels met hashwaarden bevatten waarvan de laatste $d$ bits verschillend zijn.
        \item Het aantal bits $k$ is de \textbf{lokale diepte} en is het aantal waarmee al haar hashwaarden eindigen.
    \end{itemize}
    \item De \textbf{woordenboekoperaties:}
    \begin{itemize}
        \item \textbf{Zoeken.}
        \begin{itemize}
            \item Bereken de hashwaarde van de sleutel.
            \item Zoek de overeenkomstige pagina via de hashtabel.
            \item Zoek sequentieel in deze pagina.
        \end{itemize}
        \item \textbf{Toevoegen.}
        \begin{itemize}
            \item Als de pagina niet vol is moet gemiddeld helft van de elementen opgeschoven worden, maar dat is verwaarloosbaar.
            \item Als de pagina vol is moet deze gesplitst worden.
            \item Alle hashwaarden in die pagina beginnen met dezelfde $k$ bits.
            \item Er wordt daarom gesplitst op het volgende bit $k + 1$. Alle elementen in de pagina waarbij die bit één is wordt overgebracht naar de nieuwe pagina.
            \item De waarde van $k$ wordt één groter zowel in de nieuwe pagina als in de oude pagina.
            \item De hashtabel moet ook aangepast worden.
            \begin{itemize}
                \item \textbf{Als $k$ kleiner was dan $d$:} de helft van de wijzers van de oude pagina moeten naar de nieuwe pagina wijzen.
                \item \textbf{Als $k$ gelijk was aan $d$:} er was maar één wijzer naar de oude pagina. De waarde van $d$ moet ook met één toenemen en de grootte van de hashtabel moet \textbf{verdubbelt} worden.
            \end{itemize}           
        \end{itemize}
        \item \textbf{Verwijderen.}
        \begin{itemize}
            \item Zien we niet.
        \end{itemize}
    \end{itemize}
    \item Als er $n$ uniform verdeelde sleutels opgeslagen zijn, dan is de verwachtingswaarde van het aantal pagina's $n/(m\ln 2) \equiv 1.44n/m$.
    
\end{itemize}

\subsubsection{Voorbeeld}
\begin{itemize}
    \item Veronderstel een hashfunctie $h(k)$.
    \item Een pagina heeft slechts plaats om één hashwaarde op te slaan.
    \item De eerste $i$ bits van elke hashwaarde wordt gebruikt als index in de hashtabel. 
    \item De waarde van $i$ is het kleinste getal zodanig dat elk item in de hashtabel uniek is.
    \item De volgende hashwaarden worden gebruikt:
    \begin{itemize}
        \item $h(k_1) = 100100$
        \item $h(k_2) = 010110$
        \item $h(k_3) = 110110$
        \item $h(k_4) = 011110$
    \end{itemize}
    \item \textbf{$k_1$ en $k_2$ worden toegevoegd.}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.5\textwidth]{extendible_hashing_ex1}
        \caption{}
        \label{fig:extendible_hashing_ex1}
    \end{figure}
    \begin{itemize}
        \item Deze hashwaarden kunnen onderscheiden worden door het eerste bit, dus $d = 1$.
        \item De hashtabel bevat nu twee elementen (figuur \ref{fig:extendible_hashing_ex1}), met twee wijzers: één naar pagina $A$ en één naar pagina $B$. 
        \item De lokale diepte $k$ van beide elementen is gelijk aan $d$, $k = d = 1$.
    \end{itemize}
    \item \textbf{$k_3$ wordt toegevoegd.}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.5\textwidth]{extendible_hashing_ex2}
        \caption{}
        \label{fig:extendible_hashing_ex2}
    \end{figure}
    \begin{itemize}
        \item Er zijn niet genoeg bits om $k_3$ te onderscheiden van $k_1$.
        \item Er wordt vergeleken op bit $k + 1$.
        \item Er wordt een nieuwe pagina $C$ aangemaakt waarin de sleutel $k_3$ opgeslagen wordt.
        \item Aangezien $k$ gelijk was aan $d$, verdubbelt de grootte van de hashtabel.              
    \end{itemize}
\end{itemize}

\subsection{Linear hashing}
\begin{itemize}
    \item Er wordt geen hashtabel gebruikt door ervoor te zorgen dat pagina's opeenvolgende adressen hebben.
    \item De $d$ eindbits van de hashwaarde worden niet gebruikt als index, maar rechtstreeks als adres van een pagina.
    \item Het gaat hier over \textbf{logische adressen}, die eenvoudig manipuleerbaar zijn en niet de \textbf{fysische adressen} die het besturingssysteem beheert.
    \item Er zijn $2^d$ adressen en evenveel pagina's.
    \item Als een pagina vol is wordt deze gesplitst, maar niet noodzakelijk de hele pagina.
    \item Pagina's worden in sequentiële volgorde gesplitst, of ze nu vol zijn of niet.
    \item Elke pagina die niet vol is (alle pagina's behalve de volle die het splitsen veroorzaakt heeft) krijgt een overflow pagina.
    \item Als de pagina aan de beurt is om te splitsen, worden zijn gegevens verdeeld over zijn overflow pagina en de pagina zelf.
    \item De \textbf{woordenboekoperaties:} 
    \begin{itemize}
        \item \textbf{Zoeken.}
        \begin{itemize}
            \item Bereken de hashwaarde van de sleutel.
            \item We moeten echter weten hoeveel eindbits er nodig zijn om de pagina te adresseren.
            \item Er wordt een variabele $p$ bijgehouden, die het adres van de volgende te splitsen pagina bijhoudt.
            \item Het adres gevormd door de $d$ eindbits wordt vergeleken met $p$. 
            \item Als $d < p$ dan is de gezochte pagina reeds gesplitst en moeten $d + 1$ eindbits gebruikt worden. Anders volstaan $d$ bits.
            \item De sleutel kan in de pagina binair of lineair gezocht worden.
        \end{itemize}
        \item \textbf{Toevoegen.}
        \begin{itemize}
            \item Eerst wordt de juiste pagina gelokaliseerd.
            \item Als de pagina vol zit moet ze gesplitst worden.
            \item Splitsen gebeurt sequentieël zodat $p = 0$ in het begin.
            \item $p$ wordt met één verhoogd tot alle $2^d$ pagina's gesplitst zijn.
            \item De waarde van $d$ wordt dan verhoogd met één, en $p$ wordt terug 0.
            \item Als pagina $p$ gesplitst wordt, is het adres van de nieuwe pagina $p + 2^d$.
        \end{itemize}
        \item \textbf{Verwijderen.}
        \begin{itemize}
            \item 
        \end{itemize}
    \end{itemize}                                                                                                                                                           
\end{itemize}