\newcommand{\nonterminal}[1]{
    \langle \textbf{#1} \rangle
}

\chapter{Zoeken in strings}
\label{ch:zoeken_in_strings}
\begin{itemize}
    \item De gebruikte symbolen:

    \begin{table}[ht]
        \centering
        \begin{tabular}{c l}
            \hline
            Symbool & Betekenis \\
            \hline
            $\Sigma$ & Het gebruikte alfabet \\
            $\Sigma*$ & De verzameling strings van eindige lengte van letters uit $\Sigma$ \\
            d & Aantal karakters in $\Sigma$ \\
            P & Patroon (de tekst die gezocht wordt) \\
            p & Lengte van P \\
            T & De hele tekst waarin gezocht wordt\\
            t & lengte van T \\
            \hline
        \end{tabular}
    \end{table}

    \item We willen een bepaalde string (het patroon P) in een langere string (de tekst T) lokaliseren.
    \item We nemen aan dat we alle plaatsen zoeken waar dat patroon voorkoomt.
    \item We veronderstellen ook dat P en T in het inwendig geheugen opgeslaan zitten.
\end{itemize}


\section{Formele talen}
\begin{itemize}
    \item Een \textbf{formele taal} over een alfabet is een verzameling eindige strings over dat alfabet.
    \item Een formele taal wordt vrij vaag gedefinieerd (maar zien we niet in de cursus).
    \item Een formele taal kan op twee manieren gedefinieerd worden: via \textbf{generatieve grammatica's} of via \textbf{reguliere expressies}.
\end{itemize}

\subsection{Generatieve grammatica's}
\begin{itemize}
    \item Een \textbf{generatieve grammatica} is een methode om een taal te beschrijven.
    \item Er is een startsymbool dat getransformeerd kan worden tot een zin van de taal met behulp van substitutieregels.
    \item Buiten de karakters $\Sigma$ van het alfabet, is er ook nog een verzameling \textbf{niet-terminale symbolen}.
    \item Een niet-terminaal symbool wordt aangeduid als
        $$\nonterminal{\dots}$$
        waarin $\textbf{\dots}$ vervangen wordt door de naam van het niet-terminale symbool. 
    \item De verzameling alle strings uit $\Sigma$ vermengd met de niet-terminale symbolen is $\Xi$, en de daarbijhorende verzameling strings $\Xi*$.
    \item Een belangrijk geval zijn de \textbf{contextvrije grammatica's}.
    \begin{itemize}
        \item Er is op elk moment een string uit $\Xi*$.
        \item Als er geen niet-terminale symbolen meer zijn krijgt men een zin in de taal, anders kan men één niet-terminaal vervangen door een string uit $\Xi*$.
        \item De taal is contextvrij omdat de substitutie onafhankelijk is wat voor en achter de betreffende niet-terminaal staat.
        \item Een voorbeeld van een contextvrije grammatica:

        \begin{align*}
             \nonterminal{S} &::= \nonterminal{AB}\;|\;\nonterminal{CD} \\
             \nonterminal{AB} &::= a\nonterminal{AB}b\;|\;\epsilon \\
             \nonterminal{CD} &::= c\nonterminal{CD}c\;|\;\epsilon
        \end{align*}
        \begin{itemize}
            \item Hierbij is $\Sigma = \{ a, b, c, d \}$ en $\epsilon$ de lege string.
            \item Deze grammatica definieert als formele taal de verzameling van alle strings ofwel bestaande uit een rij 'a's gevolgd door een even lange rij 'b's ofwel bestaande uit een rij 'c's gevolgd door een even lange rij 'd's.    
            \item De afleiding van "cccddd":
            $$\nonterminal{S} \rightarrow \nonterminal{CD} \rightarrow c\nonterminal{CD}d \rightarrow cc\nonterminal{CD}dd \rightarrow ccc\nonterminal{CD}ddd \rightarrow cccddd$$
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection{Reguliere uitdrukkingen}
\begin{itemize}
    \item Een \textbf{reguliere uitdrukking} is ook een methode om een taal te beschrijven.
    \item Een reguliere uitdrukking, of \textit{regexp}, is een string over het alfabet $\Sigma = \{\sigma_0, \sigma_1, \cdots, \sigma_{d-1}\}$ aangevuld met de symbolen $\varnothing, \epsilon, *, (, )$ en $\bot$, gedefinieerd door
    \begin{align*}
        \nonterminal{Regexp} &::= \nonterminal{basis}\;|\;\nonterminal{samengesteld} \\
        \nonterminal{basis} &::= \sigma_0|\cdots|\sigma_{d-1}|\varnothing|\epsilon \\
        \nonterminal{samengesteld} &::= \nonterminal{plus}|\nonterminal{of}|\nonterminal{ster}\\
        \nonterminal{plus} &::= (\nonterminal{Regexp}\nonterminal{Regexp})\\
        \nonterminal{of} &::= (\nonterminal{Regexp}\bot\nonterminal{Regexp})\\
        \nonterminal{ster} &::= (\nonterminal{Regexp})*
    \end{align*}
    \item Elke regexp $R$ definieert een formele taal, Taal($R$).
    \item Een taal die door een regexp gedefinieerd kan worden heet een reguliere taal.
    \item De definitie van een regexp en reguliere taal is recursief:
    \begin{enumerate}
        \item $\varnothing$ is een regexp, met als taal de lege verzameling.
        \item De lege string $\epsilon$ is een regexp met als taal Taal($\epsilon$) = \{$\epsilon$\}.
        \item  Voor elke $a \in \Sigma$ is \quotes{a} een regexp, met als taal Taal(\quotes{a}) = \{\quotes{a}\}.
    \end{enumerate}
    \item Regexps kunnen gecombineerd worden via drie operaties:

    \begin{table}[ht]
        \centering
        \begin{tabular}{c c c}
            \hline
            Operatie & Regexp & Operatie op taal/talen \\
            \hline
            Concatenatie & (RS) & Taal($R$) $\cdot$ Taal($S$) \\
            Of & $(R|S)$ & Taal($R$) $\cup$ Taal($S$) \\
            Kleenesluiting & (R)* & Taal($R$)* \\
            \hline
        \end{tabular}

    \end{table}
    \item Vaak worden verkorte notaties gebruikt:
    \begin{itemize}
        \item \textbf{Minstens eenmaal herhalen}
        $$rr* \rightarrow r+$$
        \item \textbf{Optionele uitdrukking}
        $$r|\epsilon \rightarrow r?$$
        
        \item \textbf{Unies van symbolen}
        $$a|b|c \rightarrow [abc] $$
        $$a|b|\dots|z \rightarrow [a-z] $$

        
    \end{itemize}

    \item Regexps kunnen gelinkt worden met graafproblemen.
    \item \textbf{Stelling:} Zij $G$ een gerichte multigraaf met verzameling takken $\Sigma$. Als $a$ en $b$ twee knopen van $G$ zijn dan is de verzameling $P_G(a, b)$ van paden beginnend in $a$ en eindigend in $b$ een reguliere taal over $\Sigma$.
    \item \textbf{Bewijs:}
    \begin{itemize}
        Via inductie op het aantal verbindingen $m$ van $G$.
        \item Als $m = 0$ dan
        $$P_G(a, b) = \begin{cases}
            \varnothing, \hbox{ als } a \neq b\\
            \{\epsilon\}, \hbox{ als } a = b 
        \end{cases}$$
        \item Breidt nu de graaf $G$ uit naar $G'$ door één verbinding toe te voegen.
        \begin{itemize}
            \item Een verbinding $v_{xy}$ van knoop $x$ naar knoop $y$, waarbij eventueel $x = y$.
            \item Alle paden van $a$ naar $b$ zijn één van de twee volgende vormen:
            \begin{enumerate}
                \item De paden die $v_{xy}$ niet bevatten. Deze vormen de reguliere taal $P_G(a, b)$.
                \item De paden die $v_{xy}$ wel bevatten. Deze verzameling wordt gegeven door
                $$P_G(a, x) \cdot \{v_{xy}\} \cdot (P_G(y, x) \cdot \{v_{xy}\})* \cdot P_G(y, b)$$

                Deze is bekomen uit reguliere talen en is dus regulier.
            \end{enumerate}
        \end{itemize}
    \end{itemize}
    \item 
\end{itemize}




\section{Variabele tekst}

\subsection{Een eenvoudige methode}
\begin{itemize}
    \item We zitten op een bepaalde positie $j$ in $T$.
    \item Vanaf $j$ wordt $T[j + i]$ met $P[i]$ vergeleken voor $0 < i \leq p$.
    \begin{enumerate}
        \item Het eerste geval komt voor wanneer $T[j + i] \neq P[i]$, voor $i \leq p$, en het patroon dus niet gevonden is op positie $j$ in $T$.
        \item Het tweede geval komt dan voor wanneer het patroon wel gevonden is op positie $j$ in $T$.
    \end{enumerate}
    \item Voor willekeurige strings zal $T[j]$ vaak verschillen van $P[0]$.
    \begin{itemize}
        \item Op veel posities $j$ zal de karaktervergelijking na één positie dan stoppen.
    \end{itemize}
    \item De \textbf{gemiddelde uitvoeringstijd} is $O(t)$.
    \item Het \textbf{slechtste geval} is $O(tp)$.
\end{itemize}



\subsection{Knuth-Morris-Pratt}
\subsubsection{De prefixfunctie}
\begin{itemize}
    \item Gegeven een string $P$ en index $i$ met $i \leq p$.
    \item Een string $Q$ kan voor $i$ op $P$ gelegd woorden als $i \geq q$ en als $Q$ overeenkomt met de even lange deelstring van $P$ endigend voor $i$.
    \begin{itemize}
        \item De index $i$ wijst naar de plaats \textit{voorbij} de deelstring, niet naar de laatste letter van de deelstring.
    \end{itemize}
    \item De prefixfunctie $q(i)$ van een string $P$ bepaalt voor elke stringpositie $i$, $1 \leq i \leq p$, de lengte van de langste prefix van $P$ met lengte kleiner dan $i$ dat we voor $i$ kunnen leggen.

    \item Volgende eigenschappen gelden:
    \begin{itemize}
        \item $q(0) = -$ (niet gedefinieerd)
        \item $q(1) = 0$
        \item $q(i) < i$
        \item $q(i + 1) \leq q(i) + 1$
    \end{itemize}
    \item De waarde van $q(i + 1)$ kan bepaald worden als de waarden van de vorige posities gekend zijn.
    $$q(i + 1) = \begin{cases}
        q(i) + 1 & \hbox{ als } P[q(i)] = P[i]  \\
        q(q(i)) + 1 & \hbox{ als } P[q(q(i))] = P[i] \\
        q(q(q(i))) + 1 & \hbox{ als } P[q(q(q(i)))] = P[i] \\
        \cdots \\
        0 & \hbox { als q(q(q(....))) = 0 }
    \end{cases}$$

    \begin{itemize}
        \item Stel de string \texttt{ANOANAANOANO}
        \item Dan zijn de waarden van de prefixfunctie als volgt:
        \begin{itemize}
            \item Voor $i = 2$ geldt $q(i) = 0$:
            \begin{itemize}
                \item $P[q(1)] = P[1]\;?\;\rightarrow P[0] = P[1]\;?\;\rightarrow A \neq N$
                \item $q(2) = 0$
            \end{itemize} 
            \item Voor $i = 4$ geldt $q(i) = 1$:
            \begin{itemize}
                \item $P[q(3)] = P[3]\;?\;\rightarrow P[0] = P[3]\;?\;\rightarrow A = A$
                \item $q(4) = q(3) + 1 = 0 + 1 = 1$
            \end{itemize}
            \item Voor $i = 12$ geldt $q(i) = 3$:
            \begin{itemize}
                \item $P[q(11)] = P[11]\;?\;\rightarrow P[5] = P[11]\;?\;\rightarrow A \neq O$
                \item $P(q(5)) = P[11]\;?\;\rightarrow P[2] = P[11]\;?\;\rightarrow O = O$
                \item $q(12) = q(5) + 1 = 2 + 1 = 3$
            \end{itemize}
        \end{itemize}

        \begin{table}[ht]
            \centering
            \begin{tabular}{l | c c c c c c c c c c c c c}
                     & A & N & O & A & N & A & A & N & O & A  & N  & O  & - \\
                     \hline
                i    & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12  \\
                q(i) & - & 0 & 0 & 0 & 1 & 2 & 1 & 1 & 2 & 3  & 4  & 5 & 3 
            \end{tabular}
        \end{table}
    \end{itemize}
    \item De prefixwaarden worden dus voor stijgende $i$ berekend.
    \item Wat is de \textbf{efficiëntie}?
    \begin{itemize}
        \item Er moeten $p$ prefixwaarden berekend worden.
        \item De recursierelatie wordt ook maar $p-1$ herhaald voor de voltallige bepaling van de prefixfunctie.
        \item De methode is $\Theta(p)$.
    \end{itemize}
\end{itemize}

\subsubsection{Een eenvoudige lineaire methode}
\begin{itemize}
    \item Stel een string samen bestaande uit $P$ gevolgd door $T$, gescheiden door een speciaal karakter dat in niet in beide strings voorkomt.
    \item Bepaal de prefixfunctie van deze nieuwe string, in $\Theta(n + p)$.
    \item Als de prefixwaarde van een positie $i$ gelijk is aan $p$, werd $P$ gevonden, beginnend bij index $i - p$ in $T$.
\end{itemize}


\subsubsection{Het Knuth-Morris-Prattalgoritme}
\begin{itemize}
    \item Ook een lineaire methode, maar is efficiënter.
    \item Stel dat $P$ op een bepaalde beginpositie vergeleken wordt met $T$, en dat er geen overeenkomst meer is tussen $P[i]$ en $T[j]$.
    \begin{itemize}
        \item Als $i = 0$, dan wordt $P$ één positie naar rechts geschoven en begint het vergelijken met $T$ weer bij $P[0]$.
        \item Als $i > 0$, dan is er een prefix van $P$ met lengte $i$ gevonden, dat we voor $j$ op $T$ kunnen leggen.
        \begin{itemize}
            \item Verschuif $P$ met een stap $s$ kleiner dan $i$.
            \item Er is nu een overlapping tussen het begin van $P$ en het prefix van $P$ dat we in $T$ gevonden hebben.
            \item De overlapping heeft lengte $i - s$.
            \item De overlappende delen moeten wel overeenkomen.
            \item De kleinste waarde van $s$ waarbij dit mogelijk is, is $s = i - q(i)$.
            \item Verschuif $P$ met $s$ en vergelijk verder vanaf $T[j]$ en $P[q(i)]$.
        \end{itemize}
    \end{itemize}
        \item Voorbeeld:
        \begin{itemize}
            \item Stel $P = \texttt{ANOANAANOANO}$.
            \item Stel $T = \texttt{ANOAOAANOANO}$.
            \item De waarden $q(i)$ van $P$ zijn reeds bekend, en de waarden $s$ kunnen eenvoudig berekend worden door $i - q(i)$ (Tabel \ref{table:kmp1}).
            
            \begin{table}[ht]
                \centering
                \begin{tabular}{l | c c c c c c c c c c c c c}
                    P   & A & N & O & A & N & A & A & N & O & A  & N  & O  & - \\
                        \hline
                    i    & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12  \\
                    q(i) & - & 0 & 0 & 0 & 1 & 2 & 1 & 1 & 2 & 3  & 4  & 5 & 3   \\
                    s    & - & 1 & 2 & 3 & 3 & 3 & 5 & 6 & 6 & 6 & 6 & 6 & 9
                \end{tabular}
                \caption{Het patroon $P$ en bijhorende prefixfunctie $q(i)$ en $s$-waarden.}
                \label{table:kmp1}
            \end{table}

            \item Stel nu dat we in $T$ zoeken:
            \begin{itemize}
                \item Het eerste verkeerde karakter komt voor bij $i = 4$. 
                \item Er is dus een correct prefix van lengte $4$ gevonden.
                \item We kunnen $P$ met $s = i - q(i) = 4 - q(4) = 4 - 1 = 3$ stappen verschuiven. ($P_2$ in tabel \ref{table:kmp2})
                \item We merken nu wel op dat $P[1] = N$ ook niet gelijk is aan $T[4] = O$, zodat de verschuiving eigenlijk nutteloos is.
                \item Er is een \textbf{bijkomende voorwaarde}: de verschuiving $s$ is enkel zinvol als \\ $P[i - s] \neq P[i]$.
            \end{itemize}
                        
            \begin{table}[ht]
                \centering
                \begin{tabular}{l | c c c c c c c c c c c c c}
                    i  & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12  \\
                    \hline
                    T    & A & N & O & A & O & A & A & N & O & A & N  & O  & - \\
                    P    & A & N & O & A & N & A & A & N & O & A & N  & O  & - \\
                    $P_2$    &   &   &   & A & N & O & A & N & A & A & N  & O  & A  $\cdots$\\
                \end{tabular}
                \caption{Zoeken in $T$ met $P$, enkel rekening houdend met de eenvoudige berekening van $s$-waarden. De verschuiving heeft geen resultaat, omdat er nog steeds een fout is op $i = 4$.}
                \label{table:kmp2}
            \end{table}
           \item De kleinste $s$-waarde vinden komt neer door het berekenen van een functie $q'()$, op basis van $q()$, zodat $i - q'()$ de kleinste $s$-waarde oplevert.
            
           $$q'(i) = q(q(i)) \qquad \hbox{ als } q(i) > 0 \hbox{ EN } q(i + 1) == q(i) + 1$$
           \todo{VOORBEELD}
    \end{itemize}
\end{itemize}


\subsection{Boyer-Moore}
\begin{itemize}
    \item Dit algoritme is een \textbf{variant} van het Knuth-Morris-Prattalgoritme.
    \alert Het patroon wordt van achter naar voor overlopen bij het vergelijken met de tekst.
    \item Er worden \textbf{twee heuristieken} gebruikt die grotere verschuivingen mogelijk maakt. Het maximum van de twee heuristieken wordt dan gebruikt als verschuiving:
    \begin{enumerate}
        \item \textbf{De heuristiek van het verkeerde karakter}.
        \item \textbf{De heuristiek van het juiste suffix}.
    \end{enumerate}
\end{itemize}

\subsubsection{De heuristiek van het verkeerde karakter}
\begin{itemize}
    \item Het patroon $P$ wordt van achter naar voor vergeleken.
    \item Het tekstkarakter waar een fout voorkomt noemen we $f$ (het verkeerde karakter in de tekst $T$).
    \item Als $T$ ook dit karakter bevat, op een andere positie, kan $P$ naar rechts verschoven worden.
    \begin{table}[ht]
        \centering
        \begin{tabular}{l | c c c c c c c c c c c c c}
            i    & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & \\
            \hline
            T    & A & N & O & A & O & A & A & N & O & A & N  & O  & \\
            P    & A & N & O & A & N & A & A & N & O & A & N  & O  & \\
        \end{tabular}
        \caption{Hier is $f = O$ op positie $i = 4$.}
        \label{table:bm1}
    \end{table}
    \item Om de verschuiving te bepalen wordt \textbf{de meest rechtse positie} in $P$ van elk karakter in het alfabet bijgehouden.
    \begin{itemize}
        \item Dit wordt geïmplementeerd als een tabel, MRP genaamd, geïndexeerd op de karakters van het alfabet.
        \item Tabel \ref{table:bm2} toont de MRP-tabel voor $P = \texttt{ANOANAANOANO}$.
        \begin{table}[ht]
            \centering
            \begin{tabular}{l | cccccccc}
                MRP & A & B & C & $\cdots$ & N & $\cdots$ & O &  $\cdots$ \\
                \hline
                &     9 & -1 & -1 & $\cdots$ & 10 & $\cdots$ & 8 & $\cdots$  
            \end{tabular}
            \caption{De MRP-tabel voor $P = \texttt{ANOANAANOANO}$. De waarden voor $A$ en $N$ zijn vanzelfsprekend. De waarde van $O$ is niet 11, omdat dat sowieso het eerste karakter is dat vergeleken wordt, en telt niet mee. Een karakter dat niet in het patroon voorkomt krijgt de waarde -1.}
            \label{table:bm2}
        \end{table}

        \item Het volstaat nu om de waarde $j = MRP[f]$ op te zoeken, waarbij $f$ het foute karakter in $P$ op positie $i$ is, en $P$ te verschuiven over $i - j$ posities. 
        \begin{itemize}
            \alert In het geval dat $i - j < 0$, dan bedraagt de verschuiving $1$ positie.
        \end{itemize}
    \end{itemize}
    \item Er zijn \textbf{drie varianten} van deze heuristiek:
    \begin{enumerate}
        \item \textbf{Uitgebreide heuristiek van het verkeerde karakter}.
        \begin{itemize}
            \item De MRP-tabel wordt uitgebreidt, zodat $MRP[f]$ de positie $j$ teruggeeft, \textbf{links} van foutpositie $i$ in het patroon.
            \item Hiervoor is een tweedimensionale tabel nodig en is in het algemeen een vrij slechte uitbreiding.

        \end{itemize}
        \item \textbf{Variant van Horspool}.
        \begin{itemize}
            \item De MRP-tabel wordt licht gewijzigd, zodat $MRP[f]$ de positie $j$ teruggeeft, \textbf{links} van positie $p - 1$.
            \item Het patroon $P$ moet bij een fout dan $p - 1 - j$ posities opgeschoven worden.
        \end{itemize}
        \item \textbf{Variant van Sunday}.
        \begin{itemize}
            \item ???
        \end{itemize}
    \end{enumerate}
    
\end{itemize}

\subsubsection{De heuristiek van het juiste suffix}
\begin{itemize}
    \item Hier wordt enkel de versie van de \textbf{originele Boyer-Moore} methode besproken, dus niet de varianten van Horspool of Sunday.
    \item In vele gevallen kan $f$ aan de rechterkant van foutpositie $i$ voorkomen, zodat $i - j < 0$, en er dus maar een verschuiving van 1 positie mogelijk is.
    \item Op positie $i$ in $P$ vinden we een verkeerd karakter $f$ in $T$.
    \item Er is dus een \textbf{suffix} van $P$ in $T$, met lengte $p - i - 1$.
    \item We willen weten of dit suffix $s$ nog ergens in $P$ voorkomt.
    \begin{itemize}
        \item Als er meerdere plaatsen zijn waar $s$ in $P$ voorkomt, wordt de meeste rechtse genomen.
        \item Suffixen kunnen overlappen.
    \end{itemize}
    \item We willen dus de meeste rechtste positie $j$ in $P$, waarbij $j \leq i$ waar een deelstring $s' = s$ begint.
    \item Analoog aan de prefixfunctie, is er nu een suffixfunctie $s(j)$:
    \begin{itemize}
        \item Voor elke index $j$ in $P$ wordt de lengte van het grootste suffix van $P$ bijgehouden, dat op index $j$ begint.
        \item De suffixwaarden is het omgekeerde van de prefixtabel voor het omgekeerde patroon $P$.
        \item De grootste waarde voor $j$ waarvoor $s(j) = p - i - 1$ is de waarde voor $k$.
        \item Een verschuiving $v[i]$ voor foutpositie $i$ is dan $i + 1 - k$. Als $k$ niet gedefinieerd is dan is $v[i] = p - s[0]$.
    \end{itemize}
    \item Voorbeeld:
    \begin{itemize}
        \item Het patroon $P = \texttt{ABBABAB}$.
        \item Tabel \ref{table:bm3} toont alle verschillende waarden:
        \begin{table}[ht]
            \centering
            \begin{tabular}{l | c c c c c c c}
                $i$         & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
                $p - i - 1$ & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
                \hline
                $P[i]$      & A & B & B & A & B & A & B \\
                \hline
                $s[i]$      & 2 & 1 & 3 & 2 & 1 & 0 & 0 \\
                $k$         & / & / & / & 2 & 3 & 4 & 6 \\
                $i + 1 - k$ & / & / & / & 2 & 2 & 2 & 1 \\
                $v[i]$      & 5 & 5 & 5 & 2 & 2 & 2 & 1
            \end{tabular}
            \caption{}
            \label{table:bm3}
        \end{table}
    \end{itemize}
    \item Er zijn \textbf{drie speciale gevallen} die zich kunnen voordoen:
    \begin{enumerate}
        \item \textbf{Het patroon $P$ werd gevonden}.
        \begin{itemize}
            \item Er is geen foutief patroonpositie ($i = -1$) en het juiste suffix is nu $P$ zelf.
            \item Toch mogen er geen  $p$ posities opgeschoven worden, want een nieuwe $P$ in $T$ kan de vorige gedeeltelijk overlappen.
            \item De overlapping is het langst mogelijke suffix van $P$, korter dan $p$.
            \item De verschuiving is dus $v[-1] = p - s[0]$ (virtueel tabelelement, kan geïmplementeerd worden als constante).
        \end{itemize}
        \item \textbf{Er is geen juist suffix}.
        \begin{itemize}
            \item Als $i = p - 1$, dan is er geen juist suffix.
            \item Er is geen waarde voor de verschuiving, dus de waarde van de eerste heuristiek moet gebruikt worden.
        \end{itemize}
        \item \textbf{Het juiste suffix komt niet meer in $P$ voor}.
        \begin{itemize}
            \item Er is geen index $j$ gevonden waarvoor $s(j) = p - i - 1$.
            \item De verschuiving is opnieuw $v[i] = p - s[0]$ voor $0 < i < p$.
        \end{itemize}
    \end{enumerate}
\end{itemize}

\subsection{Onzekere algoritmen}
\begin{itemize}
    \item Algoritmen die een zekere waarschijnlijkheid hebben om een geheel foutief resultaat te geven.
    \item Zulke algoritmen worden ook \textbf{Monte Carloalgoritmen} genoemd.
    \item Er zijn redenen waarom zulke algoritmen toch nuttig kunnen zijn;
    \begin{enumerate}
        \item Zulke algoritmen zijn vaak sneller.
        \begin{itemize}
            \item Een voorbeeld is een \textbf{Bloomfilter} (figuur \ref{fig:bloomfilter}).
            \begin{figure}[ht]
                \centering
                \includegraphics[width=\textwidth]{bloomfilter}
                \caption{Een bloomfilter, die de verzameling $\{x, y, z\}$ beschrijft. De logische OF met al deze elementen is al reeds uitgevoerd. De controle of $w$ ook in deze verzameling zit zegt dat deze er niet in zit, want een bit van de hashwaarde van $w$ in de bloomfilter is 0.}
                \label{fig:bloomfilter}
            \end{figure}
            \item We willen een verzameling van objecten in gehashte vorm bijhouden.
            \item Een Bloomfilter houdt de logische bitsgewijze OF bij van de hashwaarden van alle elementen.
            \item Om te weten of een object in de verzameling zit wordt deze eerst gehasht. Daarna wordt de logische EN operatie gebruikt op de bloomfilter met deze waarde.
            \item Als het resultaat verschilt van de hashwaarde dan zit het object er zeker niet in.
            \item Anders weten we het niet, en moet de verzameling doorzocht worden.
        \end{itemize}
        \item Men tracht de kans dat er een fout voorkomt zo klein mogelijk te maken.
    \end{enumerate}
\end{itemize}


\subsection{Het Karp-Rabinalgoritme}
\begin{itemize}
    \item Herleidt het vergelijken van strings tot het vergelijken van getallen.
    \item Aan elke mogelijke string die even lang is als $P$ wordt een getal toegekend.
    \item Er zijn $d^p$ verschillende strings met lengte $p$, zodat de getallen groot kunnen worden.
    \begin{itemize}
        \item Daarom worden de getallen beperkt tot deze die in één processorwoord (met lengte $w$ bits) voorgesteld kunnen worden, via een modulobewerking.
    \end{itemize}
    
    \item Meerdere strings zullen met hetzelfde getal moeten overeenkomen ($\equiv$ hashing).
    \item Gelijke strings betekent nog altijd gelijke getallen, maar een gelijk getal betekent niet meer dezelfde string.
    \begin{itemize}
        \item Bij een gelijk getal moet het patroon nog steeds vergeleken worden met de tekst op die positie.
    \end{itemize}
    \item Hoe worden de getallen gedefinieerd?
    \begin{itemize}
        \item Ze moeten in $O(1)$ berekend kunnen worden voor elk van de $O(t)$ deelstrings in de tekst.
        \item Een hashwaarde voor een string met lengte $p$ in $O(1)$ berekenen is niet realistisch.
        \item Daarom wordt de hashwaarde voor de deelstring op positie $j + 1$ berekend op basis van de deelstring op basis $j$.
        \item De eerste hashwaarde berekenen ($j = 0$) mag dan langer duren.
    \end{itemize}
    

    \item De voorstelling van $P$:
    \begin{itemize}
        \item We beschouwen een string als een getal in een $d-$tallig talstelsel omdat elk stringelement $d$ waarden kan aannemen zodat elk stringelement wordt voorgesteld door een cijfer tussen 0 en $d - 1$.
        
        $$H(P) = \sum_{i=0}^{p-1} P[i]d^{p-i-1} = P[0]d^{p-1} + P[1]d^{p-2} + \dots + P[p-2]d + P[p-1]$$

        \item Om de beperkte waarde te bekomen, wordt de rest bij deling door een getal $r$ genomen. Dit wordt de \textbf{fingerprint} genoemd.
        $$H_r(P) = H(P)\;\mathrm{mod}\;r$$
    
        \item Dit is geen efficiënte operatie omdat de individuele getallen van de som in $H(p)$ groot kunnen worden, maar gelukkig
        $$(a + b) \;\mathrm{mod}\;r = (a\;\mathrm{mod}\;r + b\;\mathrm{mod}\;r)\;\mathrm{mod}\;r$$
    
        Dit geldt ook voor verschil en het product.
    
        \item Omdat elk tussenresultaat nu binnen een processorwoord past, is $H_r(P)$ berekenen slechts $\Theta(p)$.
    \end{itemize}
    \item De voorstelling van $T$:
    \begin{itemize}
        \item De waarde $T_0$ bij beginpositie $j = 0$ wordt op dezelfde manier berekend als $P$.
        $$H(T_0) = \sum_{i=0}^{p-1} T[i]d^{p-i-1} = T[0]d^{p-1} + T[1]d^{p-2} + \dots + T[p-2]d + T[p-1]$$

        \item Er is nu een eenvoudig verband tussen het getal voor de deelstring $T_{j + 1}$ bij beginpositie $j + 1$ en dat voor $T_{j}$ bij beginpositie $j$:

        $$H(T_{j + 1}) = (H(T_j) - T[j]d^{p-1})d + T[j + p]$$

        (De waarde $T[j]d^{p-1}$ aftrekken en die van $T[j + p]$ optellen en er ook voor zorgen dat de macht die bij $T[j +1], T[j + 2], ... T[j + p -1]$  hoort met 1 verhoogt wordt door te vermenigvuldigen met $d$)

        \begin{itemize}
            \item Stel een string T = \texttt{ABCDE}, $d = 5$ en $p$ = 3 (wat $P$ is maakt niet uit voor dit voorbeeld). De waarden van de stringelementen zijn $A = 1, B = 2, C = 3, D = 4, E = 5$.
            \item De opeenvolgende waarden $T_j$ zijn dan:
            \begin{itemize}
                \item \begin{align*}
                    H(T_0) &= \sum_{i=0}^{2} T[i]5^{2-i}\\
                    & = A\cdot 5^2 + B\cdot 5^1 + C\\
                    & = 1\cdot 5^2 + 2\cdot 5^1 + 3\\
                    &= 25 + 10 + 3 = 38
                \end{align*}
                \item \begin{align*}
                    H(T_1) &= (H(T_0) - T[0]5^{2})\cdot 5 + T[3]\\
                           &= (A\cdot 5^2 + B\cdot 5 + C - A\cdot 5^2)\cdot 5 + D \\
                           &= B\cdot 5^2 + C \cdot 5 + D  \\
                           &= 2\cdot 5^2 + 3 \cdot 5 + 4  \\
                           &=  50 + 15 + 4 = 69
                \end{align*}
                \item \begin{align*}
                    H(T_2) &= (H(T_1) - T[1]5^{2})\cdot 5 + T[4]\\
                           &= (B\cdot 5^2 + C\cdot 5 + D - B\cdot 5^2)\cdot 5 + E \\
                           &= C\cdot 5^2 + D \cdot 5 + E  \\
                           &= 3\cdot 5^2 + 4 \cdot 5 + 5  \\
                           &=  75 + 20 + 5 = 100
                \end{align*}
            \end{itemize}
            
            
        \end{itemize}

        \item Analoog aan $H_r(P)$ worden de waarden $H(T)$ ook modulo $r$ genomen, zodat $$H_r(T_{j + 1}) = H(T_{j + 1})\;\mathrm{mod}\;r$$

        \item Het berekenen van $H_r(P)$, $H(T_0)$ en $d^{p-1}\;\mathrm{mod}\;r$ vereist $\Theta(p)$ operaties.
        \item Het berekenen van alle andere fingerprints $H_r(T_j) (0 < j \leq t - p)$ vergt $\Theta(t)$ operaties.
        \item Dit is $\Theta(t + p)$.
        \item Maar, de strings moeten nog vergeleken worden als de fingerprints hetzelfde zijn.
        \item In het slechtste geval zijn de fingerprints op elke positie gelijk, zodat de totale performantie $\textbf{O(tp)}$ is.
        \item Er zijn nu nog twee mogelijkheden om $r$ te bepalen:
        \begin{enumerate}
            \item \textbf{Vaste $r$}
            \begin{itemize}
                \item Kies $r$ als een zo groot mogelijk priemgetal zodat $rd \leq 2^w$.
                \item Priemgetallen zorgt ervoor dat gelijkaardige deelstrings dezelfde fingerprinters zouden opleveren.
                \item Een groot priemgetal zorgt voor een groot aantal mogelijke fingerprints.
                \item Er is nu wel een nieuw verband tussen $H_r(T_{j + 1})$ en $H_r(T_j)$:
                $$H_r(T_{j + 1}) = \bigg(\big((H_r(T_j) + r(d - 1) - T[j](d^{p-1}\;\mathrm{mod}\;r)) \;\mathrm{mod}\;r\big)d + T[j + 1] \bigg)\;\mathrm{mod}\;r$$
                
                (De term $r(d - 1)$ wordt toegevoegd om een negatief tussenresultaat te vermijden.)
            \end{itemize}


            \item \textbf{Random $r$}
            \begin{itemize}
                \item Soms is een vaste $r$ nadelig: er kan bijvoorbeeld een slechte waarde gekozen worden.
                \item De veiligste implementatie gebruikt een willekeurige priem $r$ uit een bepaald bereik.
                \item Een groter bereik reduceert de kans op fouten.
                \item Het aantal priemgetallen kleiner of gelijk aan $k$ is $\frac{k}{\ln k}$.
                \item Door $k$ groot te kiezen zal slechts een klein deel van die priemgetallen een fout veroorzaken.
                \item De kans dat $r$ één van die priemen is wordt klein.
                \item Voor $k = t^2$ is de kans op één enkele foute $O(1/t)$.
                \item Om fouten helemaal te vermijden zijn er twee mogelijkheden:
                \begin{itemize}
                    \item Overgaan naar een andere methode als de fout gesignaleerd wordt.
                    \item Herbeginnen met een nieuwe random priem $r$.
                \end{itemize}
            \end{itemize}
        \end{enumerate}

    \end{itemize}

\end{itemize}


\subsection{Zoeken met automaten}
\begin{itemize}
    \item Automaten beschrijven algemene informatieverwerkende eenheden met een eindig geheugen.
    \item Het geheugen wordt voorgesteld door \textbf{staten}.
    \begin{itemize}
        \item Er zijn evenveel staten als er mogelijkheden zijn.
        \item Een geheugenmodule van 32 kilobyte heeft $256^{32000}$ mogelijke staten.
    \end{itemize}
    \item Een automaat modelleert ook de tijd als een 

    \item \textbf{Deterministische automaten.}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.7\textwidth]{deterministic_automata}
        \caption{Een deterministische automaat die de woorden \texttt{CNOPS}, \texttt{KOP} en \texttt{OP} herkent. $S_0$ is de startstaat, $S_5$ en $S_8$ zijn eindstaten.}
        \label{fig:deterministic_automata}
    \end{figure}
    \begin{itemize}
        \item Een deterministische automaat (DA) bestaat uit:
        \begin{itemize}
            \item Een (eindige) verzameling invoersymbolen $\Sigma$.
            \item Een (eindige) verzameling toestanden $S$.
            \item Een begintoestand $s_0 \in S$.
            \item Een verzameling eindtoestanden $F \subset S$.
            \item Een overgangsfunctie $p(t, a)$ die een nieuwe toestand geeft wanneer de automaat in staat $t$ symbool $a$ ontvangt.
        \end{itemize}
        \item Een DA wordt voorgesteld door een gerichte geëtiketteerde multigraaf $G$, de \textbf{overgangsgraaf}.
        \begin{itemize}
            \item De knopen zijn de verschillende staten.
            \item De verbindingen zijn de overgangen met als etiket het overeenkomstig invoersymbool.
        \end{itemize}
        \item Een DA start altijd in zijn begintoestand, en maakt de gepaste toestandsovergangen bij elk ingevoerd symbool.
        \item Als een DA zich in een eindtoestand bevindt, dan wordt de string \textbf{herkend} door de DA. De verzameling strings die herkend wordt door een DA is de taal van die automaat.
    \end{itemize}

    \item \textbf{Niet-deterministische automaten.}
    \begin{itemize}
        \item Heeft geen staten, maar wel \textbf{statenbits}.
        \item De 'staat' van een NA wordt aangeduid door de verzameling statenbits die aan staan.
        \item De beginstaat wordt aangeduidt met een speciale statenbit, de beginbit, die aanstaat in het begin terwijl alle andere uit staan.
        \item De eindstaten worden aangeduid door de eindbits.
        \item De overgang van een staat naar de volgende werkt bit per bit.
        \item Een statenbit die aan staat reageert op een invoersymbool door een signaal naar nul of meer statenbits te sturen.
        \item Een statenbit die één of meer signalen binnekrijgt zet zichzelf aan, anders uit.
        \item Als $i$ een statenbit is en $a$ een letter uit het alfabet, dan is $s(i, a)$ de verzameling statenbits die rechtstreeks een signaal van $i$ krijgen als de inkomenden letter $a$ is.
        \item Er zijn ook $\epsilon-$overgangen. Een $\epsilon-$overgang van statenbit $i$ naar statenbit $j$ zorgt ervoor dat $i$ direct een signaal uitstuurt naar $j$, zonder vertraging.
    \end{itemize}

    \begin{figure}[ht]
        \centering
        \includegraphics[width=\textwidth]{nondeterministic_automata}
        \caption{Een niet-deterministische automaat en bijhorende statentabel voor de reguliere expressie $(a|b)*a(a|b)$.}
        \label{fig:nondeterministic_automata}
    \end{figure}
\end{itemize}

\subsubsection{De deelverzamelingconstructie}
\begin{itemize}
    \item Een NA is een alternatieve voorstelling van een DA, maar laat geen efficiënte implementatie toe:
    \begin{itemize}
        \item Bij elke binnenkomende letter moeten alle statenbits die aanstaan overlopen worden, en de daarbijhorende bits die een signaal krijgen aanduiden.
        \item Bij een DA moet voor elke binnenkomende letter enkel de nieuwe staat opgezocht worden in de tabel.
    \end{itemize}
    \item Een NA is wel eenvoudiger om op te stellen. Een reguliere uitdrukking kan eenvoudig omgezet worden tot een NA.
    \item \textbf{Een NA omzetten naar een DA} wordt de \textbf{deelverzamelingconstructie} genoemd.
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.7\textwidth]{deterministic_automata_2.PNG}
        \caption{De deterministische automaat geconstrueerd uit die van figuur \ref{fig:nondeterministic_automata}.}
        \label{fig:deterministic_automata_2.PNG}
    \end{figure}
    \begin{itemize}
        \item Als een NA $k$ statenbits heeft, zijn er $2^k$ mogelijke deelverzamelingen.
        \item Die allemaal nagaan is niet efficiënt aangezien de meeste deelverzamelingen al niet bereikbaar zijn vanuit de begintoestand. Op figuur \ref{fig:nondeterministic_automata} is te zien dat enkel de deelverzamelingen \{1\}, \{1, 2\} en \{3\} (3 van de 8 deelverzamelingen) op elk moment beschikbaar kunnen zijn. 
        \item Er is dus een implicite multigraaf met $2^k$ knopen die doorlopen kan worden met breedte-eerst of diepte-eerst zoeken.
        \item Knopen die niet bereikbaar zijn zijn overbodig voor de DA.
        \item Buren in deze impliciete multigraaf kunnen niet opgezocht worden in een burenlijst. Er zijn hulpoperaties nodig:
        \begin{itemize}
            \item De \textbf{$\epsilon-$sluiting(T)} geeft de deelverzameling van statenbits bereikbaar via $\epsilon-$overgangen vanuit een verzameling statenbits $T$ (gewoon via diepte eerst zoeken zoals pseudocode 11.1 in cursus).
            \item De overgangsfunctie $p(t, a)$ kan uitgebreidt worden voor een verzameling van statenbits tot $p(T, a)$: de deelverzameling van alle statenbits rechtstreeks bereikbaar vanuit een toestand $t$ uit $T$ voor het invoersymbool $a$.
        \end{itemize}
        \item Voor een DA hebben we verzameling van toestanden $D$ en overgangstabel $M$ nodig.
        \item De begintoestand van de DA is $\epsilon-$sluiting($b_0$).
        \item dunno man
    \end{itemize}
    
\end{itemize}

\subsection{De Shift-AND-methode}
\begin{itemize}
    \item Bitgeoriënteerde methode, die efficiënt werkt voor \textbf{kleine patronen}.
    \item Voor elke positie $j$ in de tekst $T$ bijhouden welke prefixen van het patroon $P$ overeenkomen met de tekst, eindigend op positie $j$.
    \item Maakt gebruik van een tabel $R$ met $p$ logische waarden. Het $i-$de element komt overeen met prefix van lengte $i$.
    \begin{itemize}
        \item $R_j$ stelt de waarde van tabel $R$ na verwerking van $T[j]$.
        \item $R_j[i - 1]$ is waar als de eerste $i$ karakters van $P$ overeenkomen met de $i$ testkarakters eindigend in $j$.
        \item De tabel $R_{j+1}$ kan afgeleidt worden uit $R_j$, aangezien sommige prefixen verlengd kunnen worden:
        \begin{align*}
            R_{j + 1}[0] & = \begin{cases}
                1, \hbox{ als } P[0] = T[j + 1] \\
                0, \hbox{ als } P[0] \neq T[j + 1] \\
            \end{cases}\\
            R_{j + 1}[i] & = \begin{cases}
                1, \hbox{ als } R_{j - 1} = 1 \hbox{ en } P[i] = T[j + 1] \\
                0, \hbox{ anders }
            \end{cases} 
            \qquad \hbox{ voor } 1 \leq i \leq p
        \end{align*}
    \end{itemize}
    \item Bij de berekening van $R_{j + 1}$ moeten we weten of $T[j + 1]$ gelijk is aan $P[i]$, voor elke mogelijke waarde van $i$.
    \item Er wordt een tweedimensionale tabel $S$ opgesteld met $d$ (lengte van alfabet) bitpatronen. Een bit $i$ van woord $S[s]$ is waar als het karakter $s$ op plaats $i$ in $P$ voorkomt.

    \item Om alle bits $R_{j + 1}$ gelijktijdig te berekenen wordt de schuifoperatie naar rechts gebruikt (bit $i$ wordt bit $i + 1$, en er wordt vooraan een éénbit ingeschoven), gevolgd door een bit-per-bit EN-operatie met $S[T[j + 1]]$
    
    $$R_{j + 1} = \hbox{Schuif}(R_j) \hbox{ EN } S[T[j + 1]]$$

    \item \textbf{Voorbeeld:}
    \begin{itemize}
        \item Stel $\Sigma = \{A, C, G, T\}$ en $d = 4$.
        \item Stel $P = $ \texttt{GCAGAGAG}.
        \item Stel $T = $ \texttt{GCATCGCAGAGAGTATACAGTACG}.
        \item De tabel $S$ kan uit $P$ berekent worden:
        \begin{table}[ht]
            \centering
            \begin{tabular}{|c | c c c c |}
                \hline
                & $S[A]$ & $ S[C]$ & $ S[G]$ & $S[T]$ \\
                \hline
                G & 0 & 0 & 1 & 0 \\
                C & 0 & 1 & 0 & 0 \\
                A & 1 & 0 & 0 & 0 \\
                G & 0 & 0 & 1 & 0 \\
                A & 1 & 0 & 0 & 0 \\
                G & 0 & 0 & 1 & 0 \\
                A & 1 & 0 & 0 & 0 \\
                G & 0 & 0 & 1 & 0 \\
                \hline
            \end{tabular}
        \end{table}
        \item De tabellen $R_j$ worden dan:

        \begin{table}[ht]
            \centering
            \scalebox{0.6}{
            
            \begin{tabular}{|c c | c c c c c c c c c c c c c c c c c c c c c c c c |}
                \hline
                & & $R_0$&$R_1$&$R_2$&$R_3$&$R_4$&$R_5$&$R_6$&$R_7$&$R_8$&$R_9$&$R_{10}$&$R_{11}$&$R_{12}$&$R_{13}$&$R_{14}$&$R_{15}$&$R_{16}$&$R_{17}$&$R_{18}$&$R_{19}$&$R_{20}$&$R_{21}$&$R_{22}$&$R_{23}$\\
                & & G&C&A&T&C&G&C&A&G&A&G&A&G&T&A&T&A&C&A&G&T&A&C&G\\
                \hline
                $R[0]$ & G & \textbf{1} & 0&0&0&0&\textbf{1}&0&0&\textbf{1}&0&\textbf{1}&0&\textbf{1}&0&0&0&0&0&0&\textbf{1}&0&0&0&\textbf{1}  \\
                $R[1]$ & C & 0 & \textbf{1}&0&0&0&0&\textbf{1}&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0  \\
                $R[2]$ & A & 0 & 0&\textbf{1}&0&0&0&0&\textbf{1}&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0  \\
                $R[3]$ & G & 0 & 0&0&0&0&0&0&0&\textbf{1}&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0  \\
                $R[4]$ & A & 0 & 0&0&0&0&0&0&0&0&\textbf{1}&0&0&0&0&0&0&0&0&0&0&0&0&0&0  \\
                $R[5]$ & G & 0 & 0&0&0&0&0&0&0&0&0&\textbf{1}&0&0&0&0&0&0&0&0&0&0&0&0&0  \\
                $R[6]$ & A & 0 & 0&0&0&0&0&0&0&0&0&0&\textbf{1}&0&0&0&0&0&0&0&0&0&0&0&0  \\
                $R[7]$ & G & 0 & 0&0&0&0&0&0&0&0&0&0&0&\textbf{1}&0&0&0&0&0&0&0&0&0&0&0  \\
                
                \hline
            \end{tabular}
            }
        \end{table}
        \begin{itemize}
            \item Start vanuit $R_0 = \begin{bmatrix}1&0&0&0&0&0&0&0\end{bmatrix}$ (want $R_0[0] = P[0]$).
            \begin{align*}
                R_{1} & = \hbox{Schuif}(R_0) \hbox{ EN } S[T[1]] \\
            & = \begin{bmatrix}1& 1& 0& 0& 0& 0& 0& 0\end{bmatrix} \hbox{ EN } \begin{bmatrix}0&1&0&0&0&0&0&0\end{bmatrix} \\
                      & = \begin{bmatrix}0&1&0&0&0&0&0&0\end{bmatrix} \\
                R_{2} & = \hbox{Schuif}(R_1) \hbox{ EN } S[T[2]] \\
                      & = \begin{bmatrix}1&0&1&0&0&0&0&0\end{bmatrix} \hbox{ EN } \begin{bmatrix}0&0&1&0&1&0&1&0\end{bmatrix} \\
                      & = \begin{bmatrix}0&0&1&0&0&0&0&0\end{bmatrix}\\
                R_{3} & = \hbox{Schuif}(R_2) \hbox{ EN } S[T[3]] \\
                      & = \begin{bmatrix}1&0&0&1&0&0&0&0\end{bmatrix} \hbox{ EN } \begin{bmatrix}0&0&0&0&0&0&0&0\end{bmatrix} \\
                      & = \begin{bmatrix}0&0&0&0&0&0&0&0\end{bmatrix} \\
                R_{4} & = \hbox{Schuif}(R_3) \hbox{ EN } S[T[4]] \\
                      & = \begin{bmatrix}1&0&0&0&0&0&0&0\end{bmatrix} \hbox{ EN } \begin{bmatrix}0&1&0&0&0&0&0&0\end{bmatrix} \\
                      & = \begin{bmatrix}0&0&0&0&0&0&0&0\end{bmatrix} \\
                R_{5} & = \hbox{Schuif}(R_4) \hbox{ EN } S[T[5]] \\
                      & = \begin{bmatrix}1&0&0&0&0&0&0&0\end{bmatrix} \hbox{ EN } \begin{bmatrix}1&0&0&0&0&0&0&0\end{bmatrix} \\
                      & = \begin{bmatrix}1&0&0&0&0&0&0&0\end{bmatrix} \\
                      \cdots \\
                R_{8} & = \hbox{Schuif}(R_7) \hbox{ EN } S[T[8]] \\
                      & = \begin{bmatrix}1&0&0&1&0&0&0&0\end{bmatrix} \hbox{ EN } \begin{bmatrix}1&0&0&1&0&1&0&1\end{bmatrix} \\
                      & = \begin{bmatrix}1&0&0&1&0&0&0&0\end{bmatrix}\\
                      \cdots \\
                R_{12} & = \hbox{Schuif}(R_{11}) \hbox{ EN } S[T[12]] \\
                      & = \begin{bmatrix}1&0&0&0&0&0&0&1\end{bmatrix} \hbox{ EN } \begin{bmatrix}1&0&0&1&0&1&0&1\end{bmatrix} \\
                      & = \begin{bmatrix}1&0&0&1&0&0&0&\textbf{1}\end{bmatrix}
            \end{align*}

        \end{itemize}

        \item Bij $R_{12}$ is $R_{12}[7] = 1$, zodat $P$ gevonden is en begint in $T$ op positie $T[12 - 7] = T[5]$.
    \end{itemize}
    \item De totale performantie is $\textbf{\Theta(t + p)}$
\end{itemize}


\section{De Shift-AND methode: benaderende overeenkomst}
\begin{itemize}
    \item De Shift-AND methode kan aangepast worden om fouten in het gevonden patroon toe te laten.
    \item Veronderstel dat er één karakter op een willekeurige plaats in $P$ mag vervangen worden.
    \begin{itemize}
        \item We zoeken dus alle deelstrings in $T$ niet langer dan $m + 1$ die $P$ als deelsequentie bevatten.
        \item Er is een nieuwe tabel $R_j^1$ die alle prefixen aanduidt in de tekst eindigend bij positie $j$, met hoogstens één vervanging.
        \item $R_j^1[i]$ is waar als de eerste $i$ karakters van $P$ overeenkomen met de $i$ van de $i + 1$ karakters die in de tekst eindigen bij positie $j$.
    \end{itemize}
\end{itemize}