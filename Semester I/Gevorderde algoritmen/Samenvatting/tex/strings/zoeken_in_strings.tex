\newcommand{\nonterminal}[1]{
    \langle \textbf{#1} \rangle
}

\chapter{Zoeken in strings}
\label{ch:zoeken_in_strings}
\begin{itemize}
    \item De gebruikte symbolen:

    \begin{table}[ht]
        \centering
        \begin{tabular}{c l}
            \hline
            Symbool & Betekenis \\
            \hline
            $\Sigma$ & Het gebruikte alfabet \\
            $\Sigma*$ & De verzameling strings van eindige lengte van letters uit $\Sigma$ \\
            d & Aantal karakters in $\Sigma$ \\
            P & Patroon (de tekst die gezocht wordt) \\
            p & Lengte van P \\
            T & De hele tekst waarin gezocht wordt\\
            t & lengte van T \\
            \hline
        \end{tabular}
    \end{table}

    \item We willen een bepaalde string (het patroon P) in een langere string (de tekst T) lokaliseren.
    \item We nemen aan dat we alle plaatsen zoeken waar dat patroon voorkoomt.
    \item We veronderstellen ook dat P en T in het inwendig geheugen opgeslaan zitten.

    \item In de voorbeelden worden volgende concrete informatie gebruikt:
    \begin{itemize}
        \item $\Sigma = \{A, C, G, T\}$
        \item $d = 4$
        \item $P = GCAGAGAG$
        \item $p = 8$
        \item $T = GCATCGCAGAGAGTATACAGTACG$
        \item $t = 24$
    \end{itemize}

\end{itemize}


\section{Formele talen}
\begin{itemize}
    \item Een \textbf{formele taal} over een alfabet is een verzameling eindige strings over dat alfabet.
    \item Een formele taal wordt vrij vaag gedefinieerd (maar zien we niet in de cursus).
    \item Een formele taal kan op twee manieren gedefinieerd worden: via \textbf{generatieve grammatica's} of via \textbf{reguliere expressies}.
\end{itemize}

\subsection{Generatieve grammatica's}
\begin{itemize}
    \item Een \textbf{generatieve grammatica} is een methode om een taal te beschrijven.
    \item Er is een startsymbool dat getransformeerd kan worden tot een zin van de taal met behulp van substitutieregels.
    \item Buiten de karakters $\Sigma$ van het alfabet, is er ook nog een verzameling \textbf{niet-terminale symbolen}.
    \item Een niet-terminaal symbool wordt aangeduid als
        $$\nonterminal{\dots}$$
        waarin $\textbf{\dots}$ vervangen wordt door de naam van het niet-terminale symbool. 
    \item De verzameling alle strings uit $\Sigma$ vermengd met de niet-terminale symbolen is $\Xi$, en de daarbijhorende verzameling strings $\Xi*$.
    \item Een belangrijk geval zijn de \textbf{contextvrije grammatica's}.
    \begin{itemize}
        \item Er is op elk moment een string uit $\Xi*$.
        \item Als er geen niet-terminale symbolen meer zijn krijgt men een zin in de taal, anders kan men één niet-terminaal vervangen door een string uit $\Xi*$.
        \item De taal is contextvrij omdat de substitutie onafhankelijk is wat voor en achter de betreffende niet-terminaal staat.
        \item Een voorbeeld van een contextvrije grammatica:

        \begin{align*}
             \nonterminal{S} &::= \nonterminal{AB}\;|\;\nonterminal{CD} \\
             \nonterminal{AB} &::= a\nonterminal{AB}b\;|\;\epsilon \\
             \nonterminal{CD} &::= c\nonterminal{CD}c\;|\;\epsilon
        \end{align*}
        \begin{itemize}
            \item Hierbij is $\Sigma = \{ a, b, c, d \}$ en $\epsilon$ de lege string.
            \item Deze grammatica definieert als formele taal de verzameling van alle strings ofwel bestaande uit een rij 'a's gevolgd door een even lange rij 'b's ofwel bestaande uit een rij 'c's gevolgd door een even lange rij 'd's.    
            \item De afleiding van "cccddd":
            $$\nonterminal{S} \rightarrow \nonterminal{CD} \rightarrow c\nonterminal{CD}d \rightarrow cc\nonterminal{CD}dd \rightarrow ccc\nonterminal{CD}ddd \rightarrow cccddd$$
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection{Reguliere uitdrukkingen}
\begin{itemize}
    \item Een \textbf{reguliere uitdrukking} is ook een methode om een taal te beschrijven.
    \item Een reguliere uitdrukking, of \textit{regexp}, is een string over het alfabet $\Sigma = \{\sigma_0, \sigma_1, \cdots, \sigma_{d-1}\}$ aangevuld met de symbolen $\varnothing, \epsilon, *, (, )$ en $\bot$, gedefinieerd door
    \begin{align*}
        \nonterminal{Regexp} &::= \nonterminal{basis}\;|\;\nonterminal{samengesteld} \\
        \nonterminal{basis} &::= \sigma_0|\cdots|\sigma_{d-1}|\varnothing|\epsilon \\
        \nonterminal{samengesteld} &::= \nonterminal{plus}|\nonterminal{of}|\nonterminal{ster}\\
        \nonterminal{plus} &::= (\nonterminal{Regexp}\nonterminal{Regexp})\\
        \nonterminal{of} &::= (\nonterminal{Regexp}\bot\nonterminal{Regexp})\\
        \nonterminal{ster} &::= (\nonterminal{Regexp})*
    \end{align*}
    \item Elke regexp $R$ definieert een formele taal, Taal($R$).
    \item Een taal die door een regexp gedefinieerd kan worden heet een reguliere taal.
    \item De definitie van een regexp en reguliere taal is recursief:
    \begin{enumerate}
        \item $\varnothing$ is een regexp, met als taal de lege verzameling.
        \item De lege string $\epsilon$ is een regexp met als taal Taal($\epsilon$) = \{$\epsilon$\}.
        \item  Voor elke $a \in \Sigma$ is \quotes{a} een regexp, met als taal Taal(\quotes{a}) = \{\quotes{a}\}.
    \end{enumerate}
    \item Regexps kunnen gecombineerd worden via drie operaties:

    \begin{table}[ht]
        \centering
        \begin{tabular}{c c c}
            \hline
            Operatie & Regexp & Operatie op taal/talen \\
            \hline
            Concatenatie & (RS) & Taal($R$) $\cdot$ Taal($S$) \\
            Of & $(R|S)$ & Taal($R$) $\cup$ Taal($S$) \\
            Kleenesluiting & (R)* & Taal($R$)* \\
            \hline
        \end{tabular}

    \end{table}
    \item Vaak worden verkorte notaties gebruikt:
    \begin{itemize}
        \item \textbf{Minstens eenmaal herhalen}
        $$rr* \rightarrow r+$$
        \item \textbf{Optionele uitdrukking}
        $$r|\epsilon \rightarrow r?$$
        
        \item \textbf{Unies van symbolen}
        $$a|b|c \rightarrow [abc] $$
        $$a|b|\dots|z \rightarrow [a-z] $$

        
    \end{itemize}

    \item Regexps kunnen gelinkt worden met graafproblemen.
    \item \textbf{Stelling:} Zij $G$ een gerichte multigraaf met verzameling takken $\Sigma$. Als $a$ en $b$ twee knopen van $G$ zijn dan is de verzameling $P_G(a, b)$ van paden beginnend in $a$ en eindigend in $b$ een reguliere taal over $\Sigma$.
    \item \textbf{Bewijs:}
    \begin{itemize}
        Via inductie op het aantal verbindingen $m$ van $G$.
        \item Als $m = 0$ dan
        $$P_G(a, b) = \begin{cases}
            \varnothing, \hbox{ als } a \neq b\\
            \{\epsilon\}, \hbox{ als } a = b 
        \end{cases}$$
        \item Breidt nu de graaf $G$ uit naar $G'$ door één verbinding toe te voegen.
        \begin{itemize}
            \item Een verbinding $v_{xy}$ van knoop $x$ naar knoop $y$, waarbij eventueel $x = y$.
            \item Alle paden van $a$ naar $b$ zijn één van de twee volgende vormen:
            \begin{enumerate}
                \item De paden die $v_{xy}$ niet bevatten. Deze vormen de reguliere taal $P_G(a, b)$.
                \item De paden die $v_{xy}$ wel bevatten. Deze verzameling wordt gegeven door
                $$P_G(a, x) \cdot \{v_{xy}\} \cdot (P_G(y, x) \cdot \{v_{xy}\})* \cdot P_G(y, b)$$

                Deze is bekomen uit reguliere talen en is dus regulier.
            \end{enumerate}
        \end{itemize}
    \end{itemize}
    \item 
\end{itemize}




\section{Variabele tekst}

\subsection{Een eenvoudige methode}
\begin{itemize}
    \item We zitten op een bepaalde positie $j$ in $T$.
    \item Vanaf $j$ wordt $T[j + i]$ met $P[i]$ vergeleken voor $0 < i \leq p$.
    \begin{enumerate}
        \item Het eerste geval komt voor wanneer $T[j + i] \neq P[i]$, voor $i \leq p$, en het patroon dus niet gevonden is op positie $j$ in $T$.
        \item Het tweede geval komt dan voor wanneer het patroon wel gevonden is op positie $j$ in $T$.
    \end{enumerate}
    \item Voor willekeurige strings zal $T[j]$ vaak verschillen van $P[0]$.
    \begin{itemize}
        \item Op veel posities $j$ zal de karaktervergelijking na één positie dan stoppen.
    \end{itemize}
    \item De \textbf{gemiddelde uitvoeringstijd} is $O(t)$.
    \item Het \textbf{slechtste geval} is $O(tp)$.
\end{itemize}



\subsection{Knuth-Morris-Pratt}
\subsubsection{De prefixfunctie}
\begin{itemize}
    \item Gegeven een string $P$ en index $i$ met $i \leq p$.
    \item Een string $Q$ kan voor $i$ op $P$ gelegd woorden als $i \geq q$ en als $Q$ overeenkomt met de even lange deelstring van $P$ endigend voor $i$.
    \begin{itemize}
        \item De index $i$ wijst naar de plaats \textit{voorbij} de deelstring, niet naar de laatste letter van de deelstring.
    \end{itemize}
    \item De prefixfunctie $q(i)$ van een string $P$ bepaalt voor elke stringpositie $i$, $1 \leq i \leq p$, de lengte van de langste prefix van $P$ met lengte kleiner dan $i$ dat we voor $i$ kunnen leggen.

    \item Volgende eigenschappen gelden:
    \begin{itemize}
        \item $q(0) = -$ (niet gedefinieerd)
        \item $q(1) = 0$
        \item $q(i) < i$
        \item $q(i + 1) \leq q(i) + 1$
    \end{itemize}
    \item De waarde van $q(i + 1)$ kan bepaald worden als de waarden van de vorige posities gekend zijn.
    $$q(i + 1) = \begin{cases}
        q(i) + 1 & \hbox{ als } P[q(i)] = P[i]  \\
        q(q(i)) + 1 & \hbox{ als } P[q(q(i))] = P[i] \\
        q(q(q(i))) + 1 & \hbox{ als } P[q(q(q(i)))] = P[i] \\
        \cdots \\
        0 & \hbox { als q(q(q(....))) = 0 }
    \end{cases}$$

    \begin{itemize}
        \item Stel de string \texttt{ANOANAANOANO}
        \item Dan zijn de waarden van de prefixfunctie als volgt:
        \begin{itemize}
            \item Voor $i = 2$ geldt $q(i) = 0$:
            \begin{itemize}
                \item $P[q(1)] = P[1]\;?\;\rightarrow P[0] = P[1]\;?\;\rightarrow A \neq N$
                \item $q(2) = 0$
            \end{itemize} 
            \item Voor $i = 4$ geldt $q(i) = 1$:
            \begin{itemize}
                \item $P[q(3)] = P[3]\;?\;\rightarrow P[0] = P[3]\;?\;\rightarrow A = A$
                \item $q(4) = q(3) + 1 = 0 + 1 = 1$
            \end{itemize}
            \item Voor $i = 12$ geldt $q(i) = 3$:
            \begin{itemize}
                \item $P[q(11)] = P[11]\;?\;\rightarrow P[5] = P[11]\;?\;\rightarrow A \neq O$
                \item $P(q(5)) = P[11]\;?\;\rightarrow P[2] = P[11]\;?\;\rightarrow O = O$
                \item $q(12) = q(5) + 1 = 2 + 1 = 3$
            \end{itemize}
        \end{itemize}

        \begin{table}[ht]
            \centering
            \begin{tabular}{l | c c c c c c c c c c c c c}
                     & A & N & O & A & N & A & A & N & O & A  & N  & O  & - \\
                     \hline
                i    & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12  \\
                q(i) & - & 0 & 0 & 0 & 1 & 2 & 1 & 1 & 2 & 3  & 4  & 5 & 3 
            \end{tabular}
        \end{table}
    \end{itemize}
    \item De prefixwaarden worden dus voor stijgende $i$ berekend.
    \item Wat is de \textbf{efficiëntie}?
    \begin{itemize}
        \item Er moeten $p$ prefixwaarden berekend worden.
        \item De recursierelatie wordt ook maar $p-1$ herhaald voor de voltallige bepaling van de prefixfunctie.
        \item De methode is $\Theta(p)$.
    \end{itemize}
\end{itemize}

\subsubsection{Een eenvoudige lineaire methode}
\begin{itemize}
    \item Stel een string samen bestaande uit $P$ gevolgd door $T$, gescheiden door een speciaal karakter dat in niet in beide strings voorkomt.
    \item Bepaal de prefixfunctie van deze nieuwe string, in $\Theta(n + p)$.
    \item Als de prefixwaarde van een positie $i$ gelijk is aan $p$, werd $P$ gevonden, beginnend bij index $i - p$ in $T$.
\end{itemize}


\subsubsection{Het Knuth-Morris-Prattalgoritme}
\begin{itemize}
    \item Ook een lineaire methode, maar is efficiënter.
    \item Stel dat $P$ op een bepaalde beginpositie vergeleken wordt met $T$, en dat er geen overeenkomst meer is tussen $P[i]$ en $T[j]$.
    \begin{itemize}
        \item Als $i = 0$, dan wordt $P$ één positie naar rechts geschoven en begint het vergelijken met $T$ weer bij $P[0]$.
        \item Als $i > 0$, dan is er een prefix van $P$ met lengte $i$ gevonden, dat we voor $j$ op $T$ kunnen leggen.
        \begin{itemize}
            \item Verschuif $P$ met een stap $s$ kleiner dan $i$.
            \item Er is nu een overlapping tussen het begin van $P$ en het prefix van $P$ dat we in $T$ gevonden hebben.
            \item De overlapping heeft lengte $i - s$.
            \item De overlappende delen moeten wel overeenkomen.
            \item De kleinste waarde van $s$ waarbij dit mogelijk is, is $s = i - q(i)$.
            \item Verschuif $P$ met $s$ en vergelijk verder vanaf $T[j]$ en $P[q(i)]$.
        \end{itemize}
    \end{itemize}
        \item Voorbeeld:
        \begin{itemize}
            \item Stel $P = \texttt{ANOANAANOANO}$.
            \item Stel $T = \texttt{ANOAOAANOANO}$.
            \item De waarden $q(i)$ van $P$ zijn reeds bekend, en de waarden $s$ kunnen eenvoudig berekend worden door $i - q(i)$ (Tabel \ref{table:kmp1}).
            
            \begin{table}[ht]
                \centering
                \begin{tabular}{l | c c c c c c c c c c c c c}
                    P   & A & N & O & A & N & A & A & N & O & A  & N  & O  & - \\
                        \hline
                    i    & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12  \\
                    q(i) & - & 0 & 0 & 0 & 1 & 2 & 1 & 1 & 2 & 3  & 4  & 5 & 3   \\
                    s    & - & 1 & 2 & 3 & 3 & 3 & 5 & 6 & 6 & 6 & 6 & 6 & 9
                \end{tabular}
                \caption{Het patroon $P$ en bijhorende prefixfunctie $q(i)$ en $s$-waarden.}
                \label{table:kmp1}
            \end{table}

            \item Stel nu dat we in $T$ zoeken:
            \begin{itemize}
                \item Het eerste verkeerde karakter komt voor bij $i = 4$. 
                \item Er is dus een correct prefix van lengte $4$ gevonden.
                \item We kunnen $P$ met $s = i - q(i) = 4 - q(4) = 4 - 1 = 3$ stappen verschuiven. ($P_2$ in tabel \ref{table:kmp2})
                \item We merken nu wel op dat $P[1] = N$ ook niet gelijk is aan $T[4] = O$, zodat de verschuiving eigenlijk nutteloos is.
                \item Er is een \textbf{bijkomende voorwaarde}: de verschuiving $s$ is enkel zinvol als \\ $P[i - s] \neq P[i]$.
            \end{itemize}
                        
            \begin{table}[ht]
                \centering
                \begin{tabular}{l | c c c c c c c c c c c c c}
                    i  & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12  \\
                    \hline
                    T    & A & N & O & A & O & A & A & N & O & A & N  & O  & - \\
                    P    & A & N & O & A & N & A & A & N & O & A & N  & O  & - \\
                    $P_2$    &   &   &   & A & N & O & A & N & A & A & N  & O  & A  $\cdots$\\
                \end{tabular}
                \caption{Zoeken in $T$ met $P$, enkel rekening houdend met de eenvoudige berekening van $s$-waarden. De verschuiving heeft geen resultaat, omdat er nog steeds een fout is op $i = 4$.}
                \label{table:kmp2}
            \end{table}
           \item De kleinste $s$-waarde vinden komt neer door het berekenen van een functie $q'()$, op basis van $q()$, zodat $i - q'()$ de kleinste $s$-waarde oplevert.
            
           $$q'(i) = q(q(i)) \qquad \hbox{ als } q(i) > 0 \hbox{ EN } q(i + 1) == q(i) + 1$$
           \todo{VOORBEELD}
    \end{itemize}
\end{itemize}


\subsection{Boyer-Moore}
\begin{itemize}
    \item Dit algoritme is een \textbf{variant} van het Knuth-Morris-Prattalgoritme.
    \alert Het patroon wordt van achter naar voor overlopen bij het vergelijken met de tekst.
    \item Er worden \textbf{twee heuristieken} gebruikt die grotere verschuivingen mogelijk maakt. Het maximum van de twee heuristieken wordt dan gebruikt als verschuiving:
    \begin{enumerate}
        \item \textbf{De heuristiek van het verkeerde karakter}.
        \item \textbf{De heuristiek van het juiste suffix}.
    \end{enumerate}
\end{itemize}

\subsubsection{De heuristiek van het verkeerde karakter}
\begin{itemize}
    \item Het patroon $P$ wordt van achter naar voor vergeleken.
    \item Het tekstkarakter waar een fout voorkomt noemen we $f$ (het verkeerde karakter in de tekst $T$).
    \item Als $T$ ook dit karakter bevat, op een andere positie, kan $P$ naar rechts verschoven worden.
    \begin{table}[ht]
        \centering
        \begin{tabular}{l | c c c c c c c c c c c c c}
            i    & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & \\
            \hline
            T    & A & N & O & A & O & A & A & N & O & A & N  & O  & \\
            P    & A & N & O & A & N & A & A & N & O & A & N  & O  & \\
        \end{tabular}
        \caption{Hier is $f = O$ op positie $i = 4$.}
        \label{table:bm1}
    \end{table}
    \item Om de verschuiving te bepalen wordt \textbf{de meest rechtse positie} in $P$ van elk karakter in het alfabet bijgehouden.
    \begin{itemize}
        \item Dit wordt geïmplementeerd als een tabel, MRP genaamd, geïndexeerd op de karakters van het alfabet.
        \item Tabel \ref{table:bm2} toont de MRP-tabel voor $P = \texttt{ANOANAANOANO}$.
        \begin{table}[ht]
            \centering
            \begin{tabular}{l | cccccccc}
                MRP & A & B & C & $\cdots$ & N & $\cdots$ & O &  $\cdots$ \\
                \hline
                &     9 & -1 & -1 & $\cdots$ & 10 & $\cdots$ & 8 & $\cdots$  
            \end{tabular}
            \caption{De MRP-tabel voor $P = \texttt{ANOANAANOANO}$. De waarden voor $A$ en $N$ zijn vanzelfsprekend. De waarde van $O$ is niet 11, omdat dat sowieso het eerste karakter is dat vergeleken wordt, en telt niet mee. Een karakter dat niet in het patroon voorkomt krijgt de waarde -1.}
            \label{table:bm2}
        \end{table}

        \item Het volstaat nu om de waarde $j = MRP[f]$ op te zoeken, waarbij $f$ het foute karakter in $P$ op positie $i$ is, en $P$ te verschuiven over $i - j$ posities. 
        \begin{itemize}
            \alert In het geval dat $i - j < 0$, dan bedraagt de verschuiving $1$ positie.
        \end{itemize}
    \end{itemize}
    \item Er zijn \textbf{drie varianten} van deze heuristiek:
    \begin{enumerate}
        \item \textbf{Uitgebreide heuristiek van het verkeerde karakter}.
        \begin{itemize}
            \item De MRP-tabel wordt uitgebreidt, zodat $MRP[f]$ de positie $j$ teruggeeft, \textbf{links} van foutpositie $i$ in het patroon.
            \item Hiervoor is een tweedimensionale tabel nodig en is in het algemeen een vrij slechte uitbreiding.

        \end{itemize}
        \item \textbf{Variant van Horspool}.
        \begin{itemize}
            \item De MRP-tabel wordt licht gewijzigd, zodat $MRP[f]$ de positie $j$ teruggeeft, \textbf{links} van positie $p - 1$.
            \item Het patroon $P$ moet bij een fout dan $p - 1 - j$ posities opgeschoven worden.
        \end{itemize}
        \item \textbf{Variant van Sunday}.
        \begin{itemize}
            \item ???
        \end{itemize}
    \end{enumerate}
    
\end{itemize}

\subsubsection{De heuristiek van het juiste suffix}
\begin{itemize}
    \item Hier wordt enkel de versie van de \textbf{originele Boyer-Moore} methode besproken, dus niet de varianten van Horspool of Sunday.
    \item In vele gevallen kan $f$ aan de rechterkant van foutpositie $i$ voorkomen, zodat $i - j < 0$, en er dus maar een verschuiving van 1 positie mogelijk is.
    \item Op positie $i$ in $P$ vinden we een verkeerd karakter $f$ in $T$.
    \item Er is dus een \textbf{suffix} van $P$ in $T$, met lengte $p - i - 1$.
    \item We willen weten of dit suffix $s$ nog ergens in $P$ voorkomt.
    \begin{itemize}
        \item Als er meerdere plaatsen zijn waar $s$ in $P$ voorkomt, wordt de meeste rechtse genomen.
        \item Suffixen kunnen overlappen.
    \end{itemize}
    \item We willen dus de meeste rechtste positie $j$ in $P$, waarbij $j \leq i$ waar een deelstring $s' = s$ begint.
    \item Analoog aan de prefixfunctie, is er nu een suffixfunctie $s(j)$:
    \begin{itemize}
        \item Voor elke index $j$ in $P$ wordt de lengte van het grootste suffix van $P$ bijgehouden, dat op index $j$ begint.
        \item De suffixwaarden is het omgekeerde van de prefixtabel voor het omgekeerde patroon $P$.
        \item De grootste waarde voor $j$ waarvoor $s(j) = p - i - 1$ is de waarde voor $k$.
        \item Een verschuiving $v[i]$ voor foutpositie $i$ is dan $i + 1 - k$. Als $k$ niet gedefinieerd is dan is $v[i] = p - s[0]$.
    \end{itemize}
    \item Voorbeeld:
    \begin{itemize}
        \item Het patroon $P = \texttt{ABBABAB}$.
        \item Tabel \ref{table:bm3} toont alle verschillende waarden:
        \begin{table}[ht]
            \centering
            \begin{tabular}{l | c c c c c c c}
                $i$         & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
                $p - i - 1$ & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
                \hline
                $P[i]$      & A & B & B & A & B & A & B \\
                \hline
                $s[i]$      & 2 & 1 & 3 & 2 & 1 & 0 & 0 \\
                $k$         & / & / & / & 2 & 3 & 4 & 6 \\
                $i + 1 - k$ & / & / & / & 2 & 2 & 2 & 1 \\
                $v[i]$      & 5 & 5 & 5 & 2 & 2 & 2 & 1
            \end{tabular}
            \caption{}
            \label{table:bm3}
        \end{table}
    \end{itemize}
    \item Er zijn \textbf{drie speciale gevallen} die zich kunnen voordoen:
    \begin{enumerate}
        \item \textbf{Het patroon $P$ werd gevonden}.
        \begin{itemize}
            \item Er is geen foutief patroonpositie ($i = -1$) en het juiste suffix is nu $P$ zelf.
            \item Toch mogen er geen  $p$ posities opgeschoven worden, want een nieuwe $P$ in $T$ kan de vorige gedeeltelijk overlappen.
            \item De overlapping is het langst mogelijke suffix van $P$, korter dan $p$.
            \item De verschuiving is dus $v[-1] = p - s[0]$ (virtueel tabelelement, kan geïmplementeerd worden als constante).
        \end{itemize}
        \item \textbf{Er is geen juist suffix}.
        \begin{itemize}
            \item Als $i = p - 1$, dan is er geen juist suffix.
            \item Er is geen waarde voor de verschuiving, dus de waarde van de eerste heuristiek moet gebruikt worden.
        \end{itemize}
        \item \textbf{Het juiste suffix komt niet meer in $P$ voor}.
        \begin{itemize}
            \item Er is geen index $j$ gevonden waarvoor $s(j) = p - i - 1$.
            \item De verschuiving is opnieuw $v[i] = p - s[0]$ voor $0 < i < p$.
        \end{itemize}
    \end{enumerate}
\end{itemize}

\subsection{Onzekere algoritmen}
\begin{itemize}
    \item Algoritmen die een zekere waarschijnlijkheid hebben om een geheel foutief resultaat te geven.
    \item Zulke algoritmen worden ook \textbf{Monte Carloalgoritmen} genoemd.
    \item Er zijn redenen waarom zulke algoritmen toch nuttig kunnen zijn;
    \begin{enumerate}
        \item Zulke algoritmen zijn vaak sneller.
        \begin{itemize}
            \item Een voorbeeld is een \textbf{Bloomfilter} (figuur \ref{fig:bloomfilter}).
            \begin{figure}[ht]
                \centering
                \includegraphics[width=\textwidth]{bloomfilter}
                \caption{Een bloomfilter, die de verzameling $\{x, y, z\}$ beschrijft. De logische OF met al deze elementen is al reeds uitgevoerd. De controle of $w$ ook in deze verzameling zit zegt dat deze er niet in zit, want een bit van de hashwaarde van $w$ in de bloomfilter is 0.}
                \label{fig:bloomfilter}
            \end{figure}
            \item We willen een verzameling van objecten in gehashte vorm bijhouden.
            \item Een Bloomfilter houdt de logische bitsgewijze OF bij van de hashwaarden van alle elementen.
            \item Om te weten of een object in de verzameling zit wordt deze eerst gehasht. Daarna wordt de logische EN operatie gebruikt op de bloomfilter met deze waarde.
            \item Als het resultaat verschilt van de hashwaarde dan zit het object er zeker niet in.
            \item Anders weten we het niet, en moet de verzameling doorzocht worden.
        \end{itemize}
        \item Men tracht de kans dat er een fout voorkomt zo klein mogelijk te maken.
    \end{enumerate}
\end{itemize}


\subsection{Het Karp-Rabinalgoritme}
\begin{itemize}
    \item Herleidt het vergelijken van strings tot het vergelijken van getallen.
    \item Aan elke mogelijke string die even lang is als $P$ wordt een getal toegekend.
    \item Er zijn $d^p$ verschillende strings met lengte $p$, zodat de getallen groot kunnen worden.
    \begin{itemize}
        \item Daarom worden de getallen beperkt tot deze die in één processorwoord (met lengte $w$ bits) voorgesteld kunnen worden, via een modulobewerking.
    \end{itemize}
    
    \item Meerdere strings zullen met hetzelfde getal moeten overeenkomen ($\equiv$ hashing).
    \item Gelijke strings betekent nog altijd gelijke getallen, maar een gelijk getal betekent niet meer dezelfde string.
    \begin{itemize}
        \item Bij een gelijk getal moet het patroon nog steeds vergeleken worden met de tekst op die positie.
    \end{itemize}
    \item Hoe worden de getallen gedefinieerd?
    \begin{itemize}
        \item Ze moeten in $O(1)$ berekend kunnen worden voor elk van de $O(t)$ deelstrings in de tekst.
        \item Een hashwaarde voor een string met lengte $p$ in $O(1)$ berekenen is niet realistisch.
        \item Daarom wordt de hashwaarde voor de deelstring op positie $j + 1$ berekend op basis van de deelstring op basis $j$.
        \item De eerste hashwaarde berekenen ($j = 0$) mag dan langer duren.
    \end{itemize}
    

    \item De voorstelling van $P$:
    \begin{itemize}
        \item We beschouwen een string als een getal in een $d-$tallig talstelsel omdat elk stringelement $d$ waarden kan aannemen zodat elk stringelement wordt voorgesteld door een cijfer tussen 0 en $d - 1$.
        
        $$H(P) = \sum_{i=0}^{p-1} P[i]d^{p-i-1} = P[0]d^{p-1} + P[1]d^{p-2} + \dots + P[p-2]d + P[p-1]$$

        \item Om de beperkte waarde te bekomen, wordt de rest bij deling door een getal $r$ genomen. Dit wordt de \textbf{fingerprint} genoemd.
        $$H_r(P) = H(P)\;\mathrm{mod}\;r$$
    
        \item Dit is geen efficiënte operatie omdat de individuele getallen van de som in $H(p)$ groot kunnen worden, maar gelukkig
        $$(a + b) \;\mathrm{mod}\;r = (a\;\mathrm{mod}\;r + b\;\mathrm{mod}\;r)\;\mathrm{mod}\;r$$
    
        Dit geldt ook voor verschil en het product.
    
        \item Omdat elk tussenresultaat nu binnen een processorwoord past, is $H_r(P)$ berekenen slechts $\Theta(p)$.
    \end{itemize}
    \item De voorstelling van $T$:
    \begin{itemize}
        \item De waarde $T_0$ bij beginpositie $j = 0$ wordt op dezelfde manier berekend als $P$.
        $$H(T_0) = \sum_{i=0}^{p-1} T[i]d^{p-i-1} = T[0]d^{p-1} + T[1]d^{p-2} + \dots + T[p-2]d + T[p-1]$$

        \item Er is nu een eenvoudig verband tussen het getal voor de deelstring $T_{j + 1}$ bij beginpositie $j + 1$ en dat voor $T_{j}$ bij beginpositie $j$:

        $$H(T_{j + 1}) = (H(T_j) - T[j]d^{p-1})d + T[j + p]$$

        (De waarde $T[j]d^{p-1}$ aftrekken en die van $T[j + p]$ optellen en er ook voor zorgen dat de macht die bij $T[j +1], T[j + 2], ... T[j + p -1]$  hoort met 1 verhoogt wordt door te vermenigvuldigen met $d$)

        \begin{itemize}
            \item Stel een string T = \texttt{ABCDE}, $d = 5$ en $p$ = 3 (wat $P$ is maakt niet uit voor dit voorbeeld). De waarden van de stringelementen zijn $A = 1, B = 2, C = 3, D = 4, E = 5$.
            \item De opeenvolgende waarden $T_j$ zijn dan:
            \begin{itemize}
                \item \begin{align*}
                    H(T_0) &= \sum_{i=0}^{2} T[i]5^{2-i}\\
                    & = A\cdot 5^2 + B\cdot 5^1 + C\\
                    & = 1\cdot 5^2 + 2\cdot 5^1 + 3\\
                    &= 25 + 10 + 3 = 38
                \end{align*}
                \item \begin{align*}
                    H(T_1) &= (H(T_0) - T[0]5^{2})\cdot 5 + T[3]\\
                           &= (A\cdot 5^2 + B\cdot 5 + C - A\cdot 5^2)\cdot 5 + D \\
                           &= B\cdot 5^2 + C \cdot 5 + D  \\
                           &= 2\cdot 5^2 + 3 \cdot 5 + 4  \\
                           &=  50 + 15 + 4 = 69
                \end{align*}
                \item \begin{align*}
                    H(T_2) &= (H(T_1) - T[1]5^{2})\cdot 5 + T[4]\\
                           &= (B\cdot 5^2 + C\cdot 5 + D - B\cdot 5^2)\cdot 5 + E \\
                           &= C\cdot 5^2 + D \cdot 5 + E  \\
                           &= 3\cdot 5^2 + 4 \cdot 5 + 5  \\
                           &=  75 + 20 + 5 = 100
                \end{align*}
            \end{itemize}
            
            
        \end{itemize}

        \item Analoog aan $H_r(P)$ worden de waarden $H(T)$ ook modulo $r$ genomen, zodat $$H_r(T_{j + 1}) = H(T_{j + 1})\;\mathrm{mod}\;r$$

        \item Het berekenen van $H_r(P)$, $H(T_0)$ en $d^{p-1}\;\mathrm{mod}\;r$ vereist $\Theta(p)$ operaties.
        \item Het berekenen van alle andere fingerprints $H_r(T_j) (0 < j \leq t - p)$ vergt $\Theta(t)$ operaties.
        \item Dit is $\Theta(t + p)$.
        \item Maar, de strings moeten nog vergeleken worden als de fingerprints hetzelfde zijn.
        \item In het slechtste geval zijn de fingerprints op elke positie gelijk, zodat de totale performantie $\textbf{O(tp)}$ is.
        \item Er zijn nu nog twee mogelijkheden om $r$ te bepalen:
        \begin{enumerate}
            \item \textbf{Vaste $r$}
            \begin{itemize}
                \item Kies $r$ als een zo groot mogelijk priemgetal zodat $rd \leq 2^w$.
                \item Priemgetallen zorgt ervoor dat gelijkaardige deelstrings dezelfde fingerprinters zouden opleveren.
                \item Een groot priemgetal zorgt voor een groot aantal mogelijke fingerprints.
                \item Er is nu wel een nieuw verband tussen $H_r(T_{j + 1})$ en $H_r(T_j)$:
                $$H_r(T_{j + 1}) = \bigg(\big((H_r(T_j) + r(d - 1) - T[j](d^{p-1}\;\mathrm{mod}\;r)) \;\mathrm{mod}\;r\big)d + T[j + 1] \bigg)\;\mathrm{mod}\;r$$
                
                (De term $r(d - 1)$ wordt toegevoegd om een negatief tussenresultaat te vermijden.)
            \end{itemize}


            \item \textbf{Random $r$}
            \begin{itemize}
                \item Soms is een vaste $r$ nadelig: er kan bijvoorbeeld een slechte waarde gekozen worden.
                \item De veiligste implementatie gebruikt een willekeurige priem $r$ uit een bepaald bereik.
                \item Een groter bereik reduceert de kans op fouten.
                \item Het aantal priemgetallen kleiner of gelijk aan $k$ is $\frac{k}{\ln k}$.
                \item Door $k$ groot te kiezen zal slechts een klein deel van die priemgetallen een fout veroorzaken.
                \item De kans dat $r$ één van die priemen is wordt klein.
                \item Voor $k = t^2$ is de kans op één enkele foute $O(1/t)$.
                \item Om fouten helemaal te vermijden zijn er twee mogelijkheden:
                \begin{itemize}
                    \item Overgaan naar een andere methode als de fout gesignaleerd wordt.
                    \item Herbeginnen met een nieuwe random priem $r$.
                \end{itemize}
            \end{itemize}
        \end{enumerate}

    \end{itemize}

\end{itemize}


\subsection{Zoeken met automaten}
\begin{itemize}
    \item Een \textbf{automaat} is een informatieverwerkend eenheid.
\end{itemize}
\subsubsection{Deterministische automaten}    
\begin{itemize}
     \item Een deterministische automaat (DA) bestaat uit: 
    \begin{itemize}
        \item Een eindige verzameling invoersymbolen $\Sigma$.
        \item Een eindige verzameling staten $S$.
        \item Een begintoestand $s_0 \in S$.
        \item Een eindige verzameling eindstaten $F \subset S$.
        \item Een overgangsfunctie $p(t, a)$ die de nieuwe toestand geeft wanneer de DA in toestand $t$ invoersymbool $a$ ontvangt.
    \end{itemize}
    \item Een DA kan voorgesteld worden een gelabelde multigraaf $G$.
    \begin{itemize}
        \item De knopen zijn de toestanden.
        \item De verbindingen zijn de overgangen.
    \end{itemize}
    \item Als de DA zich in een eindstaat bevindt na het invoeren van een string, dan wordt deze string herkent door de DA.
    \item Een taal die door een DA herkent wordt is regulier.
    \begin{itemize}
        \item Dit is de verzameling van labels $P_G(\{s_0\}, F)$
    \end{itemize}
\end{itemize}
\subsubsection{Niet-deterministische automaten}    
\begin{itemize}
     \item Een niet-deterministische automaat (NA) bestaat uit:
     \begin{itemize}
         \item Een eindige verzameling invoersymbolen $\Sigma$.
         \item Een eindig aantal statenbits. De verzameling van statenbits die de waarde 1 hebben is de staat van de NA.
         \item Een beginbit $b_0$ en een verzameling eindbits.
         \item De overgangsfunctie $s(i, a)$ is de verzameling statenbits die een signaal krijgen van statenbit $i$ als de inkomende letter $a$ is. Een statenbit dat een signaal binnenkrijgt krijgt de waarde 1.
         \item Nul of meerdere $\epsilon$-overgangen. Een $\epsilon$-overgang van statenbit $i$ naar statenbit $j$ zorgt ervoor dat wanneer $i$ een signaal binnenkrijgt, dit signaal direct doorstuurt naar $j$.
     \end{itemize}
     \item Een NA herkent een string als op het einde van die string er één of meer eindbits aan staan.
\end{itemize}

\subsubsection{De deelverzamelingconstructie}
\todo{todo}

\subsection{De Shift-AND-methode}
\begin{itemize}
    \item Bitgeoriënteerde methode, die zeer efficiënt werkt voor \textbf{kleine patronen}.
    \item Hou voor elke positie $j$ in $T$ bij welke prefixen van $P$ overeenkomen met de tekst, eindigend op $j$.
    \item Er is een tabel $S$ met $d$ woorden (tabel \ref{table:shiftandS}). Een bit $i$ van woord $S[s]$ is waar als karakter $s$ op plaats $i$ in $P$ voorkomt.
    \begin{table}[ht]
        \centering
        \begin{tabular}{l | c c c c c c c c}
            & G & C & A & G & A & G & A & G \\
            \hline
            S['G'] & \textbf{1} & 0 & 0 & \textbf{1} & 0 & \textbf{1} & 0 & \textbf{1} \\
            S['C'] & 0 & \textbf{1} & 0 & 0 & 0 & 0 & 0 & 0 \\
            S['T'] & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
            S['A'] & 0 & 0 & \textbf{1} & 0 & \textbf{1} & 0 & \textbf{1} & 0 \\
        \end{tabular}
        \caption{De tabel $S$ bevat een bitpatroon voor elk karakter $s$ in het alfabet. Karakters die niet in het patroon voorkomen krijgen een bitpatroon bestaande uit $p$ nulbits.} 
        \label{table:shiftandS}
    \end{table}
    \item Een tabel $R_j$ van $p$ logische waarden geeft voor het $i$-de element het prefix van lengte $i$, die hoort bij tekstpositie $j$.
    %\item In totaal zijn er $t$ van deze $R_j$ tabellen (tabel \ref{table:shiftandR}).

    \begin{table}[ht]
        \centering
        \scalebox{0.6}{
        
        \begin{tabular}{|c c | c c c c c c c c c c c c c c c c c c c c c c c c |}
            \hline
            & & $R_0$&$R_1$&$R_2$&$R_3$&$R_4$&$R_5$&$R_6$&$R_7$&$R_8$&$R_9$&$R_{10}$&$R_{11}$&$R_{12}$&$R_{13}$&$R_{14}$&$R_{15}$&$R_{16}$&$R_{17}$&$R_{18}$&$R_{19}$&$R_{20}$&$R_{21}$&$R_{22}$&$R_{23}$\\
            & & G&C&A&T&C&G&C&A&G&A&G&A&G&T&A&T&A&C&A&G&T&A&C&G\\
            \hline
            $R[0]$ & G & \textbf{1} & 0&0&0&0&\textbf{1}&0&0&\textbf{1}&0&\textbf{1}&0&\textbf{1}&0&0&0&0&0&0&\textbf{1}&0&0&0&\textbf{1}  \\
            $R[1]$ & C & 0 & \textbf{1}&0&0&0&0&\textbf{1}&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0  \\
            $R[2]$ & A & 0 & 0&\textbf{1}&0&0&0&0&\textbf{1}&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0  \\
            $R[3]$ & G & 0 & 0&0&0&0&0&0&0&\textbf{1}&0&0&0&0&0&0&0&0&0&0&0&0&0&0&0  \\
            $R[4]$ & A & 0 & 0&0&0&0&0&0&0&0&\textbf{1}&0&0&0&0&0&0&0&0&0&0&0&0&0&0  \\
            $R[5]$ & G & 0 & 0&0&0&0&0&0&0&0&0&\textbf{1}&0&0&0&0&0&0&0&0&0&0&0&0&0  \\
            $R[6]$ & A & 0 & 0&0&0&0&0&0&0&0&0&0&\textbf{1}&0&0&0&0&0&0&0&0&0&0&0&0  \\
            $R[7]$ & G & 0 & 0&0&0&0&0&0&0&0&0&0&0&\textbf{1}&0&0&0&0&0&0&0&0&0&0&0  \\
            \hline
        \end{tabular}
        %\caption{De opeenvolgende tabellen $R_j$. Er moet slechts één tabel in het geheugen bijgehouden worden, en dat is die op het huidige karakterpositie $j$.}
        %\label{table:shiftandR}
        }
    \end{table}

    \begin{itemize}
        \item De startabel $R_0$ wordt opgebouwd als $R_0[0] = 1$ en $R_0[1\;\cdots\;p - 1] = 0$.
        \item Opeenvolgende tabellen $R_{j + 1}$ kunnen via efficiënte bitoperaties bekomen worden:
        $$R_{j + 1} = \hbox{Schuif}(R_j) \hbox{ EN } S[T[j + 1]]$$
        \item De schuif-operatie verschuift een bitpatroon naar rechts, en voegt links een éénbit toe.
    \end{itemize}

    \item Het patroon wordt gevonden in de tekst op positie $j - p$ als $R_j[p - 1] = 1$.

    \item Er zijn ook \textbf{benaderingen mogelijk}. Deze benaderingen maken gebruik van dezelfde tabel $R_j = R^0_j$, en een nieuwe tabel $R^1_j$, waarvan de definitie afhankelijk is van het soort benadering. 
    \begin{itemize}
        \item \textbf{Karakters inlassen} 
        \begin{itemize}
            \item De tabel $R^1_j$ duidt alle prefixen aan eindigend op positie $j$ met hoogstens één inlassing.
            $$R^1_{j + 1} = R^0_j \hbox{ OF }(\hbox{Schuif}(R_j) \hbox{ EN } S[T[j + 1]]) $$.
        \end{itemize}
        \item \textbf{Karakters verwijderen} 
        \begin{itemize}
            \item De tabel $R^1_j$ duidt alle prefixen aan eindigend op positie $j$  met hoogstens één verwijdering.
            $$R^1_{j + 1} = \hbox{Schuif}(R^0_{j+1}) \hbox{ OF }(\hbox{Schuif}(R_j) \hbox{ EN } S[T[j + 1]]) $$
        \end{itemize}
        \item \textbf{Karakters vervangen}
        \begin{itemize}
            \item De tabel $R^1_j$ duidt alle prefixen aan eindigend op positie $j$ waarbij $i - 1$ van de eerste $i$ karakters van $P$ overeenkomen met $i - 1$ karakters van de $i$ karakters die in de tekst eindigen bij positie $j$.
            $$R^1_{j + 1} = \hbox{Schuif}(R^0_{j}) \hbox{ OF }(\hbox{Schuif}(R_j) \hbox{ EN } S[T[j + 1]]) $$
        \end{itemize}
    \end{itemize}
\end{itemize}

