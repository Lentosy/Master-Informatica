\chapter{Data Flow Analysis}
Compilers maken programma's kleiner, sneller. Zelfs perfecte $C++$ code kan nog steeds verbeterd worden. Een ontwerper van een programmeertaal gaat ervan uit dat een compiler veel \textit{under the hood} functies heeft.


\section{Analyse en transformaties}
\begin{itemize}
	\item Verzamel informatie
	\item Controleer de eigenschappen (precondities)
	\item Voer de transformatie uit
\end{itemize}

Interproceduraal = van meerdere procedures informatie verzamelen zodat een functie eigenschappen kan bevatten van andere functies.

Lokaal = slechts één blok wordt bekeken in een functie

Globaal = alle blokken in een functie wordt bekeken


\begin{lstlisting}
a = 1
b = a
a = 2
c = a
\end{lstlisting}
Welke waarde zit in $c$? 

Flow insensitief = slechts één eigenschap bijhouden per variabele.
\begin{lstlisting}
a = ?
b = ?
\end{lstlisting}

Flow sensitief = per blok in het programma eigenschappen bijhouden
\begin{lstlisting}
a1 = 1
b = a1
a2 = 2
c = a2
\end{lstlisting}

als een blok van meerdere paden kan bereikt worden, kan een variabele meerdere waarden aannemen.
Pad insensitief =  geen rekening houden met het pad, zodat we niet weten welke waarde een variabele heeft



Pad sensitief = Wel rekening houden met de verschillende paden


Voorbeeld slide 4
\begin{itemize}
	\item Javacode
	\item In veld $f$ van type $A$ kan ofwel object van type $B$ of $C$ zitten.	
	\item De \texttt{toString()} methode kan ofwel die van $B$ of van $C$ oproepen. Maar het is duidelijk dat het van type $B$ is, dus er is iets fout gelopen in de analyse.
	\item Voeg virtuele klassen $A1$ en $A2$ toe die beiden een attribuut $f$ hebben die respectievelijk een object van type $B$ en $C$ kunnen hebben.
	\item Het object $o$ zal nu zeker weten dat de toString() van object $B$ opgeroepen moet worden.
\end{itemize}


Niet altijd nuttig om zo sensitief mogelijk te gaan = te veel geheugen nodig.

\section{Reaching definitions}
Een niet-ambigue definitie $d$ van $t$ is
$$d: t \leftarrow M[a] \quad\hbox{of}\quad t \leftarrow a + b$$
Een ambigue definitie: call die al dan niet de waarde van $t$ wijzigt.

Een statement $d$ is reaching definition van statement $u$ als er een pad van $d$ naar $u$ bestaat waarop geen niet-ambigue definitie van $t$ voorkomt. Controleer in de controleverloopgraaf. Als de definitie van $t$ niet aangepast wordt dan is $d$ een reaching definition van $u$.  Zie tabel 17.2: de gen- en killset zijn sets van statements, bij liveliness is het set van temporaries. In andere woorden: hoe lang is een definitie van een veranderlijke geldig (vergelijkbaar met liveliness analyse, maar de vergelijking is met de unie van predecessors).
\begin{lstlisting}
d_2: t \left ...  
d_1: t \left ... 
d:t \left ... 
... 
... 
 u: ...
\end{lstlisting}


\QA{Waarom is reaching definitions nuttig?}{
Als je op een bepaald punt ziet dat er geen reaching definition is, dan zit je met een uninitialized variabele.
}

\section{Available expressions}
Een expressie $a op b$ is available bij statement $u$ als $a op b$ op elk een pad naar $u$ berekend wodt, en tussen die berekening en $u$ worden $a$ en $b$ niet meer gewijzigd.
De gen- en killset zijn nu verzamelingen van expressies. 
\begin{lstlisting}
x \leftarrow t \times u
t \leftarrow ...
x \leftarrow t \times u
\end{lstlisting}
De killset zijn alle expressies waar $t$ in zit.

\QA{Waarom is het nuttig?}{
Om te controleren of dat expressies opnieuw moeten berekend worden of niet.
}

Terug voorwaartste vergelijking: belangrijk verschil met vorige vergelijkingen: het gaat over de doorsnede van de predecessors. Hoe initialiseren? De maximale set: alle expressies in het programma.

\section{Optimalisaties}
\begin{itemize}
	\item Common-subexpression elimination
	\begin{itemize}
		\item In plaats van nieuwe berekeningen uit te voeren, gebruik het resultaat van vorige berekeningen
	\end{itemize}
	\item Constant propagation
	\begin{itemize}
		\item Stel dat je aan $t \leftarrow 3$
		\item Dan $a = t x b$
		\item Als je weet dat er slechts één toekenning (via reaching definitions) is van $t$, dan kan $t$ vervangen worden door de constante $3$.
		\item Als dit voor $b$ ook zou zijn, dan wordt (voor $b = 2$) $a = 6$.
		\item Via reaching definitions voor $a$ kan zo verder geoptimaliseerd worden.
		
	\end{itemize}
	\item Copy propagation
	\begin{itemize}
		\alert Waarom niet gewoon coalescing tijdens register allocation?
		\begin{itemize}
			\item Omdat sommige optimalisatiemogelijkheden  verdwijnen
		\end{itemize}
	\end{itemize}
	\item Dead code elimination
	\begin{itemize}
		\item Ergens een definitie die nooit gebruikt wordt
		\item Statement schrappen.
	\end{itemize}
\end{itemize}

Deze optimalisaties worden iteratief uitgevoerd: het toepassen van een optimalisatie laat nieuwe optimalisaties toe.

\section{Snellere analyses}

\begin{enumerate}
	\item Bitvectors
	\item Slechts voor elk basic blok toepassen.
	\item Volgorde van toepassen aanpassen (zie algoritme onderaan slide 15)
	\item Er wordt enkel de out set bijhouden, de inset wordt telkens opnieuw berekend omdat die vaak kleiner zijn, zodat er minder geheugen nodig is om al de sets bij te houden.
	\item chains 
	\begin{itemize}
		\item use def  = bijhouden van alle reaching definitions van een temporary
		\item def use = omgekeerd
	\end{itemize}
	\item Work-list algoritme houdt bij waar er nog berekeningen nodig kunnen zijn. (algoritme 17.6)
\end{enumerate}

\section{Incrementele analyses}
Elke transformatie heeft invloed op resultaten van de analyse. Moeten we dan de hele analyse opniew doen? Als $z$ dood is, moet van onder naar boven elke keer het statement verwijderd worden bij elke iteratie.

\section{Value Numbering}
Elke expressie een nummer geven en hergebruiken van die expressies.

\section{Incremente livenessanalyse}
Veel te moeilijk om te implementeren, wordt bijna nooit gebruikt.

\section{Alias Analysis}
Niet in detail te kennen

Kunnen $p$ en $q$ naar hetzelfde object wijzen (may-alias informatie)?
Wijst $p$ en $q$ naar hetzelfde object (must-alias informatie)? 

Een zeer moeilijke analyse en hebben maar een beperkte precisie (in bv $C$ en $C++$)

Herordenen van geheugenoperaties: waarom is dit van zo een groot belang? voor parallelisatie.