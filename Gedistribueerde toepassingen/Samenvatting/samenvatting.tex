\documentclass{report}

\usepackage{ugentstyle}
\usepackage{listings}



\begin{document}
	\maketitle{Gedistribueerde toepassingen}
	\tableofcontents
	
	\part{Theorie}
	\chapter{Extensible Stylesheet Language Family}
	\section{Inleiding}
	XSL staat voor \textit{Extensible Stylesheet Language Family} en is een standaard om XML-documenten te presenteren en te transformeren. De drie componenten van XSL zijn:
	\begin{itemize}
		\item \textbf{XSLT} (Extensible Stylesheet Language Transformations) : dit is een XML-taal dat XML-documenten kan omvormen naar opnieuw XML, maar kan ook HTML, \LaTeX, JSON, enz... zijn.
		\item \textbf{XPath} : dit is een taal dat waarmee bepaalde stukken van een XML-document kunnen gemanipuleerd worden aan de hand van het opbouwen van paden.
		\item XSL-FO (XSL Formatting Objects)
	\end{itemize}
	\section{XSLT}
	\subsection{Structuur}
	Een XSLT-bestand moet altijd voldoen aan volgende structuur:
	\begin{lstlisting}
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" 
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
	<xsl:output method="html"/>
	<xsl:template match="patroon">
	...
	</xsl:template>
	...
</xsl:stylesheet>
	\end{lstlisting}
	\begin{enumerate}
		\item \texttt{xsl:stylesheet} is het basiselement
		\item \texttt{xsl:output} is het element dat het type transformatie vastlegt in het attribuut \textit{method}
		\item \texttt{xsl:template} bevat wat er moet gebeuren voor elk element dat aan \textit{patroon} voldoet.
	\end{enumerate}

	\subsection{Instructie-elementen}
	\begin{itemize}
		\item \textbf{xsl:value-of} : Bepaalt de waarde van een XPath uitdrukking.
		
			  \texttt{<xsl:value-of select='uitdrukking'/>}
			  
		\item \textbf{apply-templates} : Zal de templates van de onmiddelijke kindelementen van het huidig element toepassen. Indien er geen templates zijn, zal de inhoud van het element naar de uitvoer uitgeschreven worden. Het optionele \textit{select} attribuut zal enkel de templates uitvoeren voor elk element die aan de uitdrukking voldoet.
		
			  \texttt{<xsl:apply-templates [select='uitdrukking']/>}
			  
		\item \textbf{xsl:for-each} : Voert een actie uit voor alle knopen die door het \textit{select}-attribuut bepaalt wordt. Binnen de for-each kunnen meerdere instructie-elementen voorkomen.
		
			  \texttt{<xsl:for-each select'uitdukking'>...</xsl:for-each>}
			  
		\item \textbf{xsl:sort} :Dit is een kindelement van \textit{xsl:apply-templates} of een \textit{xsl:for-each} element. Dit element zal de knopen sorteren die aan de waarde van het select attribuut voldoen. Optionele attributen zijn
			\begin{itemize}
				\item data-type : legt het datatype vast (\textit{text} of \textit{number}). Dit heeft een invloed op de sorteervolgorde (bij \textit{text} is 10 kleiner dan 2).
				\item order : bepaalt de sorteervolgorde (\textit{ascending} of \textit{descending}).
			\end{itemize}
				
				\texttt{<xsl:sort select='uitdrukking' [data-type='text|number'] [order='ascending|descending]/>}
		
		\item \textbf{xsl:if} : Dit is een typische selectiestructuur. Het bevat als enig attribuut \textit{test} met als waarde een predicaat.
		
			  \texttt{<xsl:if test='logische uitdrukking'> ... </xsl:if>}
			  
		\item \textbf{xsl:choose} : Een alternatieve selectiestructuur equivalent zoals een switch in programeertalen zoals Java en C\#. Dit element wordt gevolgd door één of meerdere \textbf{xsl:when} elementen. Een xsl:when element is equivalent met een xsl:if element en heeft ook als enig attribuut \textit{test}.
		\begin{lstlisting}
<xsl:choose>
	<xsl:when test="logische uitdrukking 1">
		... 
	</xsl:when>
	<xsl:when test="logische uitdrukking 2"> 
		... 
	</xsl:when>
	...
</xsl:choose>
		\end{lstlisting}
		
		\item \textbf{xsl:text} : Wanneer tekst spaties bevat is het aan te raden om xsl:text te gebruiken zodat deze ook opgenomen worden in het resultaat. Spaties die niet in een xsl:text element staan worden genegeerd.
		
		\texttt{<xsl:text>stukje tekst</xsl:text>}
		
		\item \textbf{xsl:variable} : Legt een constante variabele vast. Het verplichte attribuut is \textit{name}, wat de naam van de variabele vastlegt. Het invullen van deze waarden kan op twee manieren :
		\begin{enumerate}
			\item via het select attribuut \texttt{<xsl:variabele name='varnaam' select='uitdrukking'/>}
			\item via de inhoud van het element: \texttt{<xsl:variabele name ="varnaam">
				...
			</xsl:variable>}
			In dit geval kan de waarde ook opgebouwd worden uit meerdere instructies.
		\end{enumerate}
	
		\item \textbf{xsl:param} : Indien dit element gedeclareerd wordt in het begin van een xls:template element, dan is het mogelijk om parameters mee te geven aan dit template. De declaratie kan op dezelfde manier gebeuren als bij xsl:variabele.
		
		\item \textbf{xsl:with-param} : Dit element is een kindobject van xsl:apply-templates. Dit element vult voor een bepaalde \textit{name} de waarde die in \textit{select} staat.
		
		\begin{lstlisting}
<xsl:apply-templates ...>
	<xsl:with-param name='varnaam' select='uitdrukking'>
</xsl:apply-templates>
		\end{lstlisting} 
	\end{itemize}

	\chapter{XML Path Language (XPath)}
	XPath is een taal om knopen te selecteren van een XML-document. Het resultaat van een XPath-uitdrukking kan een getal, string of logische waarde zijn.
	\section{Paden}
	Belangrijke XPath uitdrukkingen zijn paden. Een pad identificeert nul, één of meerdere knopen in een XML-document. Een pad bestaat uit \textit{location steps} die verbonden zijn met een /. Bij elk pad zijn volgende wildcards mogelijk:
	\begin{itemize}
		\item *: selecteert elk elementknoop in de huidige context.
		\item node(): selecteert alle knopen, dus niet enkel elementen
		\item @*: selecteert alle attributen in de huidige context.
	\end{itemize}
	\subsection{Basispad (Root Location Path)}
	
	Het eenvoudigste pad is \texttt{/} en selecteert het root-element van het XML-document. Verder is dit een absoluut pad, dus deze uitdrukking zal \textbf{altijd} het root-element teruggeven.
	\subsection{Kinelement-stap (Child Element Location Steps)}
	Dit pad bestaat uit de naam van een element en selecteert alle elementen met deze naam in de huidige context. De context is afhankelijk van de ouder. 
	
	\begin{lstlisting}
<xsl:template match ="author">
	<xls:apply-templates select="name" />
</xls:template>
	\end{lstlisting}
	In dit voorbeeld wordt de XPath uitdrukking van het selectattribuut \texttt{/author/name/}.
	
	\subsection{Attribuut-stap (Attribute Location Steps)}
	Een attribuut selecteren begint met een @ en wordt gevolgd door de naam van het attribuut.	
	\begin{lstlisting}
<xsl:template match ="query">
	<xls:value-of select="@isbn"/>
</xls:template>
	\end{lstlisting}
	
	\subsection{Voorwaarden}
	\begin{lstlisting}
<xsl:apply-templates select="//book[title='XML']//name[.='Ongenae]"/>
	
<xsl:apply-templates select="//person[@born<=1976]"/>
	\end{lstlisting}
	\subsection{Lange padnamen}
	In elke XPath uitdrukking wordt elke stap voorafgegaan door de child:: as.
	
	\texttt{books/book/isbn => child::books/child::book/child::isbn}
	
	andere assen:
	\begin{itemize}
		\item parent (of ..)
		\item self (of .)
		\item descendant-or-self (of //)
		\item ancestor 
		\item ancestor-or-self
		\item namespace
		\item descendant
		\item following-sibling
		\item preceding-sibling
		\item following
		\item preceding
	\end{itemize}
	\includegraphics[width=\textwidth]{assen_XPath}
	
	\section{Andere XPath-uitdrukkingen}
	XPath kan ook getallen, logische waarden en strings manipuleren.
	\subsection{Datatypes}
	\begin{itemize}
		\item \textbf{Getallen} : Stel dat \textit{born} het geboortejaar van een persoon is, dan zal de volgende uitdrukking de eeuw uitschrijven van dit jaar.
		\texttt{<xls:value of select="(@born - (@born mod 100)) div 100 + 1"}
		
		\item \textbf{Strings} : Strings staan tussen enkele of dubbele aanhalingstekens. Strings vergelijken kan met = en != operatoren.
		
		\item \textbf{Logische waarden} : De sleutelwoorden true en false bestaan niet in XPath, wel worden ze respectievelijk voorgesteld door de functies true() en false(). Op logische waarden kunnen de operatoren \textit{and} en \textit{or} toegepast worden. Met not(...) wordt de negatie toegepast.
		
	\end{itemize}

	\section{Functies}
	XPath kent een aantal functies.
	\begin{itemize}
		\item \textbf{Knopenfuncties} zoals \textit{position()}, \textit{last()}, \textit{count(...)} en \textit{id(...)} bepalen respectievelijk \begin{itemize}
			\item het volgnummer van de huidige knoop in de context, 
			\item het aantal knopen in de huidige context (volgnummer van de laatste knoop),
			\item telt het aantal knopen van het argument, dat een verzameling knopen is en
			\item bepaalt een verzameling knopen. Deze verzameling bevat alle elementen van een XML-document met één van de gespecifieerde ID's. Het argument is een string bestaande uit ID's gescheiden door spaties.
		\end{itemize}
	
		\item \textbf{Stringfuncties} zoals \textit{concat(...)}, \textit{contains(...)}, \textit{starts-with(...)}, \textit{string(...)} (conversie naar string) en \textit{string-length(...)}.
		
		\item \textbf{Logische functies} zoals \textit{true()}, \textit{false()}, \textit{not(...)}, \textit{boolean(...)} (conversie naar bool waarde).
		
		\item \textbf{Numerieke functies} zoals \textit{ceiling(...)}, \textit{floor(...)}, \textit{number(...)}, \textit{round(...}).
	\end{itemize}
	
\end{document}
