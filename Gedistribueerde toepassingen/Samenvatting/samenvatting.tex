\documentclass{report}

\usepackage{ugentstyle}
\usepackage{listings}


\begin{document}
	\maketitle{Gedistribueerde toepassingen}
    \tableofcontents

	
	\part{Theorie}
	\chapter{Extensible Stylesheet Language Family}
	\section{Inleiding}
	XSL staat voor \textit{Extensible Stylesheet Language Family} en is een standaard om XML-documenten te presenteren en te transformeren. De drie componenten van XSL zijn:
	\begin{itemize}
		\item \textbf{XSLT} (Extensible Stylesheet Language Transformations) : dit is een XML-taal dat XML-documenten kan omvormen naar opnieuw XML, maar kan ook HTML, \LaTeX, JSON, enz... zijn.
		\item \textbf{XPath} : dit is een taal dat waarmee bepaalde stukken van een XML-document kunnen gemanipuleerd worden aan de hand van het opbouwen van paden.
		\item XSL-FO (XSL Formatting Objects)
	\end{itemize}
	\section{XSLT}
	\subsection{Structuur}
	Een XSLT-bestand moet altijd voldoen aan volgende structuur:
	\begin{lstlisting}
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" 
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
	<xsl:output method="html"/>
	<xsl:template match="patroon">
	...
	</xsl:template>
	...
</xsl:stylesheet>
	\end{lstlisting}
	\begin{enumerate}
		\item \texttt{xsl:stylesheet} is het basiselement
		\item \texttt{xsl:output} is het element dat het type transformatie vastlegt in het attribuut \textit{method}
		\item \texttt{xsl:template} bevat wat er moet gebeuren voor elk element dat aan \textit{patroon} voldoet.
	\end{enumerate}

	\subsection{Instructie-elementen}
	\begin{itemize}
		\item \textbf{xsl:value-of} : Bepaalt de waarde van een XPath uitdrukking.
		
			  \texttt{<xsl:value-of select='uitdrukking'/>}
			  
		\item \textbf{apply-templates} : Zal de templates van de onmiddelijke kindelementen van het huidig element toepassen. Indien er geen templates zijn, zal de inhoud van het element naar de uitvoer uitgeschreven worden. Het optionele \textit{select} attribuut zal enkel de templates uitvoeren voor elk element die aan de uitdrukking voldoet.
		
			  \texttt{<xsl:apply-templates [select='uitdrukking']/>}
			  
		\item \textbf{xsl:for-each} : Voert een actie uit voor alle knopen die door het \textit{select}-attribuut bepaalt wordt. Binnen de for-each kunnen meerdere instructie-elementen voorkomen.
		
			  \texttt{<xsl:for-each select'uitdukking'>...</xsl:for-each>}
			  
		\item \textbf{xsl:sort} :Dit is een kindelement van \textit{xsl:apply-templates} of een \textit{xsl:for-each} element. Dit element zal de knopen sorteren die aan de waarde van het select attribuut voldoen. Optionele attributen zijn
			\begin{itemize}
				\item data-type : legt het datatype vast (\textit{text} of \textit{number}). Dit heeft een invloed op de sorteervolgorde (bij \textit{text} is 10 kleiner dan 2).
				\item order : bepaalt de sorteervolgorde (\textit{ascending} of \textit{descending}).
			\end{itemize}
				
				\texttt{<xsl:sort select='uitdrukking' [data-type='text|number'] [order='ascending|descending]/>}
		
		\item \textbf{xsl:if} : Dit is een typische selectiestructuur. Het bevat als enig attribuut \textit{test} met als waarde een predicaat.
		
			  \texttt{<xsl:if test='logische uitdrukking'> ... </xsl:if>}
			  
		\item \textbf{xsl:choose} : Een alternatieve selectiestructuur equivalent zoals een switch in programeertalen zoals Java en C\#. Dit element wordt gevolgd door één of meerdere \textbf{xsl:when} elementen. Een xsl:when element is equivalent met een xsl:if element en heeft ook als enig attribuut \textit{test}.
		\begin{lstlisting}
<xsl:choose>
	<xsl:when test="logische uitdrukking 1">
		... 
	</xsl:when>
	<xsl:when test="logische uitdrukking 2"> 
		... 
	</xsl:when>
	...
</xsl:choose>
		\end{lstlisting}
		
		\item \textbf{xsl:text} : Wanneer tekst spaties bevat is het aan te raden om xsl:text te gebruiken zodat deze ook opgenomen worden in het resultaat. Spaties die niet in een xsl:text element staan worden genegeerd.
		
		\texttt{<xsl:text>stukje tekst</xsl:text>}
		
		\item \textbf{xsl:variable} : Legt een constante variabele vast. Het verplichte attribuut is \textit{name}, wat de naam van de variabele vastlegt. Het invullen van deze waarden kan op twee manieren :
		\begin{enumerate}
			\item via het select attribuut \texttt{<xsl:variabele name='varnaam' select='uitdrukking'/>}
			\item via de inhoud van het element: \texttt{<xsl:variabele name ="varnaam">
				...
			</xsl:variable>}
			In dit geval kan de waarde ook opgebouwd worden uit meerdere instructies.
		\end{enumerate}
	
		\item \textbf{xsl:param} : Indien dit element gedeclareerd wordt in het begin van een xls:template element, dan is het mogelijk om parameters mee te geven aan dit template. De declaratie kan op dezelfde manier gebeuren als bij xsl:variabele.
		
		\item \textbf{xsl:with-param} : Dit element is een kindobject van xsl:apply-templates. Dit element vult voor een bepaalde \textit{name} de waarde die in \textit{select} staat.
		
		\begin{lstlisting}
<xsl:apply-templates ...>
	<xsl:with-param name='varnaam' select='uitdrukking'>
</xsl:apply-templates>
		\end{lstlisting} 
	\end{itemize}

	\chapter{XML Path Language (XPath)}
	XPath is een taal om knopen te selecteren van een XML-document. Het resultaat van een XPath-uitdrukking kan een getal, string of logische waarde zijn.
	\section{Paden}
	Belangrijke XPath uitdrukkingen zijn paden. Een pad identificeert nul, één of meerdere knopen in een XML-document. Een pad bestaat uit \textit{location steps} die verbonden zijn met een /. Bij elk pad zijn volgende wildcards mogelijk:
	\begin{itemize}
		\item *: selecteert elk elementknoop in de huidige context.
		\item node(): selecteert alle knopen, dus niet enkel elementen
		\item @*: selecteert alle attributen in de huidige context.
	\end{itemize}
	\subsection{Basispad (Root Location Path)}
	
	Het eenvoudigste pad is \texttt{/} en selecteert het root-element van het XML-document. Verder is dit een absoluut pad, dus deze uitdrukking zal \textbf{altijd} het root-element teruggeven.
	\subsection{Kinelement-stap (Child Element Location Steps)}
	Dit pad bestaat uit de naam van een element en selecteert alle elementen met deze naam in de huidige context. De context is afhankelijk van de ouder. 
	
	\begin{lstlisting}
<xsl:template match ="author">
	<xls:apply-templates select="name" />
</xls:template>
	\end{lstlisting}
	In dit voorbeeld wordt de XPath uitdrukking van het selectattribuut \texttt{/author/name/}.
	
	\subsection{Attribuut-stap (Attribute Location Steps)}
	Een attribuut selecteren begint met een @ en wordt gevolgd door de naam van het attribuut.	
	\begin{lstlisting}
<xsl:template match ="query">
	<xls:value-of select="@isbn"/>
</xls:template>
	\end{lstlisting}
	
	\subsection{Voorwaarden}
	\begin{lstlisting}
<xsl:apply-templates select="//book[title='XML']//name[.='Ongenae]"/>
	
<xsl:apply-templates select="//person[@born<=1976]"/>
	\end{lstlisting}
	\subsection{Lange padnamen}
	In elke XPath uitdrukking wordt elke stap voorafgegaan door de child:: as.
	
	\texttt{books/book/isbn => child::books/child::book/child::isbn}
	
	andere assen:
	\begin{itemize}
		\item parent (of ..)
		\item self (of .)
		\item descendant-or-self (of //)
		\item ancestor 
		\item ancestor-or-self
		\item namespace
		\item descendant
		\item following-sibling
		\item preceding-sibling
		\item following
		\item preceding
	\end{itemize}
	\includegraphics[width=\textwidth]{assen_XPath}
	
	\section{Andere XPath-uitdrukkingen}
	XPath kan ook getallen, logische waarden en strings manipuleren.
	\subsection{Datatypes}
	\begin{itemize}
		\item \textbf{Getallen} : Stel dat \textit{born} het geboortejaar van een persoon is, dan zal de volgende uitdrukking de eeuw uitschrijven van dit jaar.
		\texttt{<xls:value of select="(@born - (@born mod 100)) div 100 + 1"}
		
		\item \textbf{Strings} : Strings staan tussen enkele of dubbele aanhalingstekens. Strings vergelijken kan met = en != operatoren.
		
		\item \textbf{Logische waarden} : De sleutelwoorden true en false bestaan niet in XPath, wel worden ze respectievelijk voorgesteld door de functies true() en false(). Op logische waarden kunnen de operatoren \textit{and} en \textit{or} toegepast worden. Met not(...) wordt de negatie toegepast.
		
	\end{itemize}

	\section{Functies}
	XPath kent een aantal functies.
	\begin{itemize}
		\item \textbf{Knopenfuncties} zoals \textit{position()}, \textit{last()}, \textit{count(...)} en \textit{id(...)} bepalen respectievelijk \begin{itemize}
			\item het volgnummer van de huidige knoop in de context, 
			\item het aantal knopen in de huidige context (volgnummer van de laatste knoop),
			\item telt het aantal knopen van het argument, dat een verzameling knopen is en
			\item bepaalt een verzameling knopen. Deze verzameling bevat alle elementen van een XML-document met één van de gespecifieerde ID's. Het argument is een string bestaande uit ID's gescheiden door spaties.
		\end{itemize}
	
		\item \textbf{Stringfuncties} zoals \textit{concat(...)}, \textit{contains(...)}, \textit{starts-with(...)}, \textit{string(...)} (conversie naar string) en \textit{string-length(...)}.
		
		\item \textbf{Logische functies} zoals \textit{true()}, \textit{false()}, \textit{not(...)}, \textit{boolean(...)} (conversie naar bool waarde).
		
		\item \textbf{Numerieke functies} zoals \textit{ceiling(...)}, \textit{floor(...)}, \textit{number(...)}, \textit{round(...}).
	\end{itemize}

	\section{Groeperen met de methode van Meunchian}
	Groeperen op een bepaald attribuut kan op twee manieren. 
	\begin{itemize}
		\item \underline{Zonder \texttt{xsl:key} te gebruiken}: 
			Je kan in een variabele alle elementen steken die geen broeren hebben, die hiërarchisch voor hun liggen, met dezelfde waarde voor dat attribuut:
			\begin{lstlisting}
<xsl:variable 
  name='varnaam' 
  select='element[not(attr = preceding-sibling::element/attr)]'
/>
			\end{lstlisting}
			De variabele bevat nu het eerste element voor elke verschillende waarde voor het attribuut. Om nu de verschillende elementen op te vragen, die dezelfde waarde hebben voor het gegroepeerde attribuut, kan je volgende as gebruiken:
			$$\texttt{element[attr = current()/attr]}$$
			
			Deze methode is uiteraard niet performant, aangezien elke knoop eerst al zijn voorgaande broeren moet overlopen en daarna moet elke knoop overlopen worden om de elementen met de huidige waarde voor het attribuut op te zoeken.
		\item \underline{Door \texttt{xsl:key} te gebruiken}: 
			Deze xsl instructie geeft een sleutel aan een element op basis van een één of meerdere attributen. Elementen die dezelfde waarde voor een attribuut hebben, krijgen dezelfde sleutel toegekend. Het \texttt{use} attribuut specifieert het attribuut waarop de sleutel gebaseerd moet worden.
			$$\texttt{<xsl:key match='element' use='attribuut' name='sleutelnaam'/>}$$
			Nu kan eenvoudig alle elementen opgehaald worden die een bepaalde waarde voor het attribuut hebben:
			$$\texttt{<xsl:for-each select="key('sleutelnaam','attribuutwaarde')">}$$
			Men kan ook alle elementen gegroepeerd ophalen, zonder expliciet de attribuutwaarde mee te geven, door nog een buitenlus te definieëren die elke waarde van het attribuut achterhaald door enkel de eerste tegenkomst van die waarde te selecteren:
			$$\texttt{<xsl:for-each select='element[count(. | key('..', attr)[1]) = 1]">}$$
			waarbij \texttt{attr} de naam van het attribuut is en \texttt{..} (wegens plaatsgebrek) de naam van de sleutel.


	\end{itemize}

\chapter{Webservices}
Een gedistribueerd systeem zal over verschillende servers APIs beschikbaar hebben. Tabel \ref{table:mono_vs_distributed} geeft de voornaamste verschillen tussen een monolitische architectuur en een gedistribueerde architectuur.
\begin{table}[ht]
	\begin{tabular}{l | l | l}
		& Monolitisch & Gedistribueerd \\
		\hline
		Communicatie & Tussen processen, gedeeld geheugen & Over een netwerk \\
		Globale toestand & Mogelijk & Niet mogelijk \\
		Globale tijd & Mogelijk via lokaal besturingssysteem & Niet mogelijk \\
		Fouten & Eenvoudig te ontdekken & Gedeeltelijk falen moeilijk te ontdekken \\
		Locatie & Alle componenten op één machine & Variabel \\
		Beveiliging & Taak van het besturingssysteem & Inherent kwetsbaar door networkcommunicatie.
	\end{tabular}
	\caption{Monolitisch versus gedistribueerd.}
	\label{table:mono_vs_distributed}
\end{table}

Er zijn twee belangrijke componenten bij gedistribueerde systemen :
\begin{itemize}
	\item \textbf{EDI  (Electronic Data Interchange)}
	\item \textbf{RPC (Remote Procedure Call)}.
\end{itemize}
 
\section{Componenten}
\subsection{EDI}
Dit soort toepassingen digitaliseren het papierwerk dat vaak plaatsvindt in eender welke organisatie. Dit werkt in drie stappen:
\begin{enumerate}
	\item Verzamel de informatie die verzonden moet worden. Deze data komt vaak uit interne bronnen, die een willekeurige structuur kunnnen hebben?
	\item Zet deze informatie om naar het EDI formaat door gebruik te maken van vertaler die de interne informatie kan omzetten naar het EDI formaat.
	\item Verstuur deze informatie naar de bestemmeling. Een zender en ontvanger zijn direct aangesloten met elkaar via software.
\end{enumerate}

\subsection{RPC}
RPC is het aanroepen van een procedure (functie, methode, ...) op een ander toestel dan waarop een programma fysiek uitgevoerd wordt. Dit proces bevat volgende stappen:
\begin{enumerate}
	\item De client maakt een RPC aan en verstuurt deze naar een server die deze call can behandelen.
	\item De server verwerkt de procedure en stuurt het resultaat terug naar de client.
	\item De client kan gebruik maken van dit resultaat op lokaal niveau.
\end{enumerate}
\section{Gedistribueerde objectsystemen}
Gedistribueerde systemen maken gebruik van EDI en RPC om een systeem te implementeren. Er worden enkele besproken zoals \textbf{RMI (Remote Method Invocation)}, \textbf{DCOM (Distributed Component Object Model)} en \textbf{CORBA (Common Object Request Broker Architecture)}
\subsection{RMI}
Deze technologie is ontwikkelt door Oracle en bestaat typisch uit een \textbf{Server} en \textbf{Client} applicatie. Een server zal methoden beschikbaar stellen en zal wachten tot dat een client deze methode uitvoert (invocation). RMI is het mechanisme dat de verbinding en informatieuitwisseling tussen een client en een server behandelt. Een gedistribueerd systeem gebasseerd op RMI kan de volgende 3 zaken uitvoeren.
\begin{enumerate}
	\item \textit{Lokalisatie van remote objecten.} Remote objecten moeten opgeslagen worden in een zogenaamde \textbf{RMI registery}.
	\item \textit{Communicatie met remote objecten.} Het aanroepen van methoden van een remote object wordt volledig door RMI behandelt. Dit heeft als gevolg dat een programmeur niet eens moet weten dat hij met een remote object bezig is.
	\item \textit{Klassedefinities laden van remote objecten.} Aangezien dat RMI objecten kan terugsturen/versturen, voorziet RMI de mogelijkheid om klassedefinities van deze objecten op te halen.
\end{enumerate}
\subsection{DCOM}
DCOM is een uitbreiding op COM om communicatie tussen verschillende toestellen, hetzij op een LAN, hetzij op een WAN of zelfs op het internet aan te spreken. DCOM behandelt het low-level gedeelte van de netwerkcommunicatie, zodat een programmeur hier zich niet meer mee bezig hoeft te houden.  
\subsection{CORBA}
CORBA is zoals de anderen, ook een manier om communicatie te hebben tussen verschillende systemen. CORBA baseert zich op 4 punten:
\begin{enumerate}
	\item Applicatieobjecten die specifiek zijn voor de applicatie. Een CORBA object is een encapsulatie van zulke objecten.
	\item Een \textbf{ORB (Object Request Broker)} dat de requests van verschillende services behandelt. 
	\item Een verzameling van services die waarschijnlijk gebruikt zullen worden door veel applicaties. 
	\item Een verzameling van componenten die bovenop deze services gebouwd zijn.
\end{enumerate} 


\section{MOM}
\textbf{MOM (Message Oriented Middleware)} is een software systeem dat instaat voor het aanmaken, versturen, ontvangen en lezen van berichten op zowel synchrone of aysnchrone manier. Een client applicatie moet dus enkel deze middleware aanspreken om berichten op te halen of te versturen.

\section{SOA}
\textbf{SOA (Service Oriented Architecture)} is een architectuurstijl dat gebruik maakt van services die onafhankelijk zijn van andere services. Een service kan individueel aangepast worden zonder dat andere services hiervan last hebben. Deze architectuurstijl kent een aantal uitdagingen:
\begin{itemize}
	\item Gelijktijdige toegang tot bronnen
	\item Wat indien een deel van de opdracht mislukt?
	\item Wat als één partner incompatibel wordt?
	\item Geen gedeeld geheugen voor requester en provider
	\item Traagheid en onbetrouwbaarheid gebruike transport
\end{itemize}
Er blijkt ook een gelijkheid te zijn met SOA en microservices. Het verschil tussen microservices en SOA is 
\todo{saai}

\section{Webservices in Java}
De java klasse die een SOAP aanvraag moet verwerken wordt geannoteerd met 
$$\texttt{@WebService(serviceName = "...")}$$
Deze klasse bevat een aantal methoden, die geannoteerd worden met 
$$\texttt{@WebMethod(operationName = "...")}$$
De waarde van \texttt{operationName} in de SOAP aanvraag moet overeenkomen met één van de methoden in de webservice.
Elke methode kan eventuele parameters hebben, geannoteerd met
$$\texttt{@WebParam(name = "...")}$$
Een eenvoudige webservice dat een boek geeft op basis van een ISBN, ziet er als volgt uit:
\begin{lstlisting}[language=java]
@WebService(serviceName = "Catalogus")
public class Catalogus {
  @WebMethod(operationName = "geefBoek")
  public Boek geefBoek(@WebParam(name = "isbn") String isbn){
    try {
      BoekenLijst boeken = new BoekenLijstImpl();
      return boeken.geefBoek(isbn);
    } catch(Exception e) {
      return null;
    }
  }
}
\end{lstlisting}

De bijhorende SOAP aanvraag wordt:
\begin{lstlisting}[language=xml]
<?xml version="1.0" encouding="UTF-8"?>
<S:Envelope 
  xmlns:S="http://schemas.xmlsoap.org/soap/envelope/">
  <S:Header/>
  <S:Body>
    <ns2:geefBoek xmlns:ns2="http://web.boeken.iii.be/">
      <isbn>isbn2</isbn>
    </ns2:geefBoek>
  </S:Body>
</S:Envelope>
\end{lstlisting}


Het antwoord dat we terugkrijgen is dan (bijvoorbeeld):
\begin{lstlisting}[language=xml]
<?xml version="1.0" encouding="UTF-8"?>
<S:Envelope 
  xmlns:S="http://schemas.xmlsoap.org/soap/envelope/">
  <S:Header/>
  <S:Body>
    <ns2:geefBoekResponse xmlns:ns2="http://web.boeken.iii.be/">
      <return>
        <isbn>isbn2</isbn>
        <prijs>36.0</prijs>
        <titel>Java Servlet Programming</titel>
      </return>
	</ns2:geefBoekResponse>
  </S:Body>
</S:Envelope>
\end{lstlisting}


	
\section{Webservices in C\#}
Webservics in C\# kunnen geïmplementeerd worden met \textbf{Windows Communication Foundation (WCF)}. WCF is een .NET framework om servicegeoriënteerde applicaties te ontwikkelen. De communicatie verloopt tussen endpoints via berichten. Een service bestaat uit meerdere endpoints. De \underline{architectuur} wordt eerst weergegeven op figuur \ref{fig:wcf_architecture} en bestaat uit \underline{vier lagen}.
\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{wcf_architecture}
	\caption{Architectuur WCF.}
	\label{fig:wcf_architecture}
\end{figure}
\begin{itemize}
	\item[\info] \textbf{Contracts:} Deze laag specificeert onder andere welke parameters er verwacht worden, de structuur van het bericht, de beschikbare interfaces/methodes en hoe er gecommuniceerd moet worden.
	\item[\info] \textbf{Service runtime:} Deze laag specificeert het gedrag van de applicatie zoals het aantal berichten dat verwerkt kan worden, wat er moet gebeuren als er iets fout loopt, welke metadata er beschikbaar moet zijn voor de buitenwereld en hoeveel instanties er van deze service mogen zijn.
	\item[\info] \textbf{Messaging:} Deze laag is opgebouwd uit kanalenn, ook wel de \emph{channel stack} genoemd. Een kanaal verwerkt berichten en komen in twee vormen voor:
	\begin{itemize}
		\item Transport kanaal: Verantwoordelijk voor het lezen en schrijven van berichten van en naar het netwerk.
		\item Protocol kanaal: Implementeert message processing protocols door bijkomende headers te lezen en schrijven.
	\end{itemize}
	\item[\info] \textbf{Activation and hosting:} Een service kan enerzijds als een executable (self-hosted service) uitgevoerd worden en anderzijds gehost worden in een externe omgeving als webserver of Windows service.
\end{itemize}

\subsection{Ontwerp servicecontract}
Het \underline{ontwerp van het servicecontract} is de eerste stap. Een methode krijgt het \texttt{[OperationContract]} attribuut (equivalent met annotaties in Java). Een methode die dit attribuut heeft, zal nooit referenties teruggeven, maar kopieën van de objecten. Het is ook mogelijk om eigen datatypes te definieren met het \texttt{[DataContract]} en \texttt{[DataMember]} attribuut. De werkelijke interface krijgt het \texttt{[ServiceContract]} attribuut. Een voorbeeld:
\begin{lstlisting}[style=csharp]
[ServiceContract(Namespace = "...")]
public interface ICalculator {
	[OperationContract]
	double Add(double x, double y);
	[OperationContract]
	double Subtract(double x, double y);
	[OperationContract]
	double Multiply(double x, double y);
	[OperationContract]
	double Divide(double x, double y);
}
\end{lstlisting}
De normale communicatie methode, waarbij de cliënt een vraag stelt waarop de server antwoord, is mogelijk. Ook is er een one-way contract, waarbij de cliënt geen antwoord verwacht van de server, en een duplex contract, waarbij de server zal ook informatie kan ophalen van clients. Een one-way contract is eenvoudig te definieren door de eigenschap \texttt{IsOneWay} van het attribuut \texttt{[OperationContract]} op \texttt{True} te zetten. 
\begin{lstlisting}[style=csharp]
[OperationContract(IsOneWay = true)]
void Hello(string greeting);
\end{lstlisting}


Een duplex contract moet gedefinieerd worden in het \texttt{[ServiceContract]} attribuut in de server. In de client moet er ook een callback voorzien worden.
\begin{lstlisting}[style=csharp]
	// SERVER
[ServiceContract
	(
	Namespace = "...", 
	SessionMode = SessionMode.Required,
	CallbackContract = typeof(ICalculatorDuplexCallback)
	)
]
public interface ICalculatorDuplex {
	[OperationContract(IsOneWay = true)]
	void Clear();
	[OperationContract(IsOneWay = true)]
	void AddTo(double n);
	[OperationContract(IsOneWay = true)]
	void SubtractFrom(double n);
	[OperationContract(IsOneWay = true)]
	void MultiplyBy(double n);
	[OperationContract(IsOneWay = true)]
	void DivideBy(double n);
}
\end{lstlisting}
\begin{lstlisting}[style=csharp]
	// CLIENT
public interface ICalculatorDuplexCallback {
	[OperationContract(IsOneWay = true)]
	void Result(double result);
	[OperationContract(IsOneWay = true)]
	void Equation(string eqn);
}
\end{lstlisting}
\subsection{Implementatie contract}
Als voorbeeld van de implementatie nemen we de standaardcommunicatiemethode. Na de vorige stap hebben we een interface ontworpen die er als volgt uit ziet:
\begin{lstlisting}[style=csharp]
[ServiceContract]
public interface IMath {
	[OperationContract]
	double Add(double x, double y);
	[OperationContract]
	double Multiply(double x, double y);
}
\end{lstlisting}
De implementatie van deze interface is vrij eenvoudig:
\begin{lstlisting}[style=csharp]
public class MathService : IMath {
	public double Add(double x, double y) {
		return x + y;
	}
	public double Multiply(double x, double y){
		return x * y;
	}
}
\end{lstlisting}

\subsection{Configuratie}
De configuratie specificeert per endpoint welke service (interface en implementatie) gebruikt moet worden, waar (URL) deze zich bevindt en hoe (binding) er moet gecommuniceerd worden. Een \underline{endpoint specificeren kan op twee manieren:}
\begin{itemize}
	\item[\info] \textbf{In code:}
	\begin{lstlisting}[style=csharp]
Uri base = new Uri("http://localhost:8080/Service");
ServiceHost host = new ServiceHost(typeof(MathService), base);
try {
	selfHost.AddServiceEndPoint(
		typeof(IMath),
		new WSHttpBinding(),
		"MathService");
	// gedrag instellen, service runnen
} catch (CommunicationException ce){
	Console.WriteLine(ce.Message);
	host.Abort();	
}
	\end{lstlisting}
	\item[\info] \textbf{In configuration:}
	\begin{lstlisting}[language=xml]
<system.ServiceModel>
  <services>
    <service name ="x.y.z.MathService">
      <endpoint address="http://localhost:8080/Service"
                binding="basicHttpBinding"
                bindingConfiguration="customConfiguration"
                contract = "x.y.z.IMath"/>
    </service>
  </services>
  <bindings>
    <basicHttpBinding>
      <binding name="customConfiguration"
               closeTimeout="00:01:00"/>
    </basicHttpBinding>
  </bindings>
  <behaviors>
    <serviceBehaviours>
      <behaviour>
        <serviceMetadata httpGetEnabled="True"/>
      </behaviour>
    </serviceBehaviours>
  </behaviors>
</system.ServiceModel>
	\end{lstlisting}
Er zijn een aantal bindings voorzien zoals \texttt{BasicHttpBinding}, \texttt{WSHttpBinding}, \texttt{NetTcpBinding} en \texttt{NetNamedPipeBinding}.
\end{itemize}
\subsection{Hosting}
Je kan ofwel de serivce publiceren \todo{holy shit dit is retarded}

\chapter{API Gateways}
Het publiceren van meerdere services blijft een uitdagen. Services kunnen onderling verschillende protocollen gebruiken en meerdere clients moeten de service kunnen aanspreken. Een webapplicatie kan bijvoorbeeld meer data krijgen dan een mobiele applicatie, omdat er meer plaats is om deze informatie te tonen. Een API ontwerpen die voor alle type clients zou werken is niet zinvol, en praktisch onrealiseerbaar. Men zou elke client de service rechtstreeks kunnen laten aanspreken. Dit komt erop neer dat de client de rol van \underline{API composer} krijgt. Dit heeft drie nadelen:
\begin{itemize}
	\item[\alert] \textbf{Slechte gebruikerservaring:}  De client moet complexe code bevatten om de resultaten van de APIs te combineren. Meerdere calls naar verschillende services vertraagd de aanvraag enorm.
	\item[\alert] \textbf{Backend is niet afgeschermd:} Een wijziging in de backend vereist een wijziging in de frontend. Het uitrollen van een nieuwe versie van de service en de daarbijhorende client applicatie, wordt belemmerd. Niet iedereen gebruikt namelijk de nieuwste versie van elk product. Externe partners hebben ook nood aan een stabiele API. 
	\item[\alert] \textbf{Services kunnen IPC-mechanismen gebruiken:} Het aanroepen van diverse protocollen wordt niet altijd ondersteund in de client.
\end{itemize}
De oplossing is de API gateway, dat gebaseerd is op het facade patroon zodat de interne structuur afgeschermd wordt. De API gateway is het toegangspunt van de applicatie en is verantwoordelijk voor:
\begin{itemize}
	\item[\info] Request routing.
	\item[\info] API-compositie, aggregatie/samenvoegen resultaten.
	\item[\info] Vertaling naar protocollen geschikt voor de client.
	\item[\info] Randfunctionaliteiten: authenticatie, autorisatie, caching, logging, ...
\end{itemize}
De client stuurt slechts één enkele request naar de API gateway, waarop de API gateway één enkel resultaat terugstuurt. De API gateway zal intern één of meerdere services aanspreken. De API gateway voorziet voor elke client een API.

\chapter{Netwerkprogrammatie in Java}
Belangrijke netwerkklassen in java, in de package \underline{\texttt{java.net}}:
\begin{itemize}
    \item \textbf{TCP} 
        \begin{itemize}
            \item URL
            \item URLConnection
            \item Socket
            \item ServerSocket
        \end{itemize}
    \item \textbf{UDP}
        \begin{itemize}
            \item DatagramPacket
            \item DatagramSocket
            \item MulticastSocket
        \end{itemize}
\end{itemize}
\section{Sockets}
De cliënt maakt een \texttt{Socket} object aan. De constructor heeft de locatie van een bepaalde server, en een poortnummer, die de server heeft opengezet (cfr. \ref{code:socket}).
\begin{equation}
	\texttt{Socket socket = new Socket("localhost", 8901);}
	\label{code:socket}
\end{equation}

 Communicatie met de socket gebeurt met de \texttt{PrintWriter} klasse, die naar de server zal sturen, en de \texttt{BufferedReader} klasse, die berichten van de server zal ontvangen. Code \ref{code:socket_communication} toont hoe deze objecten geïnitialiseerd kunnen worden.
 \begin{equation}
	\begin{split}
		\texttt{PrintWriter out} & \texttt{ = new PrintWriter(socket.getOutputStream(), true);} \\
		\texttt{BufferedReader in} & \texttt{ = new BufferedReader(new InputStreamReader(socket.getInputStream()));}
	\end{split}
	\label{code:socket_communication}
 \end{equation}

 
 Gebruik best de try-met-resources om instanties van deze objecten te maken, zodat ze automatisch verdwijnen indien de code uit het \texttt{try} block komt. Na de initialisatie kan er met de server gecommuniceerd worden door weg te schrijven via de \texttt{PrintWriter}. Wachten op een bericht van de server kan door de \texttt{readLine()} methode van de \texttt{BufferedReader}klasse op te roepen. Dit is een synchrone methode dus de applicatie zal blokkeren. 

De server zal gebruik maken van een \texttt{ServerSocket} klasse. Deze werkt op identiek dezelfde manier als de \texttt{Socket} klasse die de cliënt gebruik, behalve dat een instantie van de \texttt{ServerSocket} klasse meerdere sockets kan accepteren. De constructor van deze socket heeft als enige argument de poort die opengesteld moet worden (cfr \ref{code:serversocket}).
\begin{equation}
	\texttt{ServerSocket socket = new ServerSocket(8901);}
	\label{code:serversocket}
\end{equation}

Tot slot is er nog een \underline{protocol} nodig, die de communicatie tussen de server en communicatie beschrijft. Een eenvoudig protocol vereist bijvoorbeeld dat een bericht start met een bepaald sleutelwoord. 

\begin{lstlisting}
// CLIENT
String hostName = "localhost";
int portNumber = 4444;
try(
    Socket socket = new Socket(hostName, portNumber);
    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
    BufferedReader in = new BufferedReader(
        new InputStreamReader(socket.getInputStream())
    );
){
    String input = ... // input ophalen van gebruiker
    while(!input.equals("exit")){
        out.println(input); // naar server
        System.out.println("echo: ) + in.readLine()); // van server
        input = ... // input ophalen van gebruiker
    }
} catch (IOException ex) {
    System.err.println(ex.getMessage());
}

// SERVER
try {
    ServerSocket socket = new ServerSocket(4444);
    while(true) {
        try(
            PrintWriter out = new PrintWriter(
                socket.getOutputStream(), true
            );
            BufferedReader in = new BuffereadReader(
                new InputStream(socket.getInputStream())
            );
        ){
            String input, output;
            while((input = in.readLine()) != null){
                output = protocol.processInput(input);
                out.println(output);
                if(output.equals("Bye")){
                    break;
                }
            }
        }
    }
}
\end{lstlisting}

\section{Multithreading}
\subsection{Threads}
Een socket wordt best geïmplementeerd met behulp van threads, zodat verschillende cliënts op hetzelfde moment behandeld kunnen worden. Er zijn een aantal opties om multithreading te implementeren.
\begin{itemize}
	\item[\info] \textbf{De interface \texttt{Runnable} implementeren.} Dit vereist dat de methode \texttt{run()} geïmplementeerd wordt. Het object moet dan verpakt worden in een \texttt{Thread}, zodat het kan uitgevoerd worden (cfr. \ref{code:implement_runnable_start}) met de \texttt{start()} methode van de klasse \texttt{Thread}.
	\begin{lstlisting}[language=java]
public class HelloRunnable implements Runnable {
	@Override
	public void run() {
		System.out.println("Hello from a thread!");
	}
}
	\end{lstlisting}
	\begin{equation}
		\texttt{(new Thread(new HelloRunnable())).start();}
		\label{code:implement_runnable_start}
	\end{equation}
	\item[\info] \textbf{Overerven van de klasse \texttt{Thread}.} Om nu eigen functionaliteit aan te bieden, kan de methode \texttt{run()} overschreven worden. De thread kan nu direct gestart worden met de \texttt{start()} methode (cfr. \ref{code:extends_thread_start}).
	\begin{lstlisting}[language=java]
public class HelloThread extends Thread {
	@Override
	public void run() {
		System.out.println("Hello from a thread!");
	}
}
	\end{lstlisting}
	\begin{equation}
		\texttt{(new HelloThread()).start();}
		\label{code:extends_thread_start}
	\end{equation}
	\item[\info] \textbf{Inline definitie.} Deze laatste methode zal een anonieme \texttt{Runnable} instantie aanmaken, die dan op exact dezelfde manier kan gestart worden zoals (cfr. \ref{code:implement_runnable_start}).
	\begin{lstlisting}[language=java]
public static void main(String args[]){
	Runnable task = () -> {
		System.out.println("Hello from a thread!");
	};
	new Thread(task).start(); // cfr. 5.4
}
	\end{lstlisting}
\end{itemize}

\subsection{Executors}
Een \underline{Executor} is verantwoordelijk voor het beheren en aanmaken van threads. De statische factoryklasse \texttt{Executors} laat toe om verschillende typen executors te initialiseren. De eerste twee voorbeelden geven een \texttt{ExecutorService} object terug, het laatste een \texttt{ScheduledExecutorService} object:
\begin{itemize}
	\item[\info] \textbf{\texttt{Executors.newSingleThreadExecutor();}} Maakt gebruik van slechts één enkele thread. Indien de thread afsterft wordt er een nieuwe aangemaakt die zijn taken overneemt. 
	\item[\info] \textbf{\texttt{Executors.newFixedThreadPool(10);}} Maakt een thread pool dat een vast aantal threads \emph{her}gebruikt. De parameter is het aantal threads dat in de thread pool zullen zitten.
	\item[\info] \textbf{\texttt{Executors.newScheduledThreadPool(10);}} Maakt een thread pool waarmee threads na een bepaalde delay worden uitgevoerd.
\end{itemize}

De \texttt{ExecutorService} kan op meerdere manieren threads starten:
\begin{itemize}
	\item[\info] \textbf{\texttt{void execute(Runnable r);}} 
	
	Zal een \texttt{Runnable} object uitvoeren en verwacht geen returnwaarde.

	\item[\info] \textbf{\texttt{Future<?> submit(Runnable r);}} 

	Analoog met de \texttt{execute()}-methode, enkel is het returntype nu een \texttt{Future} object die de taak voorstelt. Een \texttt{Future} object is een object speciaal ontworpen voor asynchrone operaties. Het object bevat een aantal methodes zoals \texttt{isDone()}, om na te gaan of dat de taak voltooid is en \texttt{get()}, om de waarde op te halen.

	\item[\info] \textbf{\texttt{<T> Future<?> submit(Callable c);}} 
	
	Deze methode verwacht kan ook een instantie van type \texttt{Callable} krijgen. De functionaliteit is compleet analoog met \texttt{Runnable}, enkel kan een instantie van \texttt{Callable} een returnwaarde geven. Deze versie geeft een \texttt{Future} object met de returnwaarde van de overschreven methode \texttt{call()} van het \texttt{Callable} object. 

	\item[\info] \textbf{\texttt{<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks);}}

	Een lijst van \texttt{Callable} objecten uitvoeren. Het returntype is een lijst van \texttt{Future} objecten, die voor elke thread het returnresultaat bijhouden.
	\item[\info] \textbf{\texttt{<T> T invokeAny(Collection<? extends Callable<T>> tasks);}}

	Zal ook een lijst van \texttt{Callable} objecten uitvoeren, maar enkel het resultaat van de thread die het eerst klaar is wordt teruggegeven. 
\end{itemize}


\chapter{Java NIO}
Java NIO (New IO) biedt een alternatieve manier om met IO te werken.
\begin{itemize}
    \item \textbf{Channels en Buffers.} Data wordt altijd gelezen van een bepaald kanaal naar een buffer, of geschreven van een buffer naar een kanaal.
    \item \textbf{Non-blocking IO.} Een thread kan aan een kanaal vragen om data van een buffer in te lezen. Terwijl het kanaal dit doet, kan de thread andere zaken uitvoeren en wachten tot het kanaal klaar is.
    \item \textbf{Selectors.} Een selector is een object that meerdere kanalen kan monitoren. Het reageert op events (connectie opened, data arrived, ...). Een enkele thread kan meedere kanalen monitoren met behulp van selectors. Een selector registreren gebeurt door een kanaal mee te geven, en de \texttt{select()} methode op te roepen van de \texttt{Selector} klasse.
\end{itemize}
De kern van Java NIO zijn de klassen \texttt{Channel}, \texttt{Buffer} en \texttt{Selector}. Andere klassen zoals \texttt{Pipe} en \texttt{FileLock} dienen gebruikt te worden in samenwerking met de drie kernklassen. Elke klasse kent meerdere implementaties. Zo kent de \texttt{Channel} klasse bijvoorbeeld: 
$$\texttt{FileChannel}, \texttt{DatagramChannel}, \texttt{SocketChannel}\;\hbox{en}\;\texttt{ServerSocketChannel}$$ 
De klasse \texttt{Buffer} kent meerdere implementies afhankelijk van het datatype: 
$$\texttt{ByteBuffer}, \texttt{CharBuffer}, \texttt{DoubleBuffer}, \texttt{FloatBuffer}, \texttt{IntBuffer}, \texttt{LongBuffer}, \texttt{ShortBuffer}$$ 
De verschillen tussen de \texttt{Channel} en \texttt{Stream} klasse zijn:
\begin{itemize}
    \item Lezen en schrijven is mogelijk met één kanaal. Een stream is ofwel leesmode of schrijfmode.
    \item De lees en schrijfoperatie kan asynchroon gebeuren met kanalen.
    \item Een kanaal kan lezen van, of schrijven naar een buffer
\end{itemize}
Het gebruik van een eenvoudig \texttt{Channel} object:
\begin{lstlisting}[language=java]
RandomAccessFile file = new RandomAccessFile("data/file.txt", "rw");
FileChannel inChannel = file.getChannel();
ByteBuffer buffer = ByteBuffer.allocate(48);
int bytesRead = inChannel.read(buf);
while(bytesRead != -1){
    System.out.println("Read " + bytesRead);
    buf.flip();
    while(buf.hasRemaining()){
        System.out.print((char) buf.get());
    }
    buf.clear();
    bytesRead = inChannel.read(buf):
}
file.close();
\end{lstlisting}
\section{Buffers}
Om een buffer te verkrijgen, moet er altijd geheugen gereserveerd worden met de \texttt{allocate(int n)} methode. De waarde $n$ is het aantal bytes. De \texttt{read(Buffer buffer)} methode van een \texttt{Channel} object zal naar de buffer schrijven. Het returntype van deze methode is het aantal bytes dat geschreven wordt, of -1 indien er niets geshreven wordt. De \texttt{flip()} methode van een \texttt{Buffer} object zal de buffermodus van schrijven naar lezen omzetten, of omgekeerd. Een buffer in leesmode laat toe om de methode \texttt{get()} van de buffer te gebruiken, of de \texttt{write()}-methode van een \texttt{Channel} object. De naamgeving van de methoden is hier verwarrend: 
\begin{itemize}
	\item \texttt{FileChannel.read(Buffer buffer)}: Zal data VAN het kanaal NAAR de buffer schrijven. Dit vereist dat de buffer in schrijfmode staat.
	\item \texttt{FileChannel.write(Buffer buffer)}: Zal data NAAR het kanaal VAN de buffer schrijven. Dit vereist dat de buffer in leesmode staat.
\end{itemize}

Na het uitlezen van de buffer moet deze opnieuw ingesteld worden met de \texttt{clear()}-methode, zodat de buffer klaar staat om opnieuw naar geschreven te worden.

Het is ook mogelijk om handmatig data in de buffer te plaatsen, zonder behulp van een \texttt{Channel}. De \texttt{put()}-methode (en al de varianten zoals \texttt{putInt}, ...) laat toe om rechtstreeks bytes te schrijven naar de buffer. 

\underline{Terminologie:}
\begin{itemize}
	\item[\info] \textbf{Capaciteit:} Een buffer is in werkelijkheid een blok van geheugen en heeft daarom een vaste grootte, hier capaciteit genoemd. Eens de buffer vol is, kan er niet meer naar geschreven worden en moet dan ofwel gelezen worden, ofwel gereset worden.
	\item[\info] \textbf{Positie:} De positie hangt af van de buffermode:
	\begin{itemize}
		\item Schrijfmode: Data schrijven naar een buffer gebeurd op een bepaalde positie. De positie wordt bij elke toevoeging (byte, int, long, ...) verplaatst naar de volgende schrijfbare geheugenlocatie van de buffer. De positie kan maximaal 1 minder dan de capaciteit worden.
		\item Leesmode: Na het schrijven wordt de \texttt{flip()}-methode opgeroepen, die de positie terug op 0 zal zetten. Bij elke leesoperatie zal de positie zich verplaatsen naar de volgende leesbare geheugenlocatie.
	\end{itemize}
	\item[\info] \textbf{Limiet:} Ook hier wordt er een onderscheidt gemaakt afhankelijk van de buffermode:
	\begin{itemize}
		\item Schrijfmode: De limiet is gelijk aan de capaciteit.
		\item Leesmode: Vooraleer de methode \texttt{flip()} opgeroepen wordt, heeft de capaciteit een bepaalde waarde. Na de \texttt{flip()}-methode zal de limiet gelijk zijn aan deze capaciteit. Het komt erop neer dat er maar zoveel bytes mogen gelezen worden als er geschreven zijn.
	\end{itemize}
\end{itemize}

Bij berichten die een header en een body hebben met \underline{vaste grootte}, kan het handig zijn om scattering reads te gebruiken. Een kanaal kan schrijven naar een array van buffers. Deze variant zal de buffers in sequentie overlopen. Wanneer een buffer vol is, zal het de volgende buffer gebruiken. 
\begin{lstlisting}[language=java]
ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body   = ByteBuffer.allocate(1024);

ByteBuffer[] bufferArray = { header, body };
channel.read(bufferArray);
\end{lstlisting}

Op analoge manier kan ook de data van meerdere buffers rechstreeks in één kanaal geschreven worden. Deze manier werkt wel voor \underline{dynamische grootten}, aangezien er maar zoveel bytes geschreven zal worden als de positie aangeeft van elke buffer.
\begin{lstlisting}[language=java]
ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body   = ByteBuffer.allocate(1024);
	
// data naar buffer schrijven

ByteBuffer[] bufferArray = { header, body };
channel.write(bufferArray);
\end{lstlisting}

\section{Channels}
Het is mogelijk om rechtstreeks \texttt{FileChannel} objecten te verplaatsen met de \texttt{transferTo()} en \texttt{transferFrom()} methoden.
\begin{lstlisting}[language=java]
RandomAccessFile fromFile = new RandomAccessFile("fromFile.txt", "rw");
FileChannel fromChannel = fromFile.getChannel();

RandomAccessFile toFile = new RandomAccessFile("toFile.txt", "rw");
FileChannel toChannel = toFile.getChannel();


toChannel.transferFrom(fromChannel, 0, fromChannel.size());
// of
fromChannel.transferTo(0, fromChannel.size(), toChannel);
\end{lstlisting}

Op die manier kan men voorkomen dat men constant bestanden moet kopiëren.

\section{Selectors}
Een selector kan meerdere kanalen monitoren, en nagaan of ze klaar zijn om naar geschreven of van gelezen te worden. Een selector kan aangemaakt worden met de \texttt{open()} methode van de statische klasse \texttt{Selector} (cfr. \ref{code:create_selector}).
\begin{equation}
	\texttt{Selector selector = Selector.open();}
	\label{code:create_selector}
\end{equation}
Vooraleer een kanaal kan geregistreerd worden moet deze in non-blocking mode staan (cfr. \ref{code:channel_nonblocking}).
\begin{equation}
	\texttt{channel.configureBlocking(false);}
	\label{code:channel_nonblocking}
\end{equation}
Uiteindelijk kan het kanaal regegistreerd worden aan de selector (cfr. \ref{code:channel_register_selector}). Bij de registratie moeten de operaties gespecificeerd worden die van belang zijn:
\begin{itemize}
	\item Connect
	\item Accept
	\item Read
	\item Write
\end{itemize}
\begin{equation}
	\texttt{SelectionKey key = channel.register(selector, SelectionKey.OP\_READ);}
	\label{code:channel_register_selector}
\end{equation}
Een kanaal dat één van de vier events afvuurt is 'ready' voor dat event. Een kanaal meerdere events registreren, door de constanten met de OR operatie mee te geven.
Een selector kan opvragen welke kanalen er 'ready' zijn voor de gespecificeerde events Het is eerst interessant om het \underline{aantal kanalen} op te vragen, met één van de \texttt{select()}-methoden  (cfr. \ref{code:selector_select}).
\begin{equation}
	\begin{split}
		\texttt{int readyChannels} & \texttt{ = selector.select();} \\
		\texttt{int readyChannels} & \texttt{ = selector.select(1000);} \\
		\texttt{int readyChannels} & \texttt{ = selector.selectNow();} \\
	\end{split}
	\label{code:selector_select}
\end{equation}
De eerste variant is een blocking methode die oneindig lang zal wachten, tot er minstens één kanaal klaar is. De tweede variant zal slechts 1 seconde (1000 milliseconden) blocken. De laatste variant blokkeert niet en zal direct het aantal kanalen teruggeven. De \texttt{select()}-methoden geven niet altijd het aantal kanalen dat effectief 'ready' is, maar enkel de kanalen die 'ready' geworden zijn tussen twee \texttt{select()} calls.

De beschikbare kanalen kunnen wel overlopen worden via de set gegeven door de \texttt{selectedKeys()}-methode. Na het overlopen van de kanalen moet de set leeggemaakt worden aangezien de selector dat niet zelf doet (cfr. \ref{code:clear_selectedkeys})
\begin{equation}
	\texttt{selector.selectedKeys().clear();}
	\label{code:clear_selectedkeys}
\end{equation}

Voorbeeld eenvoudig gebruik van een selector:
\begin{lstlisting}[language=java]
while(true){
	int readyChannels = selector.select(10000);
	if(readyChannels == 0){ 
		continue; 
	}

	for(SelectionKey key : selector.selectedKeys()){
		if(key.isAcceptable()){

		} else if (key.isConnectable()){

		} else if (key.isReadable()){

		} else if (key.isWriteable()){

		}
	}
	selector.selectedKeys().clear();
}
\end{lstlisting}

Voorbeeld: \texttt{SocketChannel}
\begin{lstlisting}[language = java]
// aanmaken
SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(
	new InetSocketAddress("localhost", 9999)
);

// lezen
ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = socketChannel.read(buf);

// schrijven
String newData = "New String to write to file...";
buf.clear();
buf.put(newData.getBytes());
buf.flip();
while(buf.hasRemaining()){
	socketChannel.write(buf);
}

// afsluiten
socketChannel.close();
\end{lstlisting}

Voorbeeld: \texttt{ServerSocketChannel}
\begin{lstlisting}[language = java]
ServerSocketChannel serverSocketChannel 
	= SocketServerSocketChannelChannel.open();
serverSocketChannel.socket().bind(
	new InetSocketAddress(9999)
);

while(true){
	SocketChannel socketChannel = serverSocketChannel.accept();
	// ...
}

serverSocketChannel.close();
\end{lstlisting}

\section{Java IO vs Java NIO}
\subsection{Streams vs Buffers}
NIO is buffergeoriënteerd terwijl IO streamgeoriënteerd is. Een stream laat enkel toe om sequentieel te lezen, en kan niet meer teruggegaan worden, tenzij dit opgeslagen wordt in een buffer. Het voordeel van een buffer is dus dat het niet sequentieel afgelopen moet worden. 
\subsection{Blocking vs Non-blocking IO}
De traditionele IO zijn blocking. Een thread moet wachten vooraleer de blocking methoden klaar zijn. De non-blocking manier van buffers laat toe om enkel de huidige beschikbare data van een buffer op te halen, en zal niet blokkeren in het geval dat er nog data verwacht wordt. Dit heeft natuurlijk als gevolg dat een thread meerdere kanalen kan beheren.
\subsection{Selectors}
Dit is het direct gevolg van de asynchroniteit van buffers/kanalen. Een selector is de implementatie die toelaat om meerdere kanalen te monitoren met slechts één thread.
\subsection{Verwerken van data}
Stel dat we volgende inhoud willen lezen:
\begin{lstlisting}
Name: Anna
Age: 25
Email: anna@mailserver.com
Phone: 1234567890
\end{lstlisting}
Bij een streamgeoriënteerde methode moet elke lijn één voor één ingelezen worden. De opeenvolging van \texttt{readLine()} methoden verzekert dat de vorige \texttt{readLine()} aanroep met succes voltooid is.
\begin{lstlisting}[language=java]
InputStream input = ...;
BufferedReader reader = new BufferedReader(
	new InputStreamReader(input);
)
String name = reader.readLine();
String age = reader.readLine();
String email = reader.readLine();
String phone = reader.readLine();
\end{lstlisting}
Bij een buffergeoriënteerde methode is de verwerking wat complexer. Aan elke buffer moet een vooropgelegde aantal bytes toegekend worden die de buffer kan bevatten. Het probleem dat hierbij komt is dat het onmogelijk wordt om te weten wat er in de buffer zit, en je telkens de buffer moet inspecteren.
\begin{lstlisting}[language=java]
ByteBuffer buffer = ByteBuffer.allocate(48);
int bytesRead = inChannel.read(buffer);
\end{lstlisting}
Het kan zijn dat de buffer slechts 'Name: An' bevat.
\subsection{Overige topics}
\begin{itemize}
	\item[\info] \textbf{Change notifiers:} De \texttt{WatchService} klasse laat toe om eenvoudig wijzigingen in directory of bestand te monitoren. Dit is een verbetering dan het pollingsmechanisme dat gebruikt wordt door traditionele IO.
	\item[\info] \textbf{Selectors:} De I/O van NIO is eventgebaseerd. Een selector wordt pas wakker wanneer een bepaald event optreedt.
	\item[\info] \textbf{Channels:} Het gebruik van kanalen is niet altijd sneller. Een eenvoudig bestand inlezen kan twee tot drie maal performanter zijn met de traditionele IO operaties.
	\item[\info] \textbf{Memory Mapping:} NIO heeft een mechanisme dat ervoor zorgt dat een bestand eigenlijk gezien wordt als een blok geheugen, met als gevolg dat I/O nu even snel is als traditioneel geheugen uitlezen, in plaats van schijfoperaties. Het maakt het ook mogelijk om meerdere readers en writers op ditzelfde geheugen te laten werken. 
	\item[\info] \textbf{Character encoding en zoeken:} De laatste feature van NIO zijn character encodings via de klasse \texttt{Charset}. Het laat eenvoudig conversie tussen charsets toe. Het is meer flexibel dan de traditionele \texttt{getBytes()}-methode, en is zeer bruikbaar bij het zoeken in teksten die niet in het Engels geschreven zijn (met rare tekens). 
\end{itemize}

\chapter{Java Message Service}
\textbf{Java Message Service (JMS)} is een asynchrone, betrouwbare berichtenservice. Verschillende componenten kunnen berichten sturen en ontvangen. Er zijn twee soorten berichtstijlen:
\begin{itemize}
	\item[\info] \textbf{Queue:} Niet te verwarren met een effectieve queue datastructuur. Een \underline{messaging queue} laat slechts één enkele subscriber toe en één enkele producent. Het is een point-to-point verbindingen waarbij de enige producer berichten op de queue zet, en de consumer (de enige mogelijke subscriber) deze berichten zoals een queue leest, first in first out.
	\item[\info] \textbf{Topic:} Een topic laat toe om meerdere subscribers te hebben. Een publisher publiceert een bepaald bericht en elke subscriber (meerdere mogelijk) kan dit bericht lezen. Dit is in feite gewoon het publisher-subscriber model. Elke subscriber bevat nog altijd een wachtrij van nog te lezen berichten, maar is fundamentaal anders dan als de Messaging Queue.
\end{itemize}
Om een connectie te maken met een JMS provider wordt de klasse \texttt{ConnectionFactory} gebruikt. Deze klasse wordt niet zelf geïnitialiseerd, maar met behulp van annotaties (cfr. \ref{code:connectionfactory}).
\begin{equation}
	\begin{split}
		& \texttt{@Resource(lookup = "java:comp/DefaultJMSConnectionFactory")} \\
		& \texttt{private static ConnectionFactory connectionFactory;}
	\end{split}
	\label{code:connectionfactory}
\end{equation}
Hoe dat een \texttt{Queue} en \texttt{Topic} aangemaakt moeten worden, is gezien in de labo's. Een voorbeeld:
	$$\texttt{create-jms-resource --restype javax.jms.Queue customQueue}$$
De queue (of topic) wordt ook met een annotatie geïnitialiseerd (cfr. \ref{code:customQueue}).
\begin{equation}
	\begin{split}
		& \texttt{@Resource(lookup = "jms/customQueue")} \\
		& \texttt{private static Queue queue;}
	\end{split}
	\label{code:customQueue}
\end{equation}
Een producer kan een bericht op de queue zetten:
\begin{lstlisting}[language=java]
try (JMSContext context = connectionFactory.createContext();) {
	context.createProducer().send(queue, "een bericht");
} catch (JMSRuntimeException e) {
	//...
}
\end{lstlisting}
en een consumer kan dit bericht lezen:
\begin{lstlisting}[language=java]
try (JMSContext context = connectionFactory.createContext();) {
	context.createConsumer(queue);
	while(true){
		Message m = consumer.receive(1000); // om de seconde
		if(m != null && m instanceof TextMessage){
			System.out.println(m.getBody(String.class));
		}
	}
} catch (JMSRuntimeException e) {
	//...
}
	\end{lstlisting}
\end{document}