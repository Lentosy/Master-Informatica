\documentclass{report}
\usepackage{ugentstyle}

\begin{document}
	\maketitle{Systeemontwerp}
	\tableofcontents
	
	\part{Microservices}
	\chapter{Architectuur}
	\section{Gelaagde stijl}
	Een bekende architectuur is het drie-lagenmodel waarbij drie belangrijke lagen aanwezig zijn: de \textbf{persistentielaag}, die de logica zal bevatten waarmee met een databank kan gecommuniceerd worden om gegevens persistent te maken, de \textbf{businesslaag} die de regels gedefinieerd  door de use-cases bevat  en de \textbf{presentatielaag.} behandelt de logica om met client applicaties te communiceren. Het drielagenmodel kent een aantal \textbf{voordelen}.
	\begin{itemize}
		\item Het reflecteert de structuur van vele organisaties.
		\item Het is eenvoudig om mockups te gebruiken tijdens het testen van applicaties. Zo kan de hele databanklaag een mockup.
		\item Wordt ondersteund door vele frameworks zoals Microsoft .NET en Java EE.
	\end{itemize}
	Er bestaan echter ook \textbf{nadelen}:
	\begin{itemize}
		\item Er is slechts één enkele presentatielaag, maar er kunnen meerdere types zijn zoals een webapplicatie of een mobiele applicatie. 
		\item Er is ook maar één enkele persistentielaag. Bepaalde informatie geniet een voorkeur bij een ander soort databank (relationeel, grafen, document based, ...).
		\item Vaak wordt de dependency tussen de business en persistentielaag omgewisseld. De businesslaag zal repositoryinterfaces declareren die geïmplementeerd worden door de persistentielaag.
	\end{itemize}
	\section{Hexagonale stijl}
	Bij deze stijl bestaat er nog altijd de algemene businesslaag. Deze laag zal nu verschillende \textbf{interfaces} bevatten zoals een repositoryinterface of een betalinginterface. Deze interfaces kunnen door externe applicaties aangesproken worden. De implementatie van zo een interface is afhankelijk van de technologie dat gebruikt wordt. Deze technologiën worden via een \textbf{adapter} omgezet zodat ze gebruikt kunnen worden in de businesslaag.
	
	Het voordeel is dat componenten nu zwak gekoppeld zijn aan elkaar en daardoor gemakkelijker te testen zijn. Deze structuur wordt doorgaans meer gebruikt bij moderne applicaties.
	
	\section{Monolitische stijl}
	Deze stijl zet een project om tot een enkelvoudig uitvoerbare unit. Een Java EE project kan verpakt worden in een \textit{WAR} of \textit{JAR} bestand. De \textbf{voordelen} zijn:
	\begin{itemize}
		\item Eenvoudig om te ontwikkelen. \textit{IDE}'s zijn gemaakt om enkelvoudige applicaties te ontwikkelen.
		\item Eenvoudig om veranderingen toe te passen. 
		\item Eenvoudig te testen aangezien de applicatie enkel moet draaien en dan de bijhorende testen moet uitvoeren.
		\item Eenvoudig om te deployen. Een WAR bestand functioneert onmiddelijk indien deze geplaatst wordt op een server met Tomcat geïnstalleerd.
	\end{itemize}
	Er zijn ook echter een aantal \textbf{nadelen} aan verbonden. Een codebase die zodanig groot wordt dat een ontwikkelaar niet alles meer kan begrijpen geeft aanleiding tot tragere compileertijden, destructieve bugs en tragere testen aangezien deze heel de testsuite moeten uitvoeren.
	
	\section{Microservices}
	Een microservice is een stijl dat een applicatie opdeelt in kleinere services. Deze services kunnen onafhankelijk van elkaar gebouwd worden. De services communiceren enkel via een API. Elke service heeft ook zijn eigen databank. De API bestaat uit een aantal \textbf{commands}. Deze commando's wijzigen de databank van een service. \textbf{Queries} daarentegen, vragen enkel gegevens op. Deze twee types operaties worden aangesproken door een client die gebruik wenst te maken van de API. Verder bevat een service ook nog \textbf{events}. Clients worden geinformeerd bij het gebeuren van een specifiek event. Een voorbeeld van zo een event is een confirmatie dat een bestelling gelukt is. Een microservice zal een kleine taak op zich nemen. Meestal is dit een groep van use-cases die nauw aan elkaar verbonden zijn. Het voordeel is dat er slechts kleine groepen van ontwikkelaars nodig zijn om elke individueel service to bouwen. De \textbf{Voordelen} van microservices zijn:
	\begin{itemize}
		\item Zwakke koppeling tussen microservices. Een verandering in een service mag geen invloed hebben op andere services. Hierdoor zijn API's heel belangrijk.
		\item Er kunnen verschillende technologiën gebruikt worden in elke individuele miicroservice.
		\item Elke microservice kan zijn eigen database schema gebruiken.
	\end{itemize}
	Enkele \textbf{nadelen} zijn:
	\begin{itemize}
		\item Een \textbf{incorrecte decompositie} (zie volgend hoofdstuk) zal leiden tot een gidistribueerde monolith.
		\item Microservices \textbf{communiceren} met elkaar over een netwerk. Dit is over het algemeen \textbf{trager} dan een lokale connectie. Juist hierom moet de API zo ontworpen zijn dat er minimaal verkeer moet zijn tussen de verschillende microservices. 
		\item Een \textit{IDE} bevat minder tools om microservices te testen en te ontwikkelen.
		
	\end{itemize}
	\chapter{Decompositie van een applicatie}
	Het proces om een applicatie in te delen in verschillende microservices noemt men \textbf{decompositie}. Dit \textbf{iteratief} proces is belangrijk aangezien een foutieve methode leidt tot ongewenste resultaten. Een dergerlijk proces kan opgedeeld worden in drie stappen.
	\begin{enumerate}
		\item \textbf{Identificatie van de systeemoperaties.} Dit omvat het vertalen van de noden van één of meerdere gebruikers naar user stories en use-cases. Vaak wordt er hier overlegd met enkele domeinexperts. Het is belangrijk om te achterhalen wat belangrijke systeemoperaties zijn. Welke informatie moet er met een \textit{create}, \textit{update} of \textit{delete} gewijzigd worden? Welke informatie moet met een \textit{query} opgehaald worden? In deze fase worden er nog geen technische vaststellingen gedaan. De focus ligt namelijk op het vaststellen van de pre- en postcondities van de verschillende systeemoperaties.
		
		\item \textbf{Identificatie van de services.} Services specificeren handelingen dat een bedrijf kan doen. Voorbeelden voor een online webshop zijn: \textit{Sales}, \textit{Marketing}, \textit{Payment}, \textit{Order Shipping} en \textit{Order Tracking}. Deze services blijven lang stabiel en zullen haast nooit veranderen tenzij de business een shift van focus doen. Een obstakel dat zich kan voordoen zijn \textbf{godklassen}. Dit zijn klassen die te veel verantwoordelijkheid op zich dragen. Een oplossing hiervoor is om deze klasse in een centrale databank op te slaan en services die deze klasse nodig hebben kunnen die dan via de databank aanspreken. Dit is duidelijk een overtreding op de principes van de microservice architectuur. Er is nu een sterke koppeling tussen de microservices en de godklasse. Een betere oplossing is het opsplitsen van de klasse in verschillende klassen op basis van de bestaande services. Deze verschillende klassen kunnen in een microservice gestoken worden waarbij de definitie van de klasse sterk gedaald is (ze moet maar gelden binnen de microservice). Voorbeeld van een godklasse is een \textbf{Order} klasse voor pizza's. Denk aan de typische attributen: \textit{status}, \textit{requestedDeliveryTime}, \textit{prepareByTime}, \textit{deliveryTime}, \textit{paymentinfo}, \textit{deliveryAddress}, ... . Het opsplitsen van deze klassen kan bijvoorbeeld gebeuren door enkel informatie die relevant is voor de keuken, in een keukenserivce te steken en informatie die enkel relevant is voor het bezorgen van een bepaalde order in een deliveryservice. Op die manier worden godklassen vermeden.
		
		\item \textbf{Identificatie van de service API's.} Deze laatste stap zal nagaan welke operaties van een microservice publiek moeten gesteld worden aan de buitenwereld via een API. 
	\end{enumerate}
	\chapter{Interactiestijlen tussen services}
	Microservices moeten met elkaar kunnen interageren. Bij het zoeken van een oplossing moeten volgende vragen gesteld worden:
	\begin{itemize}
		\item Hoe kan het aantal interacties tussen twee microservices geminimaliseerd worden?
		\item Hoe wordt de communicatie geïmplementeerd?
		\item Kan men zeker zijn dat een microservice zal antwoorden?
	\end{itemize}
	Een interactie kan op een \textbf{synchrone} manier gebeuren. Een client zal een aanvraag sturen naar een bepaalde service en zal wachten totdat er een antwoord terug ontvangen is. Tijdens de aanvraag en het antwoord zal de client blokkeren. Een \textbf{asynchrone} interactie daarentegen zal toelaten dat de client niet hoeft te wachten op het antwoord. Verder is er ook nog een opdeling mogelijk op vlak van het aantal microservices die een request behandelen. Een \textbf{one-to-one} geeft aan dat slechts één enkele microservice het request zal afhandelen. Een \textbf{one-to-many} interactie geeft aan dat meerdere microservices een request zullen afhandelen.
	
	\part{Container deployment and orchestration}
	\chapter{Productieomgeving}
	Een applicatie kan over een groot aantal services beschikken, die allemaal gebruik maken van verschillende technologiën. Een service kan eigenlijk beschouwd worden als een kleine applicatie, zodat er in plaats van één grote applicatie, meerdere kleinere applicaties in productie moeten draaien. Zo een productieomgeving moet vier functionaliteiten implementeren:
	\begin{enumerate}
		\item \textbf{Service management interface.} Het in staat zijn om services te creëren, configureren en updaten, vaak via een shell of GUI.
		\item \textbf{Runtime service management.} De omgeving moet automatisch services kunnen herstarten indien deze gecrasht zijn. Ook als een fysieke server faalt, moet de omgeving een andere server aanspreken om de service op te draaien.
		\item \textbf{Monitoring.} Informatie over elke service instance zoals logbestanden en metrieken voor die bepaalde service (aantal bezoekers per seconde, sucess rate, ...) moeten beschikbaar zijn voor de ontwikkelaars, en moeten ook gewaarschuwd worden indien een service niet aan de vooropgestelde criteria voldoet.  
		\item \textbf{Request routing.} De requests dat users versturen moeten naar de juiste service doorverwezen worden.
	\end{enumerate}

	Volgende paragrafen bespreken hoe een aantal van deze zaken geïmplementeerd kunnen worden.

	Een service heeft altijd een aantal configuratiegegevens (\textbf{environment variabelen} genoemd), die afhankelijk zijn van de omgeving waarin de service draait. Een service moet zo ontworpen zijn dat deze slechts éénmaal gecompileerd moet worden door de deployment pipeline, zodat deze meerdere malen in productie gezet kan worden. Het externalizeren van de configuratiegegevens betekent dat de configuratie van een service tijdens runtime bepaalt wordt. Hier zijn er twee modellen mogelijk:
	\begin{itemize}
		\item \textbf{Push model.} Bij dit model zal de service bij het opstarten configuratiegegevens verwachten, die door de deploymentomgeving meegegeven worden. Hoe deze configuratiegegevens gegeven worden (via bestand, of individuele parameters) maakt niet uit. De service en deploymentomgeving moeten wel onderling van elkaar weten hoe de structuur van de configuratiegegevens in elkaar zit. Het \underline{grootste nadeel} van deze methode is dat een service haast niet meer gewijzigd kan worden na het initialiseren van de service. Een ander \underline{nadeel} is dat de configuratiegegevens verspreidt over de services liggen.
		\item \textbf{Pull model.} Het pull model heeft bijna enkel voordelen tegenover het push model. De deploymentomgeving geeft bij de creatie van de service enkel de URL mee van een zogenaamde \underline{configuratieserver}. Deze server bevat alle configuratiegegevens voor elke service. De service zelf zal dan deze server, met behulp van de URL, aanspreken om de juiste configuratiegegevens op te halen. Dit biedt een aantal \underline{voordelen}:
		\begin{itemize}
			\item Gecentraliseerde configuratie.
			\item Een service kan de server pollen om na te gaan of de configuratiegegevens aangepast zijn, en deze dan eventueel op te halen. De service moet hiervoor niet herstart worden.
			\item Sommige configuratiegegevens zijn gevoelig, zoals databaseinformatie. De server zal deze moeten encrypteren. De service wordt dan wel verwacht de publieke sleutel van de server te hebben zodat hij deze kan decrypteren. Sommige servers decrypteren de configuratiegegevens zelf.
		\end{itemize}
		Het \underline{grootste nadeel} is echter dat de configuratieserver opnieuw een infrastructuur is dat moet opgesteld en onderhouden worden.
	\end{itemize}

	Om \textbf{monitoring} te implementeren moeten services 'waarneembaar' gemaakt worden. Er moeten hiervoor extra APIs aangemaakt worden, die niet mogen interfereren met de werkelijke functionaliteit van de service. Hiervoor zijn er een aantal hulpmiddelen om een service waarneembaar te maken:
	\begin{itemize}
		\item \textbf{Health check API.} Een eenvoudige API dat de status van de service teruggeeft.
		\item \textbf{Log aggregation.} Logbestanden zijn een goede manier om de werking van de service op te volgen. Deze logbestanden worden best geschreven naar een gecentraliseerde logserver, zodat \underline{zoeken} ondersteund kan worden. Het is ook enkel de verantwoordelijkheid van de logserver om ontwikkelaars te waarschuwen. Traditioneel logt een applicatie naar een welbepaald logbestand op het filesysteem. Dit is hier geen goede oplossing, omdat sommige services zelfs geen filesysteem zullen hebben. Hierom moet elke service loggen naar stdout. De deploymentomgeving zal dan beslissen wat hij wil doen met deze uitvoer. 
		\item \textbf{Distributed tracing.} Het oproepen van een endpoint van de API kan meerdere interne calls maken. Het is vaak moeilijk te achterhalen waarom zo een query traag verloopt. Distributed tracing kent aan elke endpoint een ID toe, en bekijkt de call chain die overlopen wordt. Deze gegevens worden naar een gecentraliseerde server verstuurd waarop analyse kan uitgevoerdt worden. Een endpoint wordt gepresenteerd door een \underline{trace}. Zo een trace bestaat uit geneste \underline{spans}, die elk een call voorstellen. De endpoint is de top span, en zal elke andere span bevatten. 
		\item \textbf{Audit logging.} Het doel van audit logging is om acties van gebruikers te verzamelen. Elke audit log entry heeft een ID dat een gebruiker voorstelt, de actie dat ze uitgevoerd hebben en het domeinobject. Voorbeelden zijn gefaalde loginpoging, toevoegen van items in het winkelmandje, maar uiteindelijk niet betalen. Zulke logs dienen vooral voor customer support en om vreemde activiteiten op te sporen.
		\item \textbf{Application metrics.} Deze tak bestaat uit een metriekservice. Deze metriekservice vraagt gegevens op van de verschillende applicaties. Zulke gegevens zijn onder andere: CPU gebruik, geheugengebruik, schijfgebruik, aantal requests per seconde, request latency en domeinspecifieke gegevens. Een service moet ontworpen zijn zodat al deze gegevens naar de metriekservice kunnen verstuurd worden, en is afhankelijk van het gebruikte framework. De service kan ofwel zelf beslissen om zijn metrieken te versturen naar de metriekservice, of de metriekservice zal elke service pollen om de metrieken op te halen.
	\end{itemize}
	\chapter{Containers}
	Verschillende microservices kunnen onderling elk gebruik maken van verschillende technologiën. Om deze verschillende microservices te deployen zouden al de verschillende dependencies van elke technologie op de server geconfigureerd moeten worden. Dit is natuurlijk niet haalbaar op grote schaal, daarom zou men in eerste instantie virtuele machines kunnen gebruiken waarbij elke verschillende virtuele machine geshickt is voor een specifieke technologiestack. Virtuele machines nemen echter te veel opslag in beslag. Ze nemen zoveel beslag in omdat elke virtuele machine zijn eigen besturingssysteem en kernel bevat. De hypervisor (of virtual machine monitor) geeft elke virtuele machine de illusie dat enkel hun machine toegang heeft tot de resources van het \underline{hosttoestel} (het toestel waarop de virtuele machines draaien). 
	Er zijn twee types hypervisor:
	\begin{itemize}
		\item \textbf{Type 1.} Dit type hypervisor draait rechtstreeks op de hardware van de host en heeft geen behoefte aan een onderliggend besturingssysteem. 
		\item \textbf{Type 2.} Dit type hypervisor heeft wel nood aan een besturingssysteem. Dit heeft als voordeel dat er ook applicaties op het hosttoestel kunnen draaien.
	\end{itemize}
	\underline{Containers} zijn een virtualisatietechniek op besturingssysteemniveau. Op het host toestel draait er slechts één besturingssysteem en zal 
 
	\part{Distributed Data Storage \& Processing}
\end{document}
