\documentclass{report}
\usepackage{ugentstyle}

\begin{document}
	\maketitle{Systeemontwerp}
	\tableofcontents
	\chapter{Inleiding}
	\begin{itemize}
		\item[\info] \underline{Systeemontwerp} = het ontwerpen van een infrastructuur waarbij verschillende componenten met elkaar kunnen interageren.
		\item[\info] Typische high level architectuurblokken: 
			\begin{itemize}
				\item[\info] \underline{transactiebehandeling}: requests behandelen van gebruikers.
				\item[\info] \underline{business intelligence}: geproduceerde data analyseren.
			\end{itemize}  
	\end{itemize}
	\section{Softwarearchitectuur}
	\subsection{Systeemrequirements}
	\begin{itemize}
		\item[\info] \underline{functionele requirements}: specificatie wat een systeem moet \textbf{doen}.
		\item[\info] \underline{niet-functionele requirements}: specificatie wat een systeem moet \textbf{zijn} (kwaliteitseisen).
	\end{itemize}

	\subsection{4+1 view model}
	\begin{itemize}
		\item[\info] Logical view:
			\begin{itemize}
				\item[\info] Bevat de klassen, packages, relaties tussen klassen, associaties tussen de klassen (\accentuate{domain class diagram en entity-relationship diagram})
			\end{itemize}
		\item[\info] Implementation view:
			\begin{itemize}
				\item[\info] Bevat de output van het build systeem, zoals de verschillende modules (bv JARs) en componenten (executables, WARS).
				\item[\info] Beschrijft de onderliggende relaties tussen alle modules en componenten (import, use, merge, ...)
			\end{itemize}
		\item[\info] Process view:
			\begin{itemize}
				\item[\info] Bevat de beschrijving van de werking van verschillende processen (een proces kan een hele module zijn) (\accentuate{activity diagram}).
				\item[\info] Een proces kan beheerd worden: starten, pauzeren, configureren, stoppen.
				\item[\info] Heeft als doel om \underline{deadlocks} en \underline{netwerkvertragingen} te voorkomen en \underline{consistentie} te bereiken. 
			\end{itemize}
		\item[\info] Deployment view:
			\begin{itemize}
				\item[\info] Beschrijft op welke toestellen de processen moeten gedeployed worden, hoeveel toestellen er gebruikt worden.
				\item[\info] Verschillende deploymentconfiguraties mogelijk per klant of geografisch gebied, maar ook of dat het een productie of ontwikkelomgeving is.
			\end{itemize}
		\item[\info] \accentuate{+1} Use Cases/Scenarios:
			\begin{itemize}
				\item[\info] Een use case beschrijft, binnen een view, hoe dat de componenten binnen die view met elkaar interageren voor een bepaalde situatie.
				\item[\info] Is eigenlijk redundant omdat andere 4 views deze informatie ook al bevatten, maar \underline{use cases zijn toch nuttig}:
				\begin{itemize}
					\item[\good] Het valideert het ontwerp.
					\item[\good] Het kan nieuwe systeemelementen ontdekken.
				\end{itemize}
			\end{itemize}
	\end{itemize}
	\section{Reactive manifesto}
	\underline{4 kenmerken:}
	\begin{itemize}
		\item[\info] Message Driven: asynchrone communicatie tussen componenten. Maakt gebruik van een wachtrij om de berichten te beheren. Dit heeft \underline{drie voordelen}:
		\begin{itemize}
			\item[\good] Zwakke koppeling: de verschillende componenten moeten enkel een protocol afspreken voor het bericht. 
			\item[\good] Loskoppelen van de tijd: Zender en ontvanger moeten niet wachten op elkaar.
			\item[\good] Loskoppelen van locatie: De zender en ontvanger moeten niet in hetzelfde proces beschikbaar zijn, enkel de locator (\accentuate{analogie met gsm-nummer, ik kan eender waar naar iemand bellen, onafhankelijk van zijn locatie}) moet bekend zijn.
		\end{itemize}
		\item[\info] Responsief:
			\begin{itemize}
				\item[\info] Lazy loading
				\item[\info] Toon progressbar
				\item[\info] Een trage service mag andere services niet beïnvloeden.
			\end{itemize}
		\item[\info] Elastisch:
			\begin{itemize}
				\item[\info] Predictieve en reactieve schaling
				\item[\info] Resources moeten voor elk individueel component instelbaar zijn
				\item[\info] Systeem moet responsief blijven
			\end{itemize}
		\item[\info] Foutbestendig:
			\begin{itemize}
				\item[\info] Systeem moet zichzelf kunnen herstellen
				\item[\info] Fouten moeten snel opgespoord kunnen worden via monitoring
				\item[\info] Voorzie fallback services
			\end{itemize}
	\end{itemize}

	\part{Microservices}
	\chapter{Architectuurstijlen}
	\begin{itemize}
		\item[\info] Gelaagde stijl:
		\begin{itemize}
			\item[\info] Kan toegepast worden op elk view model.
			\item[\info] 3 lagen in het \textbf{logische view}: persistentie, presentatie en domeinlogica.
			\item[\good] Robust systeem.
			\item[\good] Eenvoudig om te ontwikkelen (veel frameworks ondersteunen dit: Java EE, .NET, ...).
			\item[\good] De verschillende lagen kunnen gemockt worden om eenvoudig testen uit te voeren.
			\item[\alert] Slechts één presentatielaag, maar er kunnen verschillende cliënts zijn (desktop, mobile, tablet, ...).
			\item[\alert] Slechts één persistentielaag, maar er kunnen verschillende databasetechnologiën gebruikt worden.
			\item[\alert] De domeinlogicalaag definieert repositories, maar de persistentielaag implementeert deze. De dependency is dus omgekeerd.
		\end{itemize}
		\item[\info] Hexagonale stijl:
		\begin{itemize}
			\item[\info] Maakt gebruik van adapters. Deze adapters zijn interfaces en kunnen opgesplitst worden:
			\begin{itemize}
				\item[\info] \textbf{Inbound adapter}: Dit is API dat de domeinlogica openstelt, zodat deze kan aangeroepen worden door externen. Elke cliënt kan nu onafhankelijk van elkaar ontwikkeld worden. Ze moeten enkel maar de API aanroepen.
				\item[\info] \textbf{Outbound adapter}: Dit is de API die de domeinlogica kan gebruiken (repository interface, payment interface).
			\end{itemize}
			\item[\good] presentatie-, persistentie- en domeinlogicalaag zijn losgekoppeld.
		\end{itemize}
		\item[\info] Monolithische stijl:
		\begin{itemize}
			\item[\info] Een monolitische applicatie bevat de drie lagen van de gelaagde stijl, en verpakt dit in één executable.
			\item[\good] Makkelijk te ontwikkelen met een IDE.
			\item[\good] Eenvoudig om wijzigingen door te voeren: edit $\rightarrow$ build $\rightarrow$ deploy.
			\item[\good] Eenvoudig te testen.
			\item[\good] Eenvoudig om te deployen.
			\item[\alert] Voor grote codebases wordt het moeilijk om elk detail van de codebase te kennen.
			\item[\alert] Een kleine wijziging resulteert in het rebuilden van de hele applicatie.
			\item[\alert] Een bug kan het hele systeem onbereikbaar maken.
			\item[\alert] Replicatie is haast onmogelijk. 
		\end{itemize}
		\item[\info] \textbf{Microservices}:
		\begin{itemize}
			\item[\info] Decomposeerd een applicatie in kleine, zwak gekoppelde services, die individueel kunnen gedeployed worden.
			\item[\info] Services communiceren met elkaar via APIs.
			\item[\info] Wordt geïmplementeerd in de implementatie view. Elke service heeft zijn eigen logische view.
			\item[\info] \underline{Wat is een service?}
			\begin{itemize}
				\item[\info] Een individueel component dat een bepaalde functionaliteit aanbiedt.
				\item[\info] Deze functionaliteit wordt via een API beschikbaar gesteld. 
			\end{itemize}
			\item[\info] \underline{Wat is een service?}
			\begin{itemize}
				\item[\info] Een service dat goed gedefinieerd is in functie van de business.
				\item[\info] Voert een eenvoudige functie uit, en kan door een klein ontwikkelteam beheerd worden.
			\end{itemize}
			\item[\alert] De juiste services vinden is moeilijk.
			\item[\alert] Foute decompositie leidt tot een gedistribueerd monolitisch systeem.
			\item[\alert] Gedistribueerde systemen zijn complex. (bv geen IDE die dit ondersteund).
			\item[\alert] Communicatie tussen services (over een netwerk) is traag.
			\item[\alert] Vele verschillende services kunnen op hetzelfde moment aan het draaien zijn. 
		\end{itemize}
	\end{itemize}
	
	\chapter{Decompositie van een applicatie}
	Het proces om een applicatie in te delen in verschillende microservices noemt men \textbf{decompositie}. Dit \textbf{iteratief} proces is belangrijk aangezien een foutieve methode leidt tot ongewenste resultaten. Een dergerlijk proces kan opgedeeld worden in drie stappen.
	\begin{enumerate}
		\item \textbf{Identificatie van de systeemoperaties.} Dit omvat het vertalen van de noden van één of meerdere gebruikers naar user stories en use-cases. Vaak wordt er hier overlegd met enkele domeinexperts. Het is belangrijk om te achterhalen wat belangrijke systeemoperaties zijn. Welke informatie moet er met een \textit{create}, \textit{update} of \textit{delete} gewijzigd worden? Welke informatie moet met een \textit{query} opgehaald worden? In deze fase worden er nog geen technische vaststellingen gedaan. De focus ligt namelijk op het vaststellen van de pre- en postcondities van de verschillende systeemoperaties.
		
		\item \textbf{Identificatie van de services.} Services specificeren handelingen dat een bedrijf kan doen. Voorbeelden voor een online webshop zijn: \textit{Sales}, \textit{Marketing}, \textit{Payment}, \textit{Order Shipping} en \textit{Order Tracking}. Deze services blijven lang stabiel en zullen haast nooit veranderen tenzij de business een shift van focus doen. Een obstakel dat zich kan voordoen zijn \textbf{godklassen}. Dit zijn klassen die te veel verantwoordelijkheid op zich dragen. Een oplossing hiervoor is om deze klasse in een centrale databank op te slaan en services die deze klasse nodig hebben kunnen die dan via de databank aanspreken. Dit is duidelijk een overtreding op de principes van de microservice architectuur. Er is nu een sterke koppeling tussen de microservices en de godklasse. Een betere oplossing is het opsplitsen van de klasse in verschillende klassen op basis van de bestaande services. Deze verschillende klassen kunnen in een microservice gestoken worden waarbij de definitie van de klasse sterk gedaald is (ze moet maar gelden binnen de microservice). Voorbeeld van een godklasse is een \textbf{Order} klasse voor pizza's. Denk aan de typische attributen: \textit{status}, \textit{requestedDeliveryTime}, \textit{prepareByTime}, \textit{deliveryTime}, \textit{paymentinfo}, \textit{deliveryAddress}, ... . Het opsplitsen van deze klassen kan bijvoorbeeld gebeuren door enkel informatie die relevant is voor de keuken, in een keukenserivce te steken en informatie die enkel relevant is voor het bezorgen van een bepaalde order in een deliveryservice. Op die manier worden godklassen vermeden.
		
		\item \textbf{Identificatie van de service API's.} Deze laatste stap zal nagaan welke operaties van een microservice publiek moeten gesteld worden aan de buitenwereld via een API. 
	\end{enumerate}
	\chapter{Interactiestijlen tussen services}
	\begin{table}[ht]
		\centering
		\begin{tabular}{c | c | c}
			& one-to-one & one-to-many \\
			\hline
			synchroon & request/response & / \\
			\hline 
		asynchroon & \hspace{2em} \begin{minipage}[c]{0.3\textwidth}request/async response \\ one way notifications\end{minipage} & \hspace{2em} \begin{minipage}[c]{0.3\textwidth}publish/subscribe \\ publish/async response\end{minipage}
		\end{tabular}
	\end{table}
	\begin{itemize}
		\item[\info] request/response: Een service stuurt een request en wacht op een response.
		\item[\info] request/async response: Een service stuurt een request, maar wacht niet noodzakelijk op een response.
		\item[\info] one way notifications: Een service stuurt een request en verwacht geen response.
		\item[\info] publish/subscribe: Een service publiceerd een bericht en kan opgevangen worden door 0 of meerdere geïnteresseerden.
		\item[\info] publish/async responses: Een service publiceerd een bericht en zal eventueel antwoorden opvangen van 0 of meerdere geïnteresseerden.
	\end{itemize}
	\section{Synchrone communicatie}
	\underline{Voorbeelden van synchrone communicatie}: REST en gRPC.
	\begin{itemize}
		\item[\info] REST
		\begin{itemize}
			\item[\info] Vier levels:
			\begin{enumerate}
				\item[0]: Enkel HTTP POST mogelijk. Elke actie krijgt dan ook een ander endpoint toegewezen.
				\item[1]: Maakt gebruik van resources zodat elk individuele resource een URI krijgt. Nog steeds enkel HTTP POST mogelijk.
				\item[2]: GET, POST, PUT mogelijk. Een zelfde resource kan nu meerdere operaties ondersteunen.
				\item[3]: HATEEOAS mogelijk: een GET request bevat, behalve het object, ook URLs die mogelijke acties op het object toelaten.
			\end{enumerate}
			\item[\good] HTTP wordt niet geblokkeerd door een firewall.
			\item[\good] Implementeerd request/response interactie.
			\item[\alert] Cliënts moeten de locatie (URL) kennen.
			\item[\alert] Meerdere resources in één request opvragen is moeilijk. 
			\item[\alert] Soms is het moeilijk om de HTTP werkwoorden te mappen op een operatie.
		\end{itemize}
		\item[\info] gRPC
		\begin{itemize}
			\item[\info] Google Remote Procedure Call.
			\item[\info] API wordt gedefinieerd op basis van een Interface Definition File. Dit bestand bevat IDL (Interface Description Language) code.
			\item[\info] Deze code wordt gecompileerd afhankelijk van de gekozen cliënt.
			\item[\alert] Het valt niet op dat de communicatie nu over het netwerk gebeurd.
		\end{itemize}
	\end{itemize}
	\underline{Hoe foutbestendig maken?}

	\chapter{Saga}
	=\underline{garanderen dat een transactie ofwel volledig, ofwel niet uitgevoerd wordt.}
	\begin{itemize}
		\item[\info] Traditioneel: 2-fasen-commit.
		\begin{itemize}
			\item[\info] Eerst wordt elke databank naarwaar geschreven moet worden, op de hoogte gebracht van de informatie die ze moeten schrijven.
			\item[\info] De eerste fase zal aan elke databank vragen of zij klaar zijn om weg te schrijven (prepare-fase).
			\item[\info] De tweede fase zal effectief een commit uitvoeren op elke databank (commit-fase).
			\item[\info] Van zodra één databank 'nee' antwoord, wordt het hele proces gestopt.
			\item[\alert] Synchroon
			\item[\alert] Niet elke database implementeert het concept van transacties en locking.
		\end{itemize}
		\item[\info] \textbf{Saga}
		\begin{itemize}
			\item[\info] Een sequentie van lokale interacties tussen verschillende microservices.
			\item[\info] Elke systeemoperatie moet een saga hebben.
			\item[\info] 
		\end{itemize}
	\end{itemize}
	
	\part{Container deployment and orchestration}
	\chapter{Productieomgeving}
	Een applicatie kan over een groot aantal services beschikken, die allemaal gebruik maken van verschillende technologiën. Een service kan eigenlijk beschouwd worden als een kleine applicatie, zodat er in plaats van één grote applicatie, meerdere kleinere applicaties in productie moeten draaien. Zo een productieomgeving moet vier functionaliteiten implementeren:
	\begin{enumerate}
		\item \textbf{Service management interface.} Het in staat zijn om services te creëren, configureren en updaten, vaak via een shell of GUI.
		\item \textbf{Runtime service management.} De omgeving moet automatisch services kunnen herstarten indien deze gecrasht zijn. Ook als een fysieke server faalt, moet de omgeving een andere server aanspreken om de service op te draaien.
		\item \textbf{Monitoring.} Informatie over elke service instance zoals logbestanden en metrieken voor die bepaalde service (aantal bezoekers per seconde, sucess rate, ...) moeten beschikbaar zijn voor de ontwikkelaars, en moeten ook gewaarschuwd worden indien een service niet aan de vooropgestelde criteria voldoet.  
		\item \textbf{Request routing.} De requests dat users versturen moeten naar de juiste service doorverwezen worden.
	\end{enumerate}

	Volgende paragrafen bespreken hoe een aantal van deze zaken geïmplementeerd kunnen worden.

	Een service heeft altijd een aantal configuratiegegevens (\textbf{environment variabelen} genoemd), die afhankelijk zijn van de omgeving waarin de service draait. Een service moet zo ontworpen zijn dat deze slechts éénmaal gecompileerd moet worden door de deployment pipeline, zodat deze meerdere malen in productie gezet kan worden. Het externalizeren van de configuratiegegevens betekent dat de configuratie van een service tijdens runtime bepaalt wordt. Hier zijn er twee modellen mogelijk:
	\begin{itemize}
		\item \textbf{Push model.} Bij dit model zal de service bij het opstarten configuratiegegevens verwachten, die door de deploymentomgeving meegegeven worden. Hoe deze configuratiegegevens gegeven worden (via bestand, of individuele parameters) maakt niet uit. De service en deploymentomgeving moeten wel onderling van elkaar weten hoe de structuur van de configuratiegegevens in elkaar zit. Het \underline{grootste nadeel} van deze methode is dat een service haast niet meer gewijzigd kan worden na het initialiseren van de service. Een ander \underline{nadeel} is dat de configuratiegegevens verspreidt over de services liggen.
		\item \textbf{Pull model.} Het pull model heeft bijna enkel voordelen tegenover het push model. De deploymentomgeving geeft bij de creatie van de service enkel de URL mee van een zogenaamde \underline{configuratieserver}. Deze server bevat alle configuratiegegevens voor elke service. De service zelf zal dan deze server, met behulp van de URL, aanspreken om de juiste configuratiegegevens op te halen. Dit biedt een aantal \underline{voordelen}:
		\begin{itemize}
			\item Gecentraliseerde configuratie.
			\item Een service kan de server pollen om na te gaan of de configuratiegegevens aangepast zijn, en deze dan eventueel op te halen. De service moet hiervoor niet herstart worden.
			\item Sommige configuratiegegevens zijn gevoelig, zoals databaseinformatie. De server zal deze moeten encrypteren. De service wordt dan wel verwacht de publieke sleutel van de server te hebben zodat hij deze kan decrypteren. Sommige servers decrypteren de configuratiegegevens zelf.
		\end{itemize}
		Het \underline{grootste nadeel} is echter dat de configuratieserver opnieuw een infrastructuur is dat moet opgesteld en onderhouden worden.
	\end{itemize}

	Om \textbf{monitoring} te implementeren moeten services 'waarneembaar' gemaakt worden. Er moeten hiervoor extra APIs aangemaakt worden, die niet mogen interfereren met de werkelijke functionaliteit van de service. Hiervoor zijn er een aantal hulpmiddelen om een service waarneembaar te maken:
	\begin{itemize}
		\item \textbf{Health check API.} Een eenvoudige API dat de status van de service teruggeeft.
		\item \textbf{Log aggregation.} Logbestanden zijn een goede manier om de werking van de service op te volgen. Deze logbestanden worden best geschreven naar een gecentraliseerde logserver, zodat \underline{zoeken} ondersteund kan worden. Het is ook enkel de verantwoordelijkheid van de logserver om ontwikkelaars te waarschuwen. Traditioneel logt een applicatie naar een welbepaald logbestand op het filesysteem. Dit is hier geen goede oplossing, omdat sommige services zelfs geen filesysteem zullen hebben. Hierom moet elke service loggen naar stdout. De deploymentomgeving zal dan beslissen wat hij wil doen met deze uitvoer. 
		\item \textbf{Distributed tracing.} Het oproepen van een endpoint van de API kan meerdere interne calls maken. Het is vaak moeilijk te achterhalen waarom zo een query traag verloopt. Distributed tracing kent aan elke endpoint een ID toe, en bekijkt de call chain die overlopen wordt. Deze gegevens worden naar een gecentraliseerde server verstuurd waarop analyse kan uitgevoerdt worden. Een endpoint wordt gepresenteerd door een \underline{trace}. Zo een trace bestaat uit geneste \underline{spans}, die elk een call voorstellen. De endpoint is de top span, en zal elke andere span bevatten. 
		\item \textbf{Audit logging.} Het doel van audit logging is om acties van gebruikers te verzamelen. Elke audit log entry heeft een ID dat een gebruiker voorstelt, de actie dat ze uitgevoerd hebben en het domeinobject. Voorbeelden zijn gefaalde loginpoging, toevoegen van items in het winkelmandje, maar uiteindelijk niet betalen. Zulke logs dienen vooral voor customer support en om vreemde activiteiten op te sporen.
		\item \textbf{Application metrics.} Deze tak bestaat uit een metriekservice. Deze metriekservice vraagt gegevens op van de verschillende applicaties. Zulke gegevens zijn onder andere: CPU gebruik, geheugengebruik, schijfgebruik, aantal requests per seconde, request latency en domeinspecifieke gegevens. Een service moet ontworpen zijn zodat al deze gegevens naar de metriekservice kunnen verstuurd worden, en is afhankelijk van het gebruikte framework. De service kan ofwel zelf beslissen om zijn metrieken te versturen naar de metriekservice, of de metriekservice zal elke service pollen om de metrieken op te halen.
	\end{itemize}
	\chapter{Containers}
	Verschillende microservices kunnen onderling elk gebruik maken van verschillende technologiën. Om deze verschillende microservices te deployen zouden al de verschillende dependencies van elke technologie op de server geconfigureerd moeten worden. Dit is natuurlijk niet haalbaar op grote schaal, daarom zou men in eerste instantie virtuele machines kunnen gebruiken waarbij elke verschillende virtuele machine geshickt is voor een specifieke technologiestack. Virtuele machines nemen echter te veel opslag in beslag. Ze nemen zoveel beslag in omdat elke virtuele machine zijn eigen besturingssysteem en kernel bevat. De hypervisor (of virtual machine monitor) geeft elke virtuele machine de illusie dat enkel hun machine toegang heeft tot de resources van het \underline{hosttoestel} (het toestel waarop de virtuele machines draaien). 
	Er zijn twee types hypervisor:
	\begin{itemize}
		\item \textbf{Type 1.} Dit type hypervisor draait rechtstreeks op de hardware van de host en heeft geen behoefte aan een onderliggend besturingssysteem. 
		\item \textbf{Type 2.} Dit type hypervisor heeft wel nood aan een besturingssysteem. Dit heeft als voordeel dat er ook applicaties op het hosttoestel kunnen draaien.
	\end{itemize}
	\underline{Containers} zijn een virtualisatietechniek op besturingssysteemniveau. Een populaire container technologie is Docker, dat gebruik maakt van de linux container functionaliteit.  
	\begin{itemize}
		\item \textbf{Linux Control Groups (cgroups).} Groeperen van taken, en privileges zetten op deze groepen.
		\item \textbf{Linux namespaces.} Een geïsoleerde weergave van de systeemresources.
		\item \textbf{Changing root (chroot).} Elk process de illusie geven dat ze vanuit de root-directory aangesproken worden.
		\item \textbf{Veilige containers.} Mogelijkheden per process vastzetten.
	\end{itemize}

	\underline{Docker}:
	\begin{itemize}
		\item Automatisch verpakken en deployen van een applicatie.
		\item Beschikbaar op Linux, MacOS, Windows.
		\item Onafhankelijk. Minimale dependencies.
		\item Grote flexibiliteit in wat er in de container moet.
		\item Alle containers kunnen gestart en gestopt worden op dezelfde manier.
		\item Lightweight. Meerdere containers per host mogelijk (nog meer dan virtuele machines).
	\end{itemize}

	\section{Docker Architecture}
	

 
	\part{Distributed Data Storage \& Processing}
	\chapter{De uitdagingen van moderne data}
	Data-intensieve applicaties moeten rekening houden met volgende vier categorieën:
	\begin{itemize}
		\item \textbf{Volume.} De hoeveelheid opslag die over verschillende plaatsen moeten opgeslagen worden.
		\item \textbf{Velocity.} De snelheid waarop nieuwe informatie actueel wordt.
		\item \textbf{Variety.} De verschillende soorten types van data die bestaan. 
		\item \textbf{Veracity.} De betrouwbaarheid van de data. 
	\end{itemize}
	\chapter{Datamodellen}
	\section{Het relationeel model}
	\accentuate{zie cursus relationele gegevensbanken, belangrijk is om gewoon de nadelen te kennen zoals:}
	\begin{itemize}
		\item Er zou een brede tabel nodig zijn met honderden kolommen (waarvan de meeste dan NULL zijn) om bijvoorbeeld de producten van een winkel op te slaan. Elk product heeft diverse kenmerken die eigen zijn aan een bepaalde productcategorie.
		\item Men zou dit kunnen oplossen door een nieuwe tabel te maken per productcategorie, maar dit introduceert veel tabellen en relaties (te vergelijken met het verhogen van de normaalvorm).
	\end{itemize}
	\section{Het document model}
	Informatie in een document model wordt in een boomstructuur met one-to-many relaties opgeslagen, en is daarom dus perfect voor \underline{one-to-many relaties}. Een document wordt opgeslagen als één string, meestal in JSON of XML formaat, op deze manier volstaat één enkele query om een hele object, en zijn relaties op te vragen. 

	Een extreem voordeel van het document model is dat het geen restricties oplegt aan de data. Er kunnen twee producten zijn die in het systeem herkent worden als "Product" maar een andere interne structuur hebben. Het \underline{document model} wordt dus best \underline{gekenmerkt door}:
	\begin{itemize}
		\item Flexibiliteit in het schemamodel. Dit wordt ook wel "schema-on-read" genoemd aangezien de cliënt niet op voorhand kan weten welke structuur het document zal hebben.
		\item Data lokaliteit. Hiermee wordt bedoeld dat een document als één enkelvoudige string wordt opgeslagen, en alle informatie zit dan ook in die string. Er is geen nood aan het join-of indexeringmechanisme. Een document wordt altijd in zijn geheel ingelezen, dit kan een nadeel zijn indien slechts een beperkt aantal informatie van dat document nodig is.
	\end{itemize}

	\section{Het graaf model}
	Het document model volstaat voor one-to-many relaties, maar is niet perfect voor \underline{many-to-many} of \underline{many-to-one relaties} want dan moeten er toch "joins" gedaan worden, maar dan op documenten. Het graaf model kent twee soorten:
	\begin{enumerate}
		\item Een normale graaf met knopen en verbindingen, die beiden attributen kunnen hebben.
		\item Een drievoudig model waarbij alle informatie opgeslagen wordt als: \texttt{SUBJECT $\rightarrow$ PREDICATE $\rightarrow$ OBJECT}
	\end{enumerate}
	Gekende graafalgoritmen kunnen toegepast worden op dit model. Het \underline{graaf model} heeft een aantal \underline{use cases}:
	\begin{itemize}
		\item \textbf{Transportnetwerk.} Een graaf is de geschikte manier om een wegennet voor te stellen.
		\item \textbf{Linkanalyse.} Het zoeken van objecten die gerelateerd zijn aan een ander object (bv vrienden van vrienden zoeken).
	\end{itemize}

	\section{Het kolomfamilie model}
	\todo{xxx}

	\chapter{Gedistribueerde informatie}
	Waarom is het belangrijk dat informatie op verschillende nodes beschikbaar is?
	\begin{itemize}
		\item \textbf{Schaalbaarheid:} Een toestel heeft maar een maximum aantal geheugen, opslagplaats en schijfoperaties per seconde. Meerdere nodes betekent dat de belasting kan verdeeld worden tussen de nodes.
		\item \textbf{Fouttolerantie:} Een reverse voorzien voor in het geval dat een andere node uitvalt.
		\item \textbf{Latency:} Nodes geografisch verspreiden zodat connecties vanuit andere continenten niet traag zijn.
	\end{itemize}
	Er wordt best gebruik gemaakt van het \underline{horizontaal schaalschema}. Dit heeft als voordeel dat er geen speciale hardware vereist is, en er gewoon machines kunnen bijgekocht worden indien dit nodig zou zijn.

	Er zijn \underline{twee belangrijke patronen} om data de distribueren:
	\begin{enumerate}
		\item \textbf{Replicatie:} Dit is eenvoudig alle data dupliceren op elke verschillende node, zodat ze allemaal dezelfde data bevatten. De \underline{voordelen} zijn: hoge databeschikbaarheid en fouttolerantietegen het uitvallen van een node door de redundantie van de informatie. Het \underline{nadeel} is: hoe moeten we ervoor zorgen dat alle nodes over dezelfde data beschikken (zie sectie \ref{sec:replicatie})? 
		\item \textbf{Partitionering (sharding):} De grote hoeveelheid data kan ook gepartitioneerd worden, zodat elke node zijn unieke verzameling van gegevens bevat. Partitionering heeft een aantal \underline{voordelen}: Elke partitie moet slechts zijn beperkte data behandelen. Hoe groter de dataset wordt, hoe minder operaties een bepaalde partitie zal moeten uitvoeren, aangezien er meer patitities zullen ingevoerd worden zodat de data meer verspreidt ligt over alle partities. Het \underline{nadeel} is: hoe kunnen we bepalen op welke node een bepaald stukje informatie moet komen. Idealiter heeft elke node dezelfde workload.
	\end{enumerate}
	In praktijk worden replicatie en partitionering gecombineerd. Eerst wordt partitionering toegepast, waarna deze partities ook nog gerepliceerd worden.

	\section{Replicatie}
	\label{sec:replicatie}
	Er zijn \underline{twee modellen} om aan replicatie te doen: het leader-follow model en het leaderless model. Een node die repliceerd wordt een replica genoemd.
	\subsection{Leader-Follower model}
	Dit model verloopt in drie stappen:
	\begin{enumerate}
		\item Een replica wordt tot leader gemaakt. Enkel op deze replica mogen er writeoperaties plaatsvinden.
		\item Elke andere replica is een follower. Elke keer dat de leader naar zijn schijf schrijft, zal de leader ook de gewijzigde data doorsturen, in de vorm van een \underline{replication log}, naar alle followers. Deze replication log bevat instructies dat elke follower moet ondernemen zodat ze de update juist kunnen uitvoeren.
		\item Een cliënt kan een readoperatie zowel aan de leader als aan een follower aanvragen. 
	\end{enumerate}
	Deze manier garandueerd dat de followers \underline{ooit zullen convergeren} naar de juiste toestand.
	\subsection{Leaderless model}
\end{document}
