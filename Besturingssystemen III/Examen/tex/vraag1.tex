\chapter{Modelvragen theorie: reeks A}
	Het examen wordt \accentuate{volledig schriftelijk} beantwoord. Indien de student dit wenst, wordt het antwoord onmiddellijk na indienen geëvalueerd, en eventueel gevolgd door enkele vragen ter verduidelijking of aanvulling.
	
	
	\section{Structuur van Active Directory gegevens}
	\begin{enumerate}
		\vraag { Bespreek de \textit{diverse namen} die alle Active Directory objecten \textit{identificeren}. \accentuate{\textsection 2.2.1} } 
		{ 
			\begin{itemize}
				\item \textbf{Relative distinguished name (RDN).} Dit is een identificatie van een object \textbf{binnen} een \textbf{containerobject}. Een RDN moet dus \textbf{niet uniek} zijn op Active Directory niveau. Dit wordt opgeslagen in het attribuut \textbf{cn}.
				
				\item \textbf{Distinguished name.} Deze \textbf{unieke} identificatie wordt opgebouwd uit de RDN van het object zelf en van alle RDNs waarvan het object hiërarchisch deel uitmaakt. Dit wordt opgeslagen in het attribuut \textbf{distinguishedName}
				
				\item \textbf{Canonieke naam.} Dit heeft dezelfde functie als een distinguished name, maar heeft een eenvoudigere representatie. Dit wordt opgeslagen in het attribuut \textbf{canonicalName}
				
				\item \textbf{GUID.} Elk object heeft een \textbf{unieke} GUID. Dit is een 128-bit getal dat niet kan gewijzigd worden. Een GUID wordt aangemaakt bij de \textbf{creatie} van een object en kan dan \textbf{niet meer aangepast} worden. Dit wordt opgeslagen in het attribuut \textbf{objectGUID}.
			\end{itemize}
			
		}	
		\vraag { Wat zijn \textit{SPN objecten}? Bespreek de \textit{aanvullende naamgeving} voor deze objecten. \accentuate{ (\textsection 2.2.2)} } { 
			\textbf{Security Principal Objects (SPN)} zijn objecten die \textbf{security IDs (SIDs)} bevatten. Dergelijke objecten worden gebruikt voor het verlenen van toegang tot domeinbronnen en zijn daarom van toepassing op gebruikersaccounts, computeraccounts, groepen en domeinen. Een SID is net zoals een GUID uniek binnen een forest voor elk nieuw aangemaakt object. Bij het verplaatsen en hernoemen binnen hetzelfde domein blijven de GUID en SID behouden van een SPN object. Indien het object naar een andere domein verplaatst wordt, zal enkel GUID hetzelfde blijven. Hierbij wordt het \textbf{sIDHistory} attribuut aangevuld met het vorige SID.	De aanvullende naamgeving voor deze objecten zijn:

			\begin{itemize}
				\item Een \textbf{gebruikersaccount} heeft nood aan een extra identificatieattribuut om inlogprocedures door een gebruiker te vereenvoudigen. Een \textbf{User Principal Name (UPN)} is een vereenvoudigde waarde (loginnaam) dat uitsluitend gebruikt wordt voor aanmelding. Verder moet een UPN uniek zijn binnen het hele forest en heeft standaard de volgende vorm:
				$$\texttt{RDN@UPNsuffix}$$
				Hierbij is RDN de RDN van de gebruiker en UPNsuffix één van de volgende alternatieven:
				\begin{itemize}
					\item De DNS domeinnaam waarin het gebruikersaccount zich bevindt.
					\item De DNS domeinnaam van het root domein.
					\item Een willekeurige maar een op voorhand gedefinieerde naam.
				\end{itemize}

				Er bestaat ook een alternatieve vorm, om compatibiliteit met vroegere NT versies te behouden. Men kan de NetBIOS naam van het domein en de SAM accountnaam van de gebruiker, aan elkaar gekoppeld door het \textbackslash-teken te gebruiken.  
				
				\item Een \textbf{computeraccount} bevat drie extra attributen:
				\begin{itemize}
					\item \textbf{SAM accountnaam.} Dit is gelijkaardig aan het UPN attribuut, maar dient voor compatibiliteit met oudere windows systemen (pre 2000). Standaard bestaat deze naam uit de eerste 15 bytes van de RDN, gevolgd door een \$ teken. Deze naam kan op elk moment gewijzigd worden. Deze waarde wordt opgeslagen in het attribuut \textbf{samAccountName}.
					\item \textbf{DNS hostnaam.} Deze waarde bevat standaard de eerste 15 bytes van de RDN en de suffix voor primaire DNS.
					\item \textbf{Service Principal Name.} Dit attribuut wordt gebruikt tijdens de wederzijdse verificatie van client software en de server die een bepaalde service aanbiedt. Het attribuut wordt bepaald door het multi-valued \texttt{servicePrincipalName} kenmerk.
				\end{itemize}
			\end{itemize}
		}
		
		\vraag { Enkele veel gebruikte klassen (hiermee worden \textit{attributeschema} en \textit{classschema} objecten niet bedoeld) vertonen nog meer identificerende attributen voor hun instanties. Bespreek deze klassen en attributen. } { 		
			
		}
		
		\vraag { In welke \textit{partities} is de Active Directory informatie verdeeld? Geef de betekenis van elke partitie, hun onderlinge relatie (zowel fysiek als met betrekking tot hun naamgeving), en de replicatiekarakteristieken ervan. \accentuate{(laatste helft \textsection 2.2.3)} } {
			\begin{itemize}
				\item \textbf{Domeingegevens.} Deze partitie bevat informatie over alle objecten in het domein (servers, bestanden, printers, accounts, ...). Objecten die aangemaakt of gewijzigd zijn, worden steeds opgeslagen in de domeingegevens. In Active Directory kunnen er meerdere domeinen bestaan in een forest. Deze domeinen vormen een boomstructuur met als wortel de domeingegevens van het \textbf{root} domein. 
				
				Domeingegevens van een bepaald domein worden gerepliceerd tussen alle domeincontrollers van enkel dat domein.

				\item \textbf{Configuratiegegevens.} De configuratiegegevens beschrijven de fysieke topologie van de directory. Het bevat ondermeer een lijst van alle domeinstructuren, de locaties van de domeincontrollers en de global catalog controllers, de sites en de replicatietopologie. Er is slechts één configuratiepartitie per forest en geldt voor alle domeincontrollers in dit forest.

				De configuratiegegevens worden gerepliceerd naar alle domeincontrollers in het forest.
				\item \textbf{Het schema.} Deze partitie is de formele definitie van alle objecten en kenmerkgegevens die kunnen opgeslagen worden in de directory. Er is slechts één schemapartitie per forest.

				Het schema wordt gerepliceerd naar alle domeincontrollers in het forest.
				\item \textbf{Applicatiepartitie.} De applicatiepartitie laat toe om een deel van de Active Directory gegevens gescheiden onder te brengen. Indien de DNS gegevens van de domeinen en van het forest geïntegreerd worden in Active Directory, dan worden er respectievelijk \texttt{DomainDNSZones} en \texttt{ForestDNSZones} applicatiepartities aangemaakt.
				
				De replicatiestrategie van een applicatiepartie is de enige die dynamisch kan gewijzigd worden, aangezien het ook de enige partitie is dat dynamisch kan aangemaakt worden. De specifieke domeincontrollers instellen die repliceren kan in het \texttt{msDS-NC-Replica-Locations} kenmerk van het overeenkomstige crossref object in de configuratiegegevens. 
			\end{itemize}
			
		}
	\end{enumerate}
	
	\section{attributeSchema objecten \accentuate{ (\textsection 2.2.4 en \textsection 2.2.5)}}
	\begin{enumerate}
		\vraag { Bespreek het \textit{doel} en de \textit{werking} van attributeSchema objecten. Hoe kunnen deze objecten het best \textit{geraadpleegd} en \textit{gewijzigd} worden? } { 
			\begin{itemize}
				\item Het attributeSchema bevat alle kenmerken die in het schema voorkomen. Een kenmerk is zelf een object. Zo een kenmerk wordt éénmaal gedefinieerd en kan meerdere malen gebruikt worden bij verschillende klassen, wat voor consistentie zorgt. Een goed voorbeeld hiervan is het description kenmerk. Om op een eenvoudige manier objecten te raadplegen of wijzigen, kan men met het schema snap-in mechanisme werken. \textbf{Active Directory Schema} is zo een snap-in, dat eenvoudig in twee vensters zowel de kenmerken als de klassen weergeeft. Dubbelklikken op een item geeft de meest relevante eigenschappen van het object, en de mogelijkheid om deze in te stellen. Er kan ook gebruikt gemaakt worden van de opdracht \textbf{dsquery *}. Deze opdracht kan om het even welke kenmerken tonen van één enkel object, of van alle objecten in een container, zowel niet-recursief als recursief.
			\end{itemize}
		}
		
		\vraag { Bespreek de \textit{diverse naamgevingen}, specifiek voor attributeSchema objecten. } { 
			\begin{itemize}
				\item \textbf{cn}: De RDN van het attributeSchema object in de Schema container.
				\item \textbf{schemaIDGUID}: Dit kan automatisch gegenereerd worden bij de creatie van een nieuw kenmerk. Een attribuut krijgt dan wel een verschillende GUID in verschillende forests. Manueel een GUID instellen kan ook, met bv de \textbf{guidgen} of \textbf{uuidgen} opdrachten.
				\item \textbf{lDAPDisplayName}: De naam die gebruikt wordt voor LDAP. Deze naam is belangrijk voor programmatische toegang.
				\item \textbf{attributeID}: De interne representatie van een object. Deze identifiers worden verleend door specialie autoriteiten, en zijn gegarandeerd uniek in alle netwerken over de hele wereld. Een Object Identifier bestaat uit een decimale reeks met punten, waarbij de toekenning op een hiërarchische manier gebeurd. Een Object Identifier kan aangevraagd worden bij een regionale ISO vertegenwoordiger. Indien dit niet gewenst is, kan er ook een Object Identifier gegenereerd worden in een Microsoft subtak, met behulp van de opdracht \textbf{oidgen}.
			\end{itemize}
		}
		
		\vraag { Bespreek de belangrijkste \textit{kenmerken} van attributeSchema objecten, en op welke waarden die ingesteld kunnen worden. } { 
			\begin{itemize}
				\item \textbf{attributeSyntax en oMSyntax}: De syntax bepaalt het data type zoals: Object ID, Boolean, Integer, DirectoryString zijn enkele van de 26 mogelijkheden. Slechts 18 van deze 26 worden momenteel gebruikt in Active Directory. Het is \textbf{onmogelijk} om een nieuwe syntax te definieëren. Het object ID van een syntax wordt geïdentificeerd in de vorm van 2.5.5.x . Sommige Object Identifiers zijn blijkbaar niet te onderscheiden, waarop beroep moet gedaan worden op een bijkomende Integer waarde: mOSyntax.
				\item \textbf{rangeLower en rangeUpper}: Bepalen de lengte- of bereikbeperkingen van kenmerken.
				\item \textbf{isSingleValued}: Geeft aan of een attribuut meerdere waarden kan bevatten (een lijst).
				\item \textbf{searchFlags}: Dit veld bevat binaire informatie, waarbij elke afzonderlijke bit kan ingesteld worden. Veronderstel de vorm ${\color{red}b_{10}}b_9{\color{red}b_8}b_7{\color{red}b_6b_5b_4b_3b_2b_1}$, dan betekent elke bit het volgende:
				\begin{itemize}
					\item \textbf{$b_1$}: Deze wordt meestal gezet, zodat eenvoudige indexering van de waarde van het kenmerk geactiveerd wordt, ongeacht van waar het object zich in Active Directory bevindt.
					\item \textbf{$b_2$}: Indien deze gezet wordt, wordt de waarde van het kenmerk gecombineerd met de identificatie van de container waarin het object zich bevindt. Dit heet een containerized index, en zijn in staat om snel objecten op te sporen in een specifieke container.
					\item \textbf{$b_3$}: Dit laat Ambiguous Name Resolution toe. Bij opzoekingen van kenmerken waaraan een bepaalde waarde voldaan moet worden, kan i.p.v.  $$(\mid(kenmerk1=waarde)(kenmerk2=waarde)(kenmerk3=waarde)...)$$ het eenvoudigere $$(anr=waarde)$$ gebruikt worden. 
					\item \textbf{$b_5$}: Deze bit heeft niets met indexering te maken, maar geeft aan of de waarde van een attribuut behouden blijft bij het maken van een kopie van dit object.
					\item \textbf{$b_6$}: Deze bit instellen versnelt opzoekingen waarin kenmerken met wildcards vermeld worden. Deze tuple indexen worden best zeldzaam gebruikt, aangezien ze veel resources in beslag nemen.
					\item \textbf{$b_8$}: \accentuate{(staat niets over in de cursus)}
					\item \textbf{$b_{10}$}: \accentuate{(staat niets over in de cursus)}
				\end{itemize}
				\item \textbf{systemFlags}: Dit heeft dezelfde vorm als searchFlags, een binair formaat ${\color{red}b_{28}}...{\color{red}b_{5}}b_{4}{\color{red}b_3b_2b_1}$ waarvan de bits het volgende betekenen:
				\begin{itemize}
					\item \textbf{$b_1$}: Deze bit geeft aan of dat het kenmerk gerepliceerd mag worden naar andere domeincontrollers of niet. Attributen die vaak wijzigen zoals lastLogOn en lastLogOff worden niet gerepliceerd.
					\item \textbf{$b_3$}: Dit geeft aan of een attribuut geconstrueerd is of niet. Een dergerlijk attribuut wordt niet opgeslagen in Active Directory, maar wordt telkens opnieuw berekend op basis van andere kenmerken.
					\item \textbf{$b_5$}: Geeft aan of dat het attribuut een systeemobject is.
					\item \textbf{$b_{28}$}:Geeft aan dat de naam van het object al dan niet gewijzigd kan worden. 
				\end{itemize}
				\item \textbf{isMemberOfPartialAttributeSet}: Bepaalt of een attribuut in de global catalog wordt opgenomen of niet.
				\item \textbf{linkID}: Een getal dat aangeeft dat het attribuut een gelinkt attribuut is. Een even getal duidt op een forward-link en het sequentieel daaropvolgend oneven getal duidt op de corresponderende back-link. Dergerlijke linkIDs laten toe om n-tot-n en n-tot-1 relaties te definiëren zoals de member en memberof, alsook de managedBy en managedObjects attributen. 
			\end{itemize}
		}
		
		\vraag { Welke andere types objecten bevat het \textit{Active Directory schema}, en wat is hun bedoeling? \accentuate{ (o.a. \textsection 2.2.7)} } {
			\begin{itemize}
				\item \textbf{subSchema:} Er is slechts één object die behoort tot de klasse subSchema, Aggregate. Dit object bevat een alternatieve, compacte representatie van het gehele schema en wordt het abstracte schema genoemd. De bedoeling is om vereenvoudigde schema gegevens ter beschikking te stellen aan LDAP clients, zonder dat die zich om veel implementatie details hoeven te bekommeren. Voor elk classSchema en attribuutSchema object biedt het abstracte schema slechts enkele kenmerken aan. 
				\item \textbf{classSchema:} Voor elke klasse is er een classSchema object waarmee de klasse kan ingesteld worden. De kenmerken van classSchema objecten definiëren de klasse, en bevatten twee soorten regels: met structuurregels worden mogelijke hiërarchische relaties tussen klassen of objecten gedefinieerd, terwijl met inhoudsregels kenmerken definiëren die beschikbaar zijn voor een exemplaar van die klasse.
			\end{itemize}
		}
		
		\vraag { Via welke attributen kun je de \textit{klasse} van een willekeurig Active Directory object achterhalen? Hoe moet je op zoek gaan naar alle objecten van een bepaalde klasse? Illustreer aan de hand van relevante voorbeelden. \accentuate{ (laatste paragraaf \textsection 2.2.6)} } { 
			\begin{itemize}
				\item \textbf{objectClass:} Het attribuut objectClass is multi-valued en niet geïndexeerd en bevat niet enkel de klasse zelf, maar ook alle hiërarchische superklassen. Voor printQueue, user en computer is objectClass ingevuld met respectievelijk \{printQueue, connectionPoint, leaf, top\}, \{user, organizationalPerson, person, top\} en \{computer, user, organizationalPerson, person, top\}. 
				\item  \textbf{objectCategory:} Het kenmerk objectCategory is single-valued en wordt geïndexeerd. Het bevat echter niet noodzakelijk de klasse van het object, maar bevat de meest typische vertegenwoordiger voor die klasse. Voor printQueue, user en computer is objectCategory respectievelijk printQueue, person en computer.
			\end{itemize}	
		
			Het opzoeken van alle objecten kan zowel via \textit{objectClass} als  \textit{objectCategory}. Het is soms niet evident wanneer wat moet gebruikt worden. Voor het opzoeken van printers is de selecte van objecten waarvoor de \textit{objectCategory} ingesteld is op \textit{printQueue}, duidelijk de beste keuze, aangezien dit de opzoeking toelaat om op indexering een beroep te doen. Om gebruikers op te zoeken zou de objecten waarvan \textit{objectCategory} gelijkgesteld is aan \textit{person} kunnen gefiltered worden. Dit heeft echter als nadeel dat ook objecten met klasse \textit{contact} teruggegeven worden. Er kan dan besloten worden om niet \textit{objectCategory} te gebruiken, maar objecten te selecteren waarvan \textit{user} tot de \textit{objectClass} behoort. Dit heeft weeral het vervelende effect dat objecten met klasse \textit{computer} ook geselecteerd worden. De juiste objecten kunnen gezocht worden door de combinatie waarvoor zowel de \textit{objectCategory} ingesteld is op \textit{person}, als \textit{user} tot de \textit{objectClass} behoort.
		}
	\end{enumerate}
	
	\section{classSchema objecten \accentuate{ (\textsection 2.2.4 en \textsection 2.2.6)}}
	\begin{enumerate}
		\vraag { Bespreek het \textit{doel} en de \textit{werking} van classSchema objecten. } { 
			\begin{itemize}
				\item Voor elke klasse is er een classSchema object waarmee de klasse kan ingesteld worden. De kenmerken van classSchema objecten definiëren de klasse, en bevatten twee soorten regels: met structuurregels worden mogelijke hiërarchische relaties tussen klassen of objecten gedefinieerd, terwijl met inhoudsregels kenmerken definiëren die beschikbaar zijn voor een exemplaar van die klasse.
			\end{itemize}	
		}
		
		\vraag { Hoe benadert Active Directory het mechanisme van \textit{overerving}? } {
			\begin{itemize}
				\item Een klasse die een andere klasse (de superklasse) overeft, neemt de kenmerken van deze superklasse over, inclusief de structuurregels en de inhoudsregels. Deze overerving werkt recursief: de subklasse erft alle gegevens van opeenvolgende superklassen. Een klasse kan echter maar van één superklasse overerven, en eventueel van speciaal hiervoor bestemde hulpklassen, die zelf geen instanties kunnen bevatten. Vanaf Windows Server 2003 is het mogelijk om dynamische objecten te definiëren. Hierdoor is het mogelijk om hulpklassen dynamisch te gebruiken: tijdens de create van een object kunnen extra dynamische hulpklassen gegenereerd worden, die enkel voor die instantie geldig zijn, door aanvullingen van het objectClass attribuut. Na de creatie kan dit attribuut niet meer gewijzigd worden.

				Het kenmerk \texttt{objectClassCategory} geeft de categorie van de klasse aan: structurele klasse, abstracte klasse en hulpklasse. Er kunnen geen instanties aangemaakt worden van een abstracte klasse, maar ze bevatten wel een verzameling kenmerken die door subklassen die van de klasse afgeleid zijn, overgeërfd worden. 

				De hiërarchische relaties tussen objecten van klassen wordt gedefinieerd in de kenmerken \texttt{possSuperiors} en \texttt{systemPossSuperiors}. 
			\end{itemize}	
		}
		
		\vraag { Bespreek de diverse \textit{naamgevingen}, specifiek voor classSchema objecten. } { 
			\accentuate{komt overeen met vraag 1.2.2, maar enkel de naamgeving is anders}
			\begin{itemize}
				\item \textbf{cn}: De RDN van het classSchema object in de Schema container.
				\item \textbf{schemaIDGUID}: Dit kan automatisch gegenereerd worden bij de creatie van een nieuw kenmerk. Een klasse krijgt dan wel een verschillende GUID in verschillende forests. Manueel een GUID instellen kan ook, met bv de \textbf{guidgen} of \textbf{uuidgen} opdrachten.
				\item \textbf{lDAPDisplayName}: De naam die gebruikt wordt voor LDAP. Deze naam is belangrijk voor programmatische toegang.
				\item \textbf{governsID}: De interne representatie van een object. Deze identifiers worden verleend door specialie autoriteiten, en zijn gegarandeerd uniek in alle netwerken over de hele wereld. Een Object Identifier bestaat uit een decimale reeks met punten, waarbij de toekenning op een hiërarchische manier gebeurd. Een Object Identifier kan aangevraagd worden bij een regionale ISO vertegenwoordiger. Indien dit niet gewenst is, kan er ook een Object Identifier gegenereerd worden in een Microsoft subtak, met behulp van de opdracht \textbf{oidgen}.
			\end{itemize}
		}
		
		\vraag { Bespreek de belangrijkste \textit{kenmerken} van classSchema objecten, en op welke waarden die ingesteld kunnen worden. } { 
			\begin{itemize}
				\item \textbf{rDNAttID:} bepaalt welk kenmerk van een klasse gebruikt wordt om de RDN van objecten te bepalen. Vaak gebruikte waarden zijn: cn (Common-Name), ou (Organizational-Unit-Name), dc (Domain-Component), o (Organization-Name), c (Country-Name) of l (Locality-Name).
				\item \textbf{(system)mustContain, (system)mayContain:} Deze vier attributen specificeren welke kenmerken optioneel zijn en welke verplicht ingevuld moeten worden. Voor een kenmerk dat overgeërfd is, en verplicht is, kan het kenmerk niet optioneel gemaakt worden, ook al staat in de subklasse dit kenmerk bij \texttt{(system)mayContain}. De prefix \texttt{system} duidt op de lijst van attributen die enkel door Active Directory zelf kunnen gewijzigd kunnen worden. 
				\item \textbf{defaultSecurityDescriptor:} bepaalt de explicitiete machtigingen die gelden voor objecten van deze klassen.
				\item \textbf{systemOnly:} Indien deze bit aanstaat, kunnen de structuurregels en inhoudsregels van de klasse niet gewijzigd worden.
				\item \textbf{systemFlags:} Kan twee belangrijke bits bevatten:
					\begin{itemize}
						\item bit 5: geeft aan of dat de klasse een systeemklasse is of niet.
						\item bit 28: geeft aan of dat de naam van de klasse mag gewijzigd worden.
					\end{itemize}
				\item \textbf{objectClass:} een multi-valued en niet geïndexeerd kenmerk. Het bevat niet alleen de klasse van het object zelf, maar ook alle hiërarchische superklassen.
				\item \textbf{objectCategory:} is single-valued en wordt geïndexeerd. De waarde van dit kenmerk bevat de meest typische vertegenwoordiger uit de verzameling van het objectClass kenmerk.
				\item \textbf{isDefunct:} duidt aan of al dan niet instanties van de klasse aangemaakt mogen worden.
			\end{itemize}	
		}
		
		\vraag { Welke andere types objecten bevat het \textit{Active Directory schema}, en wat is hun bedoeling? \accentuate{ (o.a. \textsection 2.2.7)} } 
		{ 
			\begin{itemize}
				\item \textbf{subSchema:} er is slechts één object die behoort tot de klasse subSchema, Aggregate. Dit object bevat een alternatieve, compactie representatie van het gehele schema en wordt het abstracte schema genoemd. De bedoeling is om vereenvoudigde schema gegevens ter beschikking te stellen aan LDAP cliënts, zonder dat die zich om veel implementatie details hoeven te bekommeren. Voor elk classSchema en attribuutSchema object biedt het abstracte schema slechts enkele kenmerken aan. 
				\item \textbf{attributeSchema:} Het attributeSchema bevat alle kenmerken die in het schema voorkomen. Een kenmerk is zelf een object. Zo een kenmerk wordt éénmaal gedefinieerd en kan meerdere malen gebruikt worden bij verschillende klassen, wat voor consistentie zorgt.
			\end{itemize}
		}
		
		\vraag { Hoe en met welke middelen kan het Active Directory schema uitgebreid worden? Waarom moet je en hoe kan je hierbij \textit{voorzichtig} te werk gaan? \accentuate{ (o.a. \textsection 2.2.8, ldifde fractie \textsection 2.2.3)} } { 
			\begin{itemize}
				\item Wanneer onvoorzichtig uitbreidingen aan het schema worden toegevoegd, kan dit nefaste gevolgen hebben op domein en forestniveau. Een domein kan beschadigd geraken of zelfs uitschakelen. Bovendien gelden de wijzigingen voor het gehele forest.
				
				De veiligste manier om uitbreidingen op het schema te ontwikkelen en uit te testen is een geïsoleerd netwerk van een testomgeving. Bovendien worden schemaobjecten beveiligd door Access Control Lists, zodat enkel gemachtigde gebruikers aanpassingen kunnen doen. Verder kunnen ook nog volgende richtlijnen gehanteerd worden:
				\begin{itemize}
					\item Vermijdt het wijzigen van de attributen van een bestaande klasse.
					\item Maak enkel een nieuwe structurele klasse (een subklasse van de superklasse Top) aan als er geen enkel ander object enigszins aan de behoeften voldoet.
				\end{itemize}
				
				Een schema uitbreiden heeft echter veel potentieel. De aanbevolen manier om het Active Directory op grote schaal uit te breiden is via de \textbf{ldifde} opdracht, aangezien één ldifde inputbestand meerdere aanpassingen ineens kan bevatten. Zo een inputbestand heeft als formaat het LDAP Data Interchange Format. Aanpassingen op kleine schaal kunnen eerder gebeuren met de Active Directory Schema snap-in. Om op een veilige manier kenmerken toe te voegen aan objecten, maakt men eerst de kenmerken aan in het attributeSchema, vervolgt door het aanmaken van een hulpklasse die deze kenmerken bevat. De nieuwe hulpklasse kan dan geassocieerd worden met de klasse waaraan de kenmerken moeten toegevoegd worden.
			\end{itemize}
		}
	\end{enumerate}
	
	\section{Active Directory domeinstructuren \accentuate{(§2.4.4, laatste paragraaf §2.4.5 en §2.4.6)}}
	\begin{enumerate}
		\vraag { Wat is de bedoeling van \textit{vertrouwensrelaties}? } {
			\begin{itemize}
				\item Tussen twee domeinen kan er een vertrouwensrelatie tot stand gebracht worden, zodat gebruikers in het vertrouwd domein kunnen geverifieerd worden door de domeincontroller in het vertrouwend domein. Een gebruiker kan slechts domeinbronnen van een ander domein raadplegen indien er een vertrouwenspad bestaat tussen de twee domeinen. Dit wil niet zeggen dat de gebruiker automatisch toegang heeft tot de bronnen in dat domein.
			\end{itemize}
		}
		
		\vraag { Bespreek de verschillende \textit{soorten} vertrouwensrelaties. } { 
			\begin{itemize}
				\item \textbf{Automatische vertrouwensrelaties.}
				\begin{itemize}
					\item  Windows Server maakt automatisch vertrouwensrelaties aan tussen domeinen en hun kinddomeinen bij creatie. Deze automatische vertrouwensrelaties kunnen niet verbroken worden en zijn bovendien bi-directioneel en transitief. Windows Server maakt ook automatisch vertrouwensrelaties aan tussen de trees van eenzelfde forest: de root domeinen van alle trees in het forest vormen transitieve vertrouwensrelaties met het forest root domein van het forest. Een domein dat nieuw aangemaakt wordt in een tree of een forest heeft, door de transitieve eigenschap, automatisch vertrouwensrelaties met alle andere Windows Server domeinen in de tree of het forest.
				\end{itemize}
				\item \textbf{Expliciete vertrouwensrelaties.}
				\begin{itemize}
					\item \textbf{Forest vertrouwensrelatie.} Indien de diverse forests minimaal Windows Server 2003 functioneel niveau hebben, dan kunnen er een bi-directionele en transitieve vertrouwensrelaties tussen de root-domeinen van deze forests gelegd worden. 
					\item \textbf{Realm vertrouwensrelatie.} Dit is een veralgemening van een forest vertrouwensrelatie. Deze relatie kan gelegd worden tussen een Windows Server 2008 domein en een willekeurig kerberos v5 realm, onafhankelijk van het besturingssysteem waarop die geïmplementeerd zijn. 
					\item \textbf{Verkorte vertrouwensrelatie.} Deze enkelvoudige of bi-directionele relatie kan gelegd worden tussen Windows Server domeinen binnen hetzelfde forest. Deze verkorte vertrouwensrelaties kunnen gebruikt worden om het vertrouwenspad in grote en complexe trees korter te maken. Praktisch is dit enkel nuttig indien het vertrouwenspad minstens een vijftal domeinen overspant, en dan uiteraard nog indien er frequent gebruik van gemaakt wordt. 
					\item \textbf{Externe vertrouwensrelatie.} Dit is een enkelvoudige relatie waarbij één domein een ander vertrouwt. Verificatieaanvragen kunnen enkel van het trusting domein naar het trusted domein doorgegeven worden. Om een externe vertrouwensrelatie in twee richtingen te leggen, moeten er twee enkelvoudige relaties gelegd worden. Deze relatie is ook niet transitief.
				\end{itemize}

			\end{itemize}

		}
		
		\vraag { Op welke diverse manieren kunnen vertrouwensrelaties \textit{gecreëerd} en \textit{gecontroleerd} worden? Bespreek ook de \textit{optionele configuratiemogelijkheden}. } { 
			\begin{itemize}
				\item Om een vertrouwensrelatie aan te maken, moet de domeinnamen en gebruikersaccount met machtigingen om vertrouwensrelaties in beide domeinen te maken, beschikbaar zijn. Een vertrouwensrelatie krijgt een wachtwoord toegewezen, dat bekend moet zijn bij de beheerders van beide domeinen van de vertrouwensrelatie. Dit wachtwoord wordt na het opzetten van de vertrouwensrelatie nooit meer gebruikt. Volgende optionele configuratiemogelijkheden bestaan ook:
				\begin{itemize}
					\item \textbf{Selective Authentication.} Standard worden alle gebruikers van het trusted domein opgenomen in de \underline{Authenticated Users} groep van het trusting domein. Via selective Authentication moet dit per individuele gebruiker of gebruikersgroep ingesteld worden.
					\item \textbf{SID Filtering.} Indien SID Filtering aanstaat, wordt enkel rekening gehouden met de SID opgeslagen in het \textit{objectSid} attribuut van de objecten in het trusted domein. Staat dit niet aan, dan verwerkt het trusting domein ook de SIDs opgeslagen in het sIDHistory attribuut.
				\end{itemize}

				\item Vertrouwensrelaties kunnen ook aangemaat worden in een \textit{Command Prompt}, met behulp van de \textbf{netdom trust} opdracht. Om een overzicht te krijgen van alle vertrouwensrelatie en hun toestand, kan gebruik gemaakt worden van de \textbf{netdom query trust} opdracht.
			\end{itemize}
		}
		
		\vraag { Welke verschillen zijn er in praktijk tussen \textit{NT 4.0} en \textit{Windows Server} domeinstructuren? Bespreek onder andere telkens de noodzaak om meerdere domeinen in te voeren. Bespreek de alternatieve mogelijkheden bij de \textit{conversie van een NT 4.0 domeinstructuur} naar een Windows Server omgeving. } { \todo{Oplossen}}
	\end{enumerate}
	
	\section{Active Directory server rollen \accentuate{(§2.4.7, §2.3 en fractie §2.4.2)}}
	Welke vragen moet men zich stellen na de initiële installatie van een Windows Server toestel, in verband met \textit{bijzondere functies} die de server kan vervullen met betrekking tot Active Directory? Formuleer bij het beantwoorden van deze vragen telkens (voor zover relevant): 
	\begin{itemize}
		\item  Hoe bepaald wordt \textit{welke servers} een dergelijke specifieke functie vervullen? \textit{Hoeveel} zijn er nodig (in termen van: \textit{minimaal/exact/maximaal} \#, \textit{in functie van} ...), en waarom?
		\item  \textit{Eigenschappen} zoals bedoeling, noodzaak, kriticiteit, inhoud, synchronisatie, voor welke Windows versie(s) van toepassing, ...? 
		\item  De \textit{eventuele relatie} tussen de diverse functies. Vermeld bijvoorbeeld welke functies al dan niet door dezelfde server \textit{kunnen} vervuld worden, of misschien wel juist wel door dezelfde server \textit{moeten} vervuld worden. 
		\item  Hoe kan achterhaald worden welk(e) toestel(len) de bijzondere functie vervult, en op welke diverse manieren men de \textit{toewijzing} ervan kan instellen, wijzigen en/of ongedaan maken? 
		
		\todo{oplossen}
		
	\end{itemize}	