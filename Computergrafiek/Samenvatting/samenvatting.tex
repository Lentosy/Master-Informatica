\documentclass{report}

\usepackage{ugentstyle}
\usepackage{amsmath}



\begin{document}
	\maketitle{Computergrafiek}
	\tableofcontents
	
	\part{Theorie}
	\chapter{Rastering}
	\section{Inleiding}
	De inhoud van het vak computergrafiek behandelt het realistisch voorstellen van 3D objecten op een 2D uitvoerbeeld zoals een scherm of een blad papier (via een printer). Er zijn vier fasen in dit proces:
	\begin{itemize}
		\item \textbf{CAGD en NURBS}: Het beschrijven van een willekeurige kromme met zo weinig mogelijk parameters. De studie naar dit soort wiskundige stelsels wordt Computer Aided Geometric Design genoemd.
		\item \textbf{Rendering}: Het realistisch voorstellen van deze beschrijven van objecten, onafhankelijk van de plaats en kijkrichting van een virtuele waarnemer.
		\item \textbf{Perspectieve projectie}: Het transformeren en projecteren van de 3D structuur naar 2D opstelling.
		\item \textbf{Rastering}: Het selecteren van de juiste pixels die het best overeenkomen met deze 2D opstelling. 
	\end{itemize}

	\section{Rastering van rechte lijnen}
	Rastering is het proces om de juiste pixels te selecteren die het best overeenkomen met een bepaalde voorstelling. Dit proces wordt uitgevoerd door de uitvoercontroller van een grafische kaart. Een aandachtspunt van zo een grafische kaart is dat het moeilijk met floating point getallen kan werken, dus zullen algoritmen die enkel met gehele getallen werken de voorkeur krijgen. Volgende secties bespreken enkele algoritmen om een rechte lijn van 1 pixel dik voor te stellen. Uiteraard is voor elk algoritme vereist dat een begin en eindpunt bekend is.
	\subsection{Midpoint Subdivision}
	Dit is een recursieve methode die het midden van het fictieve lijnstuk neemt en de pixel selecteert die er het dichtste bij ligt. Daarna wordt deze procedure opnieuw uitgevoerd voor de twee helften van dit lijnstuk.
	
	\subsubsection{Voordelen}
	\begin{itemize}
		\item Eenvoudig te implementeren
	\end{itemize}
	\subsubsection{Nadelen}
	\begin{itemize}
		\item Naarmate de hoek van de rechte 45 graden wordt, zal de selectie onregelmatig en dunner worden aangezien er voor dezelfde x-waarde meerdere y-waarden, en voor dezelfde y-waarde meerdere x-waarden mogelijk zijn.
		\item Dit algoritme werkt volledig met reële getallen.
	\end{itemize}
	
	\subsection{Assymetrische DDA}
	DDA staat voor Digital Differential Analyzer. Dit soort algoritmen poogt het aantal reële getallen tot een minimum te beperken.
	Dit algoritme loopt het lijnstuk af met een stapgrootte van 1 pixel. Na elke step wordt de pixel die het dichtst bij het lijnstuk ligt, geselecteerd.
	\subsubsection{Voordelen}
	\begin{itemize}
		\item Vereist minder stappen dan de symmetrische variant.
		\item Het produceert een regelmatig patroon.
	\end{itemize}
	\subsubsection{Nadelen}
	\begin{itemize}
		\item Lijnen worden te dun getekend indien de hoek van de rechte 45 graden nadert.
		\item Dit algoritme gebruikt nog altijd floating point bewerkingen.
	\end{itemize}

	\subsection{Symmetrische DDA}
	Dit algoritme loopt ook het lijnstuk af zoals assymetrische DDA, maar de stapgrootte is veel kleiner. Het produceert exact hetzelfde resultaat als Midpoint Subdivision.
	\subsubsection{Voordelen}
	\begin{itemize}
		\item Wanneer de hoek 45 graden nadert, zal het ten opzichte van de assymetrische variant, een vollere lijn, maar met een minder regelmatig patroon selecteren.
	\end{itemize}
	\subsubsection{Nadelen}
	\begin{itemize}
		\item Sommige pixels worden meerdere keren geselecteerd aangezien de stapgrootte kleiner is als een pixel.
		\item Dit algoritme gebruikt nog altijd floating point bewerkingen.
	\end{itemize}

	\subsection{Kwadrant DDA}
	Dit algoritme verhoogt ook de incrementen met 1 pixel, maar enkel in de x \textbf{of} y richting, nooit in beide richtingen tegelijk. Indien de vorige pixel boven de ideale lijn zit, zal x met 1 verhoogd worden. Als de vorige pixel onder de ideale lijn zit, zal y met 1 verhoogd worden. Het algoritme maakt gebruik van een discriminant $\Delta$, die best ingesteld wordt op $\{(x_2 - x_1) - (y_2 - y_1)\}/2$. Op basis van $\Delta$ wordt er beslist of er naar rechts of boven geselecteerd moet worden. Indien $\Delta$ positief is, bevindt de pixel benadering zich te veel in de y-richting en wordt de nieuwe pixel in de x-richting getekend, en kan $\Delta$ verminderd worden met $(y_2 - y_1)$. Analoog, als $\Delta$ negatief is wordt de lijn verder getekend in de y-richting, en $\Delta$ verhoogd met $(x_2 - x_1)$.
	\subsubsection{Voordelen}
	\begin{itemize}
		\item Dit algoritme vermijdt floating point getallen door de afstand van een pixel tot het lijnstuk te vermenigvuldigen met een factor. \todo{welke factor}
	\end{itemize}

	\subsubsection{Nadelen}
	\begin{itemize}
		\item Naarmate de hoek 45 graden nadert wordt de lijn \textbf{te dik} getekend aangezien de helft van de beslissingen naar boven selecteert, en de andere helft naar rechts.
		\item Een foute initialisatie van $\Delta$ kan ervoor zorgen dat pixels onterecht opschuiven.
	\end{itemize}

	\subsection{Octant DDA}
	Dit algoritme verfijnt kwadrant DDA door overlappingen te vermijden. Dit wordt gerealiseerd door ook diagonele selecties toe te staan. Dit algoritme produceert nagenoeg hetzelfde resultaat als assymetrische DDA.
	\subsubsection{Voordelen}
	\begin{itemize}
		\item Maakt geen gebruik van reële getallen.
	\end{itemize}
		\subsubsection{Nadelen}
	\begin{itemize}
		\item Naarmate de hoek 45 graden nadert wordt de lijn \textbf{te dun} getekend.
	\end{itemize}
	
	\subsection{Multistep DDA}
	\texttt{Moet niet gekend zijn}	
	\newline	
	
	\setlength{\parindent}{0cm} Dit algoritme probeert de snelheid van vorige algoritmen te optimaliseren, en heeft geen bijdrage tot het bijsturen van de output, ten opzichte van kwadrant DDA. Bij elke iteratie worden nu meerdere pixels geselecteerd in plaats van slechts één pixel. Een voorbeeld van zo een algoritme is double-step DDA. Dit algoritme bepaalt in één stap twee opeenvolgende pixels waardoor er keuze bestaat tussen vier patronen. In werkelijkheid levert dit algoritme een verhoogde prestatie van ongeveer 10\% en zorgt er dan ook voor dat single-step methoden zelden gebruikt worden.
	
	
	\section{Rastering van cirkels}
	Het algoritme dat gebruikt wordt om cirkels te rasteren wordt doorgaans het \textit{algoritme van Bresenham} genoemd. Dit algoritme is in staat om een volledige cirkel met straal R te rasteren op basis van enkel de cirkelsector met beginpunt (0, R) en eindpunt ($\frac{R}{\sqrt{2}}$, $\frac{R}{\sqrt{2}}$), wat overeenkomt met $1/8$ van de totale oppervlakte van de cirkel. De andere sectoren kunnen inmiddels via symmetrie bekomen worden.
	
	
	In elke iteratie wordt de x-waarde van de pixel verhoogd met 1. De verandering van de y-waarde is verbonden aan een voorwaarde die afhangt van een discriminant $\Delta_i$. Deze wordt gedefinieerd als het verschil van de kwadraten van de afstanden van $y_{i-1} (S_i)$ en $y_{i-1} - 1 (T_i)$ tot de cirkel.
	

	\begin{equation*}
	\begin{split}
			\Delta_i & = \bigg[(x_{i - 1} + 1)^2 + y_{i - 1}^2 - R^2\bigg] - \bigg[R^2 -(x_{i - 1} + 1)^2 - (y_{i - 1} - 1)^2\bigg] \\
					   & = 2(x_{i - 1} + 1)^2 + y_{i - 1}^2 + (y_{i - 1} - 1)^2 - 2R^2
	\end{split}
	\end{equation*}
	Indien $\Delta_i > 0$, dan wordt $T_i$ geselecteerd, anders $S_i$. De discriminant bij een volgende iteratie $\Delta_{i + 4}$ kan uit $\Delta_i$ berekend worden:
	
	\begin{equation*}
	\begin{split}
		\Delta_{i + 1} & = 2(x_{i - 1} + 2)^2 + y_{i}^2 + (y_{i - 1} - 1)^2 - 2R^2 \\
					   & = \Delta_i + 4x_{i - 1} + 6 + y_i^2 - y_{i - 2}^2 + (y_i - 1)^2 - (y_{i-1} - 1)^2 \\
					   & = \begin{split}
					   \Delta_i + 4x_{i - 1} + 6              & \hbox{ als } \Delta_i \leq 0 \\
					   \Delta_i + 4(x_{i - 1} - y_{y - 1}) + 10 & \hbox{ als } \Delta_i > 0
					   \end{split}
	\end{split}
	\end{equation*}
	De initieële waarde van $\Delta_1$ kan bekomen worden door $x_{i - 1} = 0$ en $y_{i - 1}$ = R te substitueren:
	$\Delta_1 = 3 - 2R$. Dit algoritme maakt enkel gehele getallen.
	
	
	\section{Opvullen van veelhoeken}
	Het opvullen van een veelhoek gebeurd via een scanlijn, die zowel horizontaal als verticaal kan zijn. Voor elke x of y-waarde wordt er een lijn getrokken door de veelhoek en gaat men op zoek naar de intersecties, wat altijd een even aantal zal zijn. Alle intersecties met een even index worden opgevuld tot de volgende intersectie met een oneven index. Zonder aanpassingen zullen echter ook pixels geselecteerd worden die buiten de veelhoek liggen. Het algoritme moet aangepast worden zodat enkel inwendige pixels als intersectiepunten kunnen gekozen worden, ook al ligt een uitwendig pixel dichter bij de randlijn.
	
	\section{Voorstellen van dikke lijnen}
	Het verdikken van lijnstukken kan de gebreken van sommige DDA algoritmes maskeren. Er bestaan drie methodes om lijnen te verdikken:
	\begin{enumerate}
		\item \textbf{Replicatie}: Tijdens de selectie van de pixel worden ook nog pixels boven en onder deze pixel geselecteerd, afhankelijk van de op voorhand gespecificeerde dikte.
		\item \textbf{Centreren}: Tijdens de selectie van de pixel wordt er rond deze pixel een vast aantal pixels geselecteerd (bv in de vorm van een vierkant). Dit heeft als nadeel dat pixels opnieuw kunnen geselecteerd worden, ook al zijn ze eerder geselecteerd.
		\item \textbf{Opvulling}: Deze methode past het DDA algoritme tweemaal toe, waarbij het resultaat van deze twee uitvoeringen verschoven zijn. De pixels tussen deze twee objecten kunnen dan geselecteerd worden. Deze methode vraagt nog meer rekenwerk.
	\end{enumerate}

	\section{Antialiasing}
	Aliasing is het gevolg van het feit dat pixels slechts een discreet aantal posities kan innemen, waardoor er kartelingen ontstaan. Antialiasing is het proces om deze kartelingen tegen te gaan. 
	Het antialiasingproces kan volgens twee categorieën gebeuren:
	\begin{enumerate}
		\item \textit{Rastering en antialising gebeurd in twee fasen.} De eerste fase maakt gebruik van een DDA algoritme zoals die reeds besproken zijn. De tweede fase zal pas antialiasing toepassen. Hiervoor zijn er twee manieren:
		\begin{enumerate}
			\item \textbf{Supersampling.} Deze methode gebruikt de vaststelling dat aliasing vermindert indien de resolutie opgedreven zou kunnen worden. Hierdoor wordt de rastering dan ook uitgevoerd in het geheugen van de computer, wat fijner is dan wat de hardware ter beschikking heeft. Elke pixel van een scherm kan bijvoorbeeld overeenkomen met 4, 9, 16 of 25 pixels. De intensiteit van een pixel hangt af van het aantal geheugenpixels dat geselecteerd worden tijdens het rasteringsproces. Deze methode is efficiënt bij het weergeven van opgevulde veelhoeken, maar bij dunne lijnen kan er niet altijd een verbeterend effect zijn.  
			\item \textbf{Postfiltering.} Hier wordt het rasteringsproces normaal uitgevoerd. De antialiasingfase maakt gebruik van een rechthoek rond de huidige geselecteerde pixel. De intensiteit van deze pixel hangt af van de geselecteerde pixels die in deze rechthoek liggen. Hoe groter de rechthoek (3x3, 5x5, ...) hoe groter het effect van antialiasing.
		\end{enumerate}
		\item \textit{Gelijktijdige rastering en antialising.} De rastering en antialiasing gebeurd in éénzelfde stap. Eén van de algoritmen is het \textit{Pitteway-Watkinson algoritme}. \todo{k}
	\end{enumerate}
	\chapter{Transformaties en projecties}
	De computergrafiek maakt gebruik van twee families transformaties: \textit{affiene transformaties} en \textit{perspectieve projecties}. Affiene transformaties zoals rotaties, spiegelingen en translaties zijn belangrijk omdat ze collineariteit en parallellisme bewaren. Een projectie is een bijzondere vorm van een transformatie die toelaat om driedimensionale beelden voor te stellen op tweedimensionale apparaten.
	\section{Affiene 3D Transformaties}
	\subsection{Rotaties}
	Er bestaan drie elementaire rotaties. Een punt met coördinaten (x, y, z) kan geroteerd worden over de drie assen. De afbeelding van deze rotatie krijgt de coördinaten (x', y', z'). Afhankelijk van de gebruikte rotatieas wordt een andere matrix gebruikt om de originele kolomvector te vermenigvuldigen.
	\begin{itemize}
		\item \textbf{Rotatie rond de x-as.}
			\[
				\begin{pmatrix}
					x' \\
					y' \\
					z'
				\end{pmatrix}
				=
				\begin{pmatrix}
					x \\
					y \\
					z
				\end{pmatrix}
				\cdot
				\begin{pmatrix}
					1 & 0 & 0 \\
					0 & \cos \theta & - \sin \theta \\
					0 & \sin \theta &   \cos \theta  
				\end{pmatrix}
			\]
		\item \textbf{Rotatie rond de y-as.}
		\item \textbf{Rotatie rond de z-as.}
	\end{itemize}
	Elke willekeurige rotatie waarbij de rotatieas door de oorsprong loopt, kan beschreven worden door 5 opeenvolgende elementaire rotatiematrices. Veronderstel een rotatieas $u$ over een hoek $\beta$. Dit kan bekomen worden door eerst de $u$-as te laten samenvallen met de $x$-as, gebruik makend van twee rotaties $R_{y,\theta}$ en $R_{z, -\phi}$. Daarna wordt een rotatie uitgevoerd rond de $x$-as over een hoek $\beta$, $R_{x,\beta}$. De laatste twee rotaties dienen om de eerste twee rotaties ongedaan te maken.
	$$R_{u, \beta} = R_{y, \theta} \cdot R_{z, \phi} \cdot R_{x, \beta} \cdot R_{z, -\phi} \cdot R_{y,\theta}$$
	Om na te gaan of een willekeurige matrix ook een rotatiematrix is moet het matrixproduct van de matrix met zijn getransponeerde \textbf{1} opleveren.
	\subsection{Schaaloperaties en spiegelingen}
	Een schaaloperatie kan eenvoudig gedefinieerd worden als :

	$$
		\begin{pmatrix}
			x' \\
			y' \\
			z'
		\end{pmatrix}
		= 
		\begin{pmatrix}
			x \\
			y \\
			z
		\end{pmatrix}
		\cdot
		\begin{pmatrix}
			s_x & 0 & 0 \\
			0 & s_y & 0 \\
			0 & 0  & s_z
		\end{pmatrix}
	$$

	Via deze schaalmatrix kunnen ook spiegelingen gedaan worden. Indien één van de schaalfactoren $s_x$, $s_y$ of $s_z$ -1 is, en de andere twee op +1, is er een spiegeling in een coördinatenvlak. Een spiegeling rond een rechte kan bekomen worden door 2 schaalfactoren op -1 te zetten en de overblijvende op +1. Een spiegeling rond de oorsprong kan bekomen worden door alle schaalfactoren op -1 te zetten.
	Elke rotatie kan ook beschouwd worden als een samenstelling van twee spiegelingen.

	\subsection{Translaties}

	\part{Examenvragen}
	\chapter{Modelvragen eerste theorievraag}
	Deze vraag wordt gequoteerd op 1/4 van de totaalpunten.
	
	\section{Rastering}
	\begin{enumerate}
		\item Bespreek de verschillende algoritmen voor de \textit{rastering van rechte lijnen}, zonder in detail in te gaan op \textit{multi-step} varianten. Vermeld telkens hun voor- en nadelen. \accentuate{(§1.2 \& §1.2.1)}
		
		\item Hoe kunnen de methodes aangepast worden om \textbf{dikke} lijnen voor te stellen ? \accentuate{(§1.5)}
	\end{enumerate}

	\section{Het algoritme van Bresenham}
	\begin{enumerate}
		\item Bespreek het doel van dit algoritme en geef de volledige uitwerking van het selectieproces. \accentuate{(§1.3)}
		
		\item Hoe kan deze methode aangepast worden om \textbf{dikke} cirkels voor te stellen ? \accentuate{ (§1.5)}
	\end{enumerate}

	\section{Rastering van veelhoeken en antialiasing}
	\begin{enumerate}
		\item Hoe moeten algoritmen voor het rasteren van rechte lijnen gewijzigd worden indien men ze wil toepassen op het \textit{opvullen van veelhoeken} ? \accentuate{(§1.4)}
		
		\item Geef het doel van \textit{antialiasing}, het algemeen principe ervan, en drie algoritmen voor de praktische uitwerking (met voorbeelden). \accentuate{(§1.6)}
	\end{enumerate}

	\section{Transformaties}
	\begin{enumerate}
	\item Welke families transformaties worden in de computer-grafiek gebruikt, en waarom ?
	
	\item Geef en bespreek de matrixrepresentaties van de verschillende types transformaties en hun samenstellingen. \accentuate{(§2.1 behalve §2.1.4)}
	\end{enumerate}

	\section{Projecties en clipping}

	\begin{enumerate}
	\item Welke soort projectie wordt in de computergrafiek gebruikt, en waarom ?
	
	\item Leid de algemene matrixvorm van deze projectie af. \accentuate{(§2.2)}
	
	\item Wat is de bedoeling van clipping ? Bespreek clippen in twee en in drie dimensies. \accentuate{(§2.3 zonder deelparagrafen)}
	\end{enumerate}

	\section{Het algoritme van Cyrus-Beck}
	\begin{enumerate}
		\item Geef het doel, de toepasbaarheid, en de beperkingen van het algoritme, en de volledige uitwerking van het principe. Pas het algoritme stap-voor-stap toe op volgende viewport \textit{(figuur wordt gegeven)} en een lijnstuk met eindpunten ... .  \accentuate{(§2.3.2)}
		
		\item Hoe clipt men meer ingewikkelde krommen en figuren ?
	\end{enumerate}

	\section{Clipping}
	\begin{enumerate}
		\item Het algoritme van \textit{Cohen-Sutherland}: geef het doel, de toepasbaarheid, en de beperkingen van het algoritme, en de volledige uitwerking van het principe. Pas het algoritme toe op relevante voorbeelden. Geef eveneens een variant van de techniek. \accentuate{(§2.3.1)}
		
		\item Het algoritme van \textit{Sutherland-Hodgman}: geef het doel, de toepasbaarheid, en de beperkingen van het algoritme, en de volledige uitwerking van het principe. Pas het algoritme stap-voor-stap toe op volgend voorbeeld: (figuur wordt gegeven) . \accentuate{(§2.3.3)}
	\end{enumerate}

	\chapter{Modelvragen tweede theorievraag}
	Deze vraag wordt gequoteerd op 2/4 van de totaalpunten.
	
	\section{NURBS constructie van cirkels \accentuate{(\textsection 3.4.8, slides en lesnota's)}}
	\begin{enumerate}
		\item aMet welke \textit{open-uniforme NURBS} van orde drie (graad twee) kun je een \textit{halve cirkel} (met centrum in de oorsprong en straal 1) tekenen , zonder (reële) knooppunten met meervoudige multipliciteit te moeten gebruiken ? Geef de preciese locatie van de \textit{controlepunten} (op een figuur), hun gewichten, en de corresponderende \textit{knopenvector}. Uit hoeveel segmenten bestaat deze NURBS ?
		
		\item Toon aan dat deze constructie inderdaad exact een halve cirkel oplevert.
		
		\item Construeer van deze NURBS de \textit{uniforme} representatie. Vermeld de conversiestappen om tot dit resultaat te bekomen. Waarom is de constructie van de uniforme representatie belangrijk ?
	\end{enumerate}

	\section{NURBS constructie van cirkels en lijnsegmenten \accentuate{(§3.4.8 en slides)} }
	\begin{enumerate}
		\item Met welke \textit{NURBS} kun je exact een recht \textit{lijnsegment} door twee punten tekenen ? Geef de preciese locatie van de \textit{controlepunten} (op een figuur), hun gewichten, en de corresponderende \textit{knopenvector}.
		
		\item Met welke \textit{NURBS} bestaande uit één enkel segment kun je een \textit{halve cirkel} (met centrum in de oorsprong en straal 1) tekenen ? Geef de preciese locatie van de \textit{controlepunten} (op een figuur), hun gewichten, en de corresponderende knopenvector\textit{}. Wat is de graad van deze NURBS ?
		
		\item Toon aan dat deze constructie inderdaad exact een halve cirkel oplevert.
		
		\item Met welke \textit{NURBS} bestaande uit één enkel segment kun je exact een \textit{volledige cirkel} (met centrum in de oorsprong en straal 1) tekenen ? Geef de preciese locatie van de \textit{controlepunten} (op een figuur), hun gewichten, en de corresponderende \textit{knopenvector}. Wat is de graad van deze NURBS ?
	\end{enumerate}

	\section{Reflectiemodellen \accentuate{(§5.2, behalve §5.2.1.2 en §5.2.1.3) }}
	\begin{enumerate}
		\item Waarom zijn reflectiemodellen noodzakelijk ?
		
		\item Omschrijf het lokale reflectiemodel (Phong-model). Geef ondermeer de
		 berekenings-voorschriften, de betekenis van de parameters, en de nadelen.
		 
		\item Geef en omschrijf (in het bijzonder de nadelen) van de drie mogelijke benaderingen voor de berekening van de \textit{lichtintensiteit van zichtbare punten}, indien men het object beschrijft aan de hand van een verzameling \textit{vlakke veelhoeken}.
		
	\end{enumerate}

	\section{1D Wavelet transformaties}
	\begin{enumerate}
		\item Bespreek met behulp van \textit{Multi-Resolutie-Analyse} de algemene concepten van wavelet transformaties. \accentuate{(§3.5.2)}
		
		\item Vertaal deze algemene concepten in het bijzonder geval van de \textit{Haar-wavelet} transformatie. \accentuate{(§3.5.1 \& §3.5.2)}

		
		\item Bespreek de noodzaak van \textit{spline-wavelets} (1D). Wat is het verband tussen de \textit{Haar-wavelet} transformatie en de \textit{spline-wavelet} transformatie ? Geef een overzicht van de relatieve voor- en nadelen. 
		
		\item Beschrijf van lage orde 1D \textit{open-uniforme} spline-wavelet transformaties de vorm van achtereenvolgens de \textit{schaalfuncties}, de \textit{wavelets} en de \textit{synthese filters}.
	\end{enumerate}

	\section{2D Wavelet transformaties \accentuate{(§4.5.1)}}
	\begin{enumerate}
		\item Bespreek de alternatieve methodes om 2D \textit{schaalfuncties en wavelets} te construeren.
		
		\item Beschrijf, aan de hand van \textit{contourplotjes}, en voor elk van deze alternatieve methodes, de resulterende \textit{2D Haar-schaalfuncties en Haar-wavelets} van het laagste en het op één na laagste niveau.
	\end{enumerate}

	\section{Toepassingen van wavelet transformaties }
	\begin{enumerate}
		\item Geef de meest relevante toepassingen in de computergrafiek van 1D \textit{Haar-wavelet} en 1D \textit{spline-wavelet} transformaties. \accentuate{(§3.5.4)}
		
		\item 	Geef de meest relevante toepassingen in de computergrafiek van 2D \textit{Haar-wavelet} en 1D \textit{spline-wavelet} transformaties. \accentuate{(§4.5.2)}
	\end{enumerate}
	
	\chapter{Informatie derde vraag}
	Deze vraag is een \textbf{oefening}, gequoteerd op 1/2 van de totaalpunten, over één of enkele van volgende onderwerpen:
	\begin{itemize}
		\item \accentuate{(1-3)} de Casteljau constructie (van een punt met specifieke parameterwaarde) van een Bézier kromme
		\item \accentuate{(1)} verhoging van de graad van Bézier splines (in één enkele stap); voorafgaand moet het verband tussen de \textit{oude} en de \textit{nieuwe} controlepunten opgesteld worden (vermenigvuldiging met een specifieke matrix, cfr. theorieles)
		\item \accentuate{(2)} verhoging van de graad van Bézier splines (\textit{stapsgewijs}: één graad verhogen per stap)
		\item \accentuate{(3,4)} segmentering (subdivisie) van Bézier krommen (eventueel meerdere segmenten in één enkele stap)
		\item \accentuate{(9-10,14-16)} constructie van de \textit{kromtecirkel} in een punt van een Bézier kromme
		\item \accentuate{(5-7,9-11)} constructie van de \textit{Bézier representatie} van een (polynomiale) NURBS
		\item \accentuate{(6-10)} constructie van controlepunten na toevoeging van één of meerdere \textit{reële} knopen in de knopenvector van een (polynomiale) NURBS (zonder over te gaan op de Bézier representatie)
		\item \accentuate{(10)} constructie van controlepunten na toevoeging van één of meerdere \textit{virtuele} knopen in de knopenvector van een (polynomiale) NURBS (zonder over te gaan op de Bézier representatie)
		\item \accentuate{(11)} berekening en constructie van de controlepunten van de \textit{open-uniforme} representatie van een (polynomiale) NURBS met een \textit{uniforme} knopenvector
		\item \accentuate{(12,19)} berekening en constructie van de controlepunten van de \textit{uniforme} representatie van een polynomiale of rationale NURBS met een \textit{open-uniforme} knopenvector
		\item \accentuate{(12)} de Boor constructie (van een punt met specifieke parameterwaarde) van een (polynomiale) NURBS
		\item \accentuate{(13)} constructie van de \textit{hodograaf} van een Bézier kromme of spline
		\item \accentuate{(13-16)} vaststellen van de continuïteit in de knooppunten van Bézier splines (\textit{stelling van Stärk})
		\item \accentuate{(17)} constructie van de controlepunten van de \textit{uniforme} Lagrange representatie van een Lagrange geïnterpoleerde kromme met \textit{niet-uniforme} knopenvector; schematisch aantonen hoe de berekening van de Bézier representatie van deze kromme zou kunnen uitgevoerd worden (ondermeer opstellen van de \textit{inverse} van de Bézier basismatrix).
		\item \accentuate{(18,19)} constructie van een  \textit{benadering door lijnstukken} van een uniforme NURBS door toepassing van het algoritme van Lane \& Riesenfeld
		\item \accentuate{(20)} constructie van een \textit{triangulair schema} met behulp van het veralgemeend algoritme van Neville (voor een specifieke configuratie van inputgegevens), en berekening hieruit van de \textit{gewichtsfuncties} en de \textit{matrixrepresentatie}
		
	\end{itemize}
	
\end{document}


