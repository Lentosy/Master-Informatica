\documentclass{report}

\usepackage{ugentstyle}
\usepackage{amsmath}

\newcommand{\vraag}[2]{
	\item #1
	
	#2
}

\begin{document}
	\maketitle{Computergrafiek - Examen}
	\tableofcontents
	\chapter{Modelvragen eerste theorievraag}
	Deze vraag wordt gequoteerd op 1/4 van de totaalpunten.
	
	\section{Rastering}
	\begin{enumerate}
		\vraag
		{
			Bespreek de verschillende algoritmen voor de \textit{rastering van rechte lijnen}, zonder in detail in te gaan op \textit{multi-step} varianten. Vermeld telkens hun voor- en nadelen. \accentuate{(§1.2 \& §1.2.1)}
		}
		{
			\begin{itemize}
				\item \textbf{Midpoint subdivision.} Dit algoritme maakt gebruik van een recursieve procedure waarbij het midden van een lijnstuk berekent wordt, de overeenkomstige pixel selecteert, en daarna deze procedure opnieuw aanroept om de twee helften van het segment. Dit algoritme werkt nadelig naarmate een hellingshoek van 45 graden bereikt wordt. Het effect is dan onregelmatig en dunner. Het grootste nadeel is echter dat het me reële getallen moet uitgevoerd worden.
				
				\item \textbf{Asymmetrische DDA.} Algoritmes van de familie DDA pogen het aantal reële getallen te beperken, en voeren hun berekeningen ook incrementeel uit in plaats van recursief. Bij asymmetrische DDA wordt de x-waarde wordt telkens met 1 verhoogt terwijl de y-waarde verhoogt wordt met de richtingscoëfficiënt van de rechte. In elke stap wordt een pixel berekend en geselecteerd. Indien de helling van de rechte met de x-as groter zou zijn dan 45 graden, worden de rollen van x en y omgewisseld. Hier is echter ook het probleem dat indien de hellingshoek 45 graden nadert, dat de lijn te dun wordt getekend.
				
				\item \textbf{Symmetrische DDA.} De symmetrische variant van DDA vermijdt het onderscheid in functie van de hellingshoek ten opzichte van de x-as, door de incrementen in beide richtingen repetitief te halveren tot wanneer deze kleiner zijn dan een pixel. Nadat de incrementen berekend zijn, wordt hetzelfde princiepe toegepast als asymmetrische DDA. De x en y-waarde worden nu telkens verhoogt met de eerder berekende incrementen, en selecteren de juiste pixel. Aangezien de incrementen kleiner zijn dan een pixel, zullen sommige pixels meerdere malen geselecteerd worden, wat een impact heeft op de snelheid van het algoritme. Het resultaat indien de hellingshoek 45 graden nadert, is voller dan by de asymmetrische variant, maar het patroon is minder regelmatig. Het produceert hetzelfde resultaat als midpoint subdivision.
				
				\item \textbf{Kwadrant DDA.} Dit algoritme verhoogt de incrementen met exact 1 pixel, maar nooit in beide richtingen tegelijkertijd. De verhouding van het aantal incrementen in de y-richting tot het aantal incrementen in de x-richting wordt bepaald door de richtingscoëfficiënt van de rechte. Er is een extra variabele, $\Delta$ die best geinitialiseerd wordt op $\frac{(x_2 - x_1) - (y_2 - y_1)}{2}$. Indien $\Delta$ foutief geinitialiseerd wordt, produceert dit algoritme slechte resultaten bij zeer vlakke of zeer steile lijnstukken. De variabele $\Delta$ bepaalt of de lijn verder getekend moet worden in de x-richting, indien $\Delta \geq 0$, of in de y-richting wanneer $\Delta < 0$.
				
				 Een enorm voordeel van dit algoritme is dat het geen gebruik maakt van reële getallen, ook niet bij de  variabele $\Delta$ aangezien het dubbele bijgehouden wordt. Bij een hellingshoek die 45 graden nadert, zijn de lijnstukken veel te dik. Dit is logisch aangezien de helft van de beslissingen het lijnstuk in de x-richting zullen selecteren, en de andere helft in de y-richting, telkens afwisselend van elkaar.
				
				\item \textbf{Octant DDA.} Dit laatste algoritme verfijnt kwadrant DDA door overlappende segmenten te vermijden. Indien de hellingshoek van het lijnstuk kleiner zou zijn dan 45 graden, zal octant DDA een pixel ofwel in de horizontale richting of in de diagonale richting selecteren, afhankelijk naargelang $\Delta$ positief of negatief is. Is de hellingshoek groter, dan zal octant DDA in de verticale of diagonale richting selecteren. 
				
				Dit algoritme produceert ongeveer dezelfde resultaten als asymmetrische DDA, zonder gebruik te maken van reële getallen. Naarmate de hellingshoek 45 graden nadert, wordt het lijnstuk te fijn weergegeven.
			\end{itemize}
		}
	
		
		\vraag
		{
			Hoe kunnen de methodes aangepast worden om \textbf{dikke} lijnen voor te stellen ? \accentuate{(§1.5)}
		}
		{
			\begin{itemize}
				\item \textbf{Replicatie.} Dit is een eenvoudige manier, dat bij elke iteratie van een DDA algoritme, enkele pixels boven en onder, of links en rechts van de geselecteerde pixels meeselecteren, afhankelijk van de gewenste dikte en de hellingshoek. De overgang tussen twee lijnstukken die op deze manier dikker gemaakt zijn, is niet altijd even goed. Deze techniek wordt enkel toegepast indien de lijnen relatief dun zijn.
				\item \textbf{Replicatie met vorm.} Bij elke iteratie van een DDA algoritme wordt rond de huidige geselecteerde pixel, een vlak geselecteerd. Vaak gebruikte vlakken zijn vierkanten voor lijnstukken en cirkelvormige vlakken voor cirkels.
				
				\item \textbf{Opvulling.} Een derde techniek is om tweemaal het DDA algoritme toe te passen, op lijnstukken die uit elkaar verschoven zijn. Daarna worden deze twee lijnstukken opgevuld met de techniek om veelhoeken op te vullen.
			\end{itemize}
		}
		
	\end{enumerate}

	\section{Het algoritme van Bresenham}
	\begin{enumerate}
		\vraag
		{
			Bespreek het doel van dit algoritme en geef de volledige uitwerking van het selectieproces. \accentuate{(§1.3)}
	    }
		{
			\begin{itemize}
				\item Het algoritme van Bresenham is geschikt om pixels te rasteren in de vorm van een cirkel terwijl het ook enkel gehele getalllen vereist. Het algoritme berekent enkel de pixels voor de cirkelsector met beginpunt ($0, R$) en eindpunt ($R/\sqrt{2},R/\sqrt{2}$). De andere cirkelsectoren kunnen met behulp van symmetrie bekomen. Bij elke iteratie wordt de x-waarde van de pixel verhoogd. Het aanpassen van de y-waarde hangt af van de discriminant $\Delta_i$. Is deze waarde strikt positief dan zal de y-waarde met 1 pixel verlaagt worden. Is de discriminant negatief, dan blijf de y-waarde dezelfde. De discriminant $\Delta_i$ wordt gedefinieerd als het verschil van de kwadraten van de afstanden van de twee mogelijke punten tot de cirkel:
				
				\begin{equation*}
					\begin{split}
						\Delta_i & = [(x_{i - 1} + 1)^2 + y_{i - 1}^2 - R^2] - [R^2 - (x_{i - 1} + 1)^2 - (y_{i - 1} - 1)^2]  \\
						& = 2(x_{i - 1} + 1)^2 + y_{i - 1}^2 + (y_{i - 1} - 1)^2 - 2R^2
					\end{split}
				\end{equation*}	
				
				De discriminant $\Delta_{i + 1}$ kan uit $\Delta_i$ afgeleidt worden.
				\begin{equation*}
					\begin{split}
						\Delta_{i + 1} & = 2(x_{i - 1} + 2)^2 + y_i^2 + (y_i - 1)^2 - 2R^2 \\
									   & = \Delta_i + 4x_i + 6 + y_i^2 - y_{i - 1}^2 + (y_i - 1)^2 - (y_{i - 1} - 1)^2 \\
									   & = \begin{cases}
											  \Delta_i + 4x_{i - 1} + 6 &, \Delta_i \leq 0 \\
											  \Delta_i + 4(x_{i - 1} - y_{i - 1}) + 10  &, \Delta_i > 0
									 	   \end{cases}
					\end{split}
				\end{equation*}
				
				De beginwaarde van de discriminant, $\Delta_i$ kan bekomen worden door de substitutie $x_{i - 1} = 0$ en $y_{i - 1} = R$ toe te passen:
				$$\Delta_1 = 3 - 2R$$
				
			\end{itemize}

		}

		
		\vraag
		{
			Hoe kunnen de methodes aangepast worden om \textbf{dikke} lijnen voor te stellen ? \accentuate{(§1.5)}
		}
		{
			\begin{itemize}
				\item \textbf{Replicatie.} Dit is een eenvoudige manier, dat bij elke iteratie van een DDA algoritme, enkele pixels boven en onder, of links en rechts van de geselecteerde pixels meeselecteren, afhankelijk van de gewenste dikte en de hellingshoek. De overgang tussen twee lijnstukken die op deze manier dikker gemaakt zijn, is niet altijd even goed. Deze techniek wordt enkel toegepast indien de lijnen relatief dun zijn.
				\item \textbf{Replicatie met vorm.} Bij elke iteratie van een DDA algoritme wordt rond de huidige geselecteerde pixel, een vlak geselecteerd. Vaak gebruikte vlakken zijn vierkanten voor lijnstukken en cirkelvormige vlakken voor cirkels.
				
				\item \textbf{Opvulling.} Een derde techniek is om tweemaal het DDA algoritme toe te passen, op lijnstukken die uit elkaar verschoven zijn. Daarna worden deze twee lijnstukken opgevuld met de techniek om veelhoeken op te vullen.
			\end{itemize}
		}
	\end{enumerate}

	\section{Rastering van veelhoeken en antialiasing}
	\begin{enumerate}
		\vraag{
			 Hoe moeten algoritmen voor het rasteren van rechte lijnen gewijzigd worden indien men ze wil toepassen op het \textit{opvullen van veelhoeken} ? \accentuate{(§1.4)}
		}
		{
			\begin{itemize}
				\item De veelhoek wordt afgetast met een horizontale of verticale scanlijnen. Voor elke scanlijn worden de intersectiepunten met de lijn en het veelhoek bepaalt. Het aantal intersectiepunten is altijd een even aantal. De intersecties worden (bij een horizontale scanlijn) gesorteerd op de x-waarde. Alle pixels x tussen een intersectie met een even index en een intersectie met oneven index, $x_{2i} \leq x \leq x_{2i + 1}$ , worden getekend. Om te voorkomen dat pixels buiten het veelvlak geselecteerd worden, beperkt men de selectie tot enkel inwendige pixels als intersectiepunten, ook als ligt een uitwendig pixel dichter bij de randlijn. 
			\end{itemize}
		}
		
		\vraag
		{
			Geef het doel van \textit{antialiasing}, het algemeen principe ervan, en drie algoritmen voor de praktische uitwerking (met voorbeelden). \accentuate{(§1.6)}
		}
		{
			\begin{itemize}
				\item Antialiasing is het proces om de discrete eigenschap dat pixels vertonen, namelijk het gekarteld uitzicht, te minimaliseren. 
				\begin{enumerate}
					\item \textbf{Supersampling.} Deze techniek maakt gebruik van een interne geheugenbuffer. Deze buffer biedt een fijner raster aan dan die dat hardwarematig beschikbaar zijn. Een pixel op een computerscherm kan overeenkomen met 16 pixels in het geheugen. Na het rasteringsproces, dat nu uitgevoerd wordt in het geheugen, wordt voor elke pixel nagegaan hoeveel geheugenpixels in de groep geselecteerd zijn. Als 7 pixels geselecteerd zijn met een geheugenpixelgrootte van 16 pixels, dan zal die pixel een intensiteit van $7/16$ bedragen.
					\item \textbf{Postfiltering.} Deze methode zal eerst het rasteringsproces uitvoeren in het geheugen, dat nu dezelfde resolutie heeft als de hardware. Nadien wordt de intensiteit van een pixel herberekend op basis van het al dan niet geselecteerd zijn van de naburige pixels. De groep dat in beschouwing wordt genomen heeft vaak de vorm van een rechthoek (meer specifiek, een vierkant). Het gewicht van een naburige pixel wordt berekend op basis van de afstand van die pixel tot het middenpunt van de groep.
					\item \textbf{Prefiltering.} In tegenstelling tot de vorige twee algoritmen zal het rasterproces en antialiasingproces zich in dezelfde stap plaatsvinden. Dit algoritme heeft nood aan aangepaste DDA algoritmen. Een specifieke implementatie is het Pitteway-Watkinson algoritme. Dit algoritme maakt het mogelijk om een pixel te selecteren terwijl zijn intensiteit incrementeel berekend wordt. \todo{??}
				\end{enumerate}
			\end{itemize}
		}
	\end{enumerate}

	\section{Transformaties}
	\begin{enumerate}
	\vraag
	{
		Welke families transformaties worden in de computer-grafiek gebruikt, en waarom ?
	}
	{
		\begin{itemize}
			\item \textbf{Affiene transformaties.} Hieronder vallen de rotaties, schaaloperaties, spiegelingen en translaties. Deze transformaties behouden colliniariteit en parallellisme. Evenwijdige lijnen zullen na een affiene transformatie nog steeds evenwijdig zijn. 
			
			\item \textbf{Perspectieve projecties.} Deze transformaties maken het mogelijk om een driedimensionaal object voor te stellen op een tweedimensionaal uitvoerapparaat.
			
			\item De combinatie van deze twee transformaties biedt de mogelijkheidt om onder andere:
			\begin{itemize}
				\item een object vanuit een andere kijkrichting te bekijken.
				\item hij construeren van een object dat uit meerdere identieke componenten bestaat. 
			\end{itemize}
		\end{itemize}	
	}
	
	\vraag 
	{
		Geef en bespreek de matrixrepresentaties van de verschillende types transformaties en hun samenstellingen. \accentuate{(§2.1 behalve §2.1.4)}	
	}
	{
		\begin{itemize}
			\item \textbf{Rotaties.} 
		\end{itemize}
	}
	\end{enumerate}

	\section{Projecties en clipping}

	\begin{enumerate}
	\vraag{Welke soort projectie wordt in de computergrafiek gebruikt, en waarom ?}{ 	
		\begin{itemize}
			\item De computergrafiek maakt gebruik van perspectieve projecties. Deze soort projecties simuleren de werking van het menselijk oog. Er wordt een oogpunt en een kijkrichting vastgelegd. De kijkrichting is een georiënteerde rechte door het oogpunt. Tussen het oogpunt en elk object wordt een rechte verbonden. Ergens op die rechte zal er een snijpunt zijn met het projectievlak. Dit snijpunt bepaalt het getransformeerde beeld van het punt.
		\end{itemize} 
	}
	
	\vraag{Leid de algemene matrixvorm van deze projectie af. \accentuate{(§2.2)}}{
		\begin{itemize} 
			\item Een perspectieve projectie kan afgeleid worden na het toepassen van een affiene transformatie. Een translatie T verplaatst het snijpunt van de kijkrichting met het projectievlak naar de oorsprong van het coördinatenstelsel. Deze transformatie wordt gevolgd door een rotatie R die het oogpunt op de negatieve z-as plaatst, in het punt met homogene coördinaten (0, 0, -d, 1). Hierdoor valt het projectievlak samen met het xy-vlak. Hierdoor is ook de z-waarde van het geprojecteerd punt nul. Op dit moment kunnen twee driehoeken beschouwd worden. De driehoek met de kijkrichting vanuit de y-as naar het zx-vlak (1) en de driehoek met de kijkrichting vanuit de x-as naar het zy vlak (2).
			\begin{enumerate}
				\item[(1)] Hieruit kan afgeleidt worden dat $\frac{x_p}{d} = \frac{d}{z + d}$.
				\item[(2)] Hieruit kan afgeleidt worden dat $\frac{y_p}{d} = \frac{d}{z + d}$.
			\end{enumerate}
		In homogene coördinaten kan dit echter vereenvoudigd worden.:
		$$x' \equiv w'\cdot x_p = x \qquad y' \equiv w'\cdot y_p = y \qquad \hbox{met} \qquad w' = \frac{z}{d} + 1$$
		In matrixvorm:
		$$
			\begin{pmatrix}
			 x' \\ y' \\ 0 \\ w'
			\end{pmatrix}
			=
			\begin{pmatrix}
				1 & 0 & 0 & 0 \\
				0 & 1 & 0 & 0 \\
				0 & 0 & 0 & 0 \\
				0 & 0 & 1/d & 1 \\
			\end{pmatrix} 
			\cdot
			\begin{pmatrix}
			x \\ y \\ z \\ 1
			\end{pmatrix}
		$$
		
		Hieruit is het duidelijk dat een perspectieve projectie ook kan berekend worden via eenvoudige matrixvermenigvuldigingen:
		$$
			\begin{pmatrix}
			x' \\ y' \\ 0 \\ w'
			\end{pmatrix}
			=
			\begin{pmatrix}
			1 & 0 & 0 & 0 \\
			0 & 1 & 0 & 0 \\
			0 & 0 & 0 & 0 \\
			0 & 0 & 1/d & 1 \\
			\end{pmatrix} 
			\cdot
			\begin{pmatrix}
			i_x & j_x & k_x & -\theta_x \\
			i_y & j_y & k_y & -\theta_y \\
			i_z & j_z & k_z & -\theta_z \\
			0 & 0 & 0 & 1
			\end{pmatrix}
			\cdot
			\begin{pmatrix}
			x \\ y \\ z \\ 1
			\end{pmatrix}
		$$
		\end{itemize}
	}
	
	\vraag{Wat is de bedoeling van clipping ? Bespreek clippen in twee en in drie dimensies. \accentuate{(§2.3 zonder deelparagrafen)}}{
		\begin{itemize} 
			\item Een kijkrichting is begrensd door een bepaalde maximumwaarde. Vanuit het oogpunt kan er een pyramide beschouwd worden. Elke pixel dat zich niet in deze pyramide bevindt moet geclipt worden, aangezien deze toch niet gezien kan worden. De doorsnede van de pyramide met het projectievlak wordt het viewport genoemd. De viewport is evenwijdig met de x- en y-assen met het centrum in de oorsprong van het coördinatenstelsel waarin het geprojecteerd beeld afgebeeld. De selectie van alle pixels in perspectieve projectie die binnen de viewport liggen noemt men clipping. 3D Objecten worden eerste geclipt vooraleer ze perspectief geprojecteerd wordt. 2D objecten worden geprojecteerd en daarna pas geclipt. Het clippen van lijnstukken en opgevulde veelhoeken wordt door vrijwel alle algoritmen ondersteund. Bij het clippen van complexere veelhoeken wordt eerst de omhullende veelhoek berekent, en worden alle zijden geclipt met de viewport.
		\end{itemize}}
	\end{enumerate}

	\section{Het algoritme van Cyrus-Beck}
	\begin{enumerate}
		\vraag{Geef het doel, de toepasbaarheid, en de beperkingen van het algoritme, en de volledige uitwerking van het principe. Pas het algoritme stap-voor-stap toe op volgende viewport \textit{(figuur wordt gegeven)} en een lijnstuk met eindpunten ... .  \accentuate{(§2.3.2)}}{
			\begin{itemize} 
				\item Het algoritme van Cyrus-Beck is geschikt om lijnen te clippen ten opzichte van een willekeurige convexe veelhoek. Het algoritme maakt gebruik van de geparameteriseerde voorstelling van een lijnstuk: $P(t) = P_1 + t(P_2 - P_1)$. Indien $0 \leq t \leq 1$, dan bevindt P(t) zich op het lijnstuk. Het Cyrus-Beck algoritme spoort deze t-waarden op van de intersecties met de verschillende zijden van de viewport en hieruit afleiden ofdat het lijnsegment hetzij partieel, hetzij totaal binnen de viewport ligt.
				
				De eerste stap van dit algoritme berekent alle $n_i[P(t) - f_i]$ functies en de waarden van $t_i$ waarvoor deze functies nul worden. Indien al deze functies niet-negatieve waarden hebben voor zowel $t = 0$ als $t = 1$, dan ligt het lijnstuk volledig binnen de viewport. Is dit slechts het geval voor $t = 0$ of $t = 1$, dan ligt het lijnstuk zeker partieel in de viewport. Er moet bijgevolg extra kandidaatsnijpunten met de viewport gezocht worden. Enkel $t_j$ waarden waarvor $0 \leq t_j \leq 1$ komen hiervoor in aanmerking. Voor elke $t_j$ waarde wordt nagegaan of $n_i \cdot [P(t_j) - f_i] \geq 0$. De kleinste en grootste $t_j$ leveren de gezochte snijpunten op.
				
				\item Toegepast op een lijnstuk met punten $P_1(-1, 1)$ en $P_2(9, 3)$ in een viewport met dimensie 8 bij 4 (fig 2.23 p 27 in de cursus). Het lijnstuk wordt geparameteriseerd door $$P(t) = \begin{cases}
				x = -1 + 10t \\
				y = 1 + 2t
				\end{cases}$$
				Neem $f_{L, B} = (0, 0)$ en $f_{T, R} = (8, 4)$. Uitrekenen van de $n_i[P(t) - f_i]$ functies wordt dan:
				\begin{table}[h]
					\centering
					\begin{tabular}{c | c | c}
						zijde & $[P_1P_2]$  & nulwaarde\\ 
						\hline 
						\\
						$n_L, f_L = (0, 0)$ & $(-1 + 10t - 0, 1 + 2t - 0) \cdot (1, 0) = -1 + 10t$ & $1/10$\\
						$n_R, f_R = (8, 4)$ & $(-1 + 10t - 8, 1 + 2t - 4) \cdot (-1, 0) = 9 - 10t$ & $9/10$\\
						$n_B, f_B = (0, 0)$ & $(-1 + 10t - 0, 1 + 2t - 0) \cdot (0, 1) =  1 + 2t$ & $-1/2$\\
						$n_T, f_T = (8, 4)$ & $(-1 + 10t - 8, 1 + 2t - 4) \cdot (0, -1) = 3 - 2t$  & $3/2$\\
					\end{tabular}
				\end{table}
				Elke nulwaarde kan een waarde voor t zijn. 	Er moet echter gelden dat $n_i[P(t_j) - f_i] \geq 0, \forall i$. Dit komt neer op het substitueren van de nulwaarden $t_i$ in elke andere functie en nagaan of dat het resultaat positief is voor elk van deze functies. In dit geval is dit enkel voor $t = 1/10$ en $t = 9/10$. Dit zijn dan ook de punten die snijden met de viewport.
			\end{itemize}
		}
		
		\vraag{Hoe clipt men meer ingewikkelde krommen en figuren ?}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
	\end{enumerate}

	\section{Clipping}
	\begin{enumerate}
		\vraag{Het algoritme van \textit{Cohen-Sutherland}: geef het doel, de toepasbaarheid, en de beperkingen van het algoritme, en de volledige uitwerking van het principe. Pas het algoritme toe op relevante voorbeelden. Geef eveneens een variant van de techniek. \accentuate{(§2.3.1)}}{
			\begin{itemize} 
				\item Het algoritme van Cohen-Sutherland is geschikt voor het clippen van lijnstukken ten opzichte van een rechthoekig viewport. Dit algoritme is enkel aan te raden om 2D clipping toe te passen. Het algoritme wenst zo snel mogelijk te detecteren of lijnstukken volledig binnen of buiten het viewport liggen. Het algortime zal aan elk eindpunt van een lijnstuk een bitcode $ b_3b_2b_1b_0$ toekennen. Bit $b_0$ wordt op 1 gezet indien het punt zich links van de viewport bevindt, en een bit $b_1$ identificeert een punt aan de rechterzijde van de viewport. Op dezelfde manier hebben punten onder en boven de viewport respectievelijk bits $b_2 = 1$ en $b_3 = 1$. Een lijnstuk dat volledig binnen de viewport ligt heeft dus twee eindpunten met bitcode $0000$. De twee eindpunten van een lijnstuk AND'en kan twee gevallen opleveren:
				\begin{enumerate}
					\item Indien het resultaat verschillend van $0000$ is, dan ligt het lijnstuk met zekerheid buiten de viewport.
					\item Is het resultaat echter $0000$ (zonder dat de bitcodes van beide eindpunten $0000$ is) dan ligt slechts een deel van het lijnstuk in de viewport.
				\end{enumerate}
				In dit tweede geval wordt het midden van dit lijnstuk genomen, en wordt het algoritme recursief toegepast op beide helften. Deze iteraties moeten doorgevoerd worden tot wanneer de precisie van een pixel bereikt is. Het voordeel van deze methodiek is dat het performant in de hardware kan uitgevoerd worden. Er is enkel een deling door twee vereist en kan parallel uitgevoerd worden.
			 \end{itemize}
		}
		
		\vraag{Het algoritme van \textit{Sutherland-Hodgman}: geef het doel, de toepasbaarheid, en de beperkingen van het algoritme, en de volledige uitwerking van het principe. Pas het algoritme stap-voor-stap toe op volgend voorbeeld: (figuur wordt gegeven) . \accentuate{(§2.3.3)}}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
	\end{enumerate}

	\chapter{Modelvragen tweede theorievraag}
	Deze vraag wordt gequoteerd op 1/4 van de totaalpunten.
	
	\section{NURBS constructie van cirkels \accentuate{(\textsection 3.4.8, slides en lesnota's)}}
	\begin{enumerate}
		\vraag{aMet welke \textit{open-uniforme NURBS} van orde drie (graad twee) kun je een \textit{halve cirkel} (met centrum in de oorsprong en straal 1) tekenen , zonder (reële) knooppunten met meervoudige multipliciteit te moeten gebruiken ? Geef de preciese locatie van de \textit{controlepunten} (op een figuur), hun gewichten, en de corresponderende \textit{knopenvector}. Uit hoeveel segmenten bestaat deze NURBS ?}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		
		\vraag{Toon aan dat deze constructie inderdaad exact een halve cirkel oplevert.}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		
		\vraag{Construeer van deze NURBS de \textit{uniforme} representatie. Vermeld de conversiestappen om tot dit resultaat te bekomen. Waarom is de constructie van de uniforme representatie belangrijk ?}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
	\end{enumerate}

	\section{NURBS constructie van cirkels en lijnsegmenten \accentuate{(§3.4.8 en slides)} }
	\begin{enumerate}
		\vraag{Met welke \textit{NURBS} kun je exact een recht \textit{lijnsegment} door twee punten tekenen ? Geef de preciese locatie van de \textit{controlepunten} (op een figuur), hun gewichten, en de corresponderende \textit{knopenvector}.}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		
		\vraag{Met welke \textit{NURBS} bestaande uit één enkel segment kun je een \textit{halve cirkel} (met centrum in de oorsprong en straal 1) tekenen ? Geef de preciese locatie van de \textit{controlepunten} (op een figuur), hun gewichten, en de corresponderende knopenvector\textit{}. Wat is de graad van deze NURBS ?}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		
		\vraag{Toon aan dat deze constructie inderdaad exact een halve cirkel oplevert.}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		
		\vraag{Met welke \textit{NURBS} bestaande uit één enkel segment kun je exact een \textit{volledige cirkel} (met centrum in de oorsprong en straal 1) tekenen ? Geef de preciese locatie van de \textit{controlepunten} (op een figuur), hun gewichten, en de corresponderende \textit{knopenvector}. Wat is de graad van deze NURBS ?}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
	\end{enumerate}

	\section{Reflectiemodellen \accentuate{(§5.2, behalve §5.2.1.2 en §5.2.1.3) }}
	\begin{enumerate}
		\vraag{Waarom zijn reflectiemodellen noodzakelijk ?}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		
		\vraag{Omschrijf het lokale reflectiemodel (Phong-model). Geef ondermeer de}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		 berekenings-voorschriften, de betekenis van de parameters, en de nadelen.
		 
		\vraag{Geef en omschrijf (in het bijzonder de nadelen) van de drie mogelijke benaderingen voor de berekening van de \textit{lichtintensiteit van zichtbare punten}, indien men het object beschrijft aan de hand van een verzameling \textit{vlakke veelhoeken}.}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		
	\end{enumerate}

	\section{1D Wavelet transformaties}
	\begin{enumerate}
		\vraag{Bespreek met behulp van \textit{Multi-Resolutie-Analyse} de algemene concepten van wavelet transformaties. \accentuate{(§3.5.2)}}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		
		\vraag{Vertaal deze algemene concepten in het bijzonder geval van de \textit{Haar-wavelet} transformatie. \accentuate{(§3.5.1 \& §3.5.2)}}{\begin{itemize} \item \todo{oplossen} \end{itemize}}

		
		\vraag{Bespreek de noodzaak van \textit{spline-wavelets} (1D). Wat is het verband tussen de \textit{Haar-wavelet} transformatie en de \textit{spline-wavelet} transformatie ? Geef een overzicht van de relatieve voor- en nadelen. }{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		
		\vraag{Beschrijf van lage orde 1D \textit{open-uniforme} spline-wavelet transformaties de vorm van achtereenvolgens de \textit{schaalfuncties}, de \textit{wavelets} en de \textit{synthese filters}.}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
	\end{enumerate}

	\section{2D Wavelet transformaties \accentuate{(§4.5.1)}}
	\begin{enumerate}
		\vraag{Bespreek de alternatieve methodes om 2D \textit{schaalfuncties en wavelets} te construeren.}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		
		\vraag{Beschrijf, aan de hand van \textit{contourplotjes}, en voor elk van deze alternatieve methodes, de resulterende \textit{2D Haar-schaalfuncties en Haar-wavelets} van het laagste en het op één na laagste niveau.}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
	\end{enumerate}

	\section{Toepassingen van wavelet transformaties }
	\begin{enumerate}
		\vraag{Geef de meest relevante toepassingen in de computergrafiek van 1D \textit{Haar-wavelet} en 1D \textit{spline-wavelet} transformaties. \accentuate{(§3.5.4)}}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		
		\vraag{	Geef de meest relevante toepassingen in de computergrafiek van 2D \textit{Haar-wavelet} en 1D \textit{spline-wavelet} transformaties. \accentuate{(§4.5.2)}}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
	\end{enumerate}
	
	\chapter{Informatie derde vraag}
	Deze vraag is een \textbf{oefening}, gequoteerd op 1/2 van de totaalpunten, over één of enkele van volgende onderwerpen:
	\begin{itemize}
		\vraag{\accentuate{(1-3)} de Casteljau constructie (van een punt met specifieke parameterwaarde) van een Bézier kromme}{ 	\todo{oplossen}}
		\vraag{\accentuate{(1)} verhoging van de graad van Bézier splines (in één enkele stap); voorafgaand moet het verband tussen de \textit{oude} en de \textit{nieuwe} controlepunten opgesteld worden (vermenigvuldiging met een specifieke matrix, cfr. theorieles)}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		\vraag{\accentuate{(2)} verhoging van de graad van Bézier splines (\textit{stapsgewijs}: één graad verhogen per stap)}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		\vraag{\accentuate{(3,4)} segmentering (subdivisie) van Bézier krommen (eventueel meerdere segmenten in één enkele stap)}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		\vraag{\accentuate{(9-10,14-16)} constructie van de \textit{kromtecirkel} in een punt van een Bézier kromme}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		\vraag{\accentuate{(5-7,9-11)} constructie van de \textit{Bézier representatie} van een (polynomiale) NURBS}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		\vraag{\accentuate{(6-10)} constructie van controlepunten na toevoeging van één of meerdere \textit{reële} knopen in de knopenvector van een (polynomiale) NURBS (zonder over te gaan op de Bézier representatie)}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		\vraag{\accentuate{(10)} constructie van controlepunten na toevoeging van één of meerdere \textit{virtuele} knopen in de knopenvector van een (polynomiale) NURBS (zonder over te gaan op de Bézier representatie)}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		\vraag{\accentuate{(11)} berekening en constructie van de controlepunten van de \textit{open-uniforme} representatie van een (polynomiale) NURBS met een \textit{uniforme} knopenvector}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		\vraag{\accentuate{(12,19)} berekening en constructie van de controlepunten van de \textit{uniforme} representatie van een polynomiale of rationale NURBS met een \textit{open-uniforme} knopenvector}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		\vraag{\accentuate{(12)} de Boor constructie (van een punt met specifieke parameterwaarde) van een (polynomiale) NURBS}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		\vraag{\accentuate{(13)} constructie van de \textit{hodograaf} van een Bézier kromme of spline}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		\vraag{\accentuate{(13-16)} vaststellen van de continuïteit in de knooppunten van Bézier splines (\textit{stelling van Stärk})}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		\vraag{\accentuate{(17)} constructie van de controlepunten van de \textit{uniforme} Lagrange representatie van een Lagrange geïnterpoleerde kromme met \textit{niet-uniforme} knopenvector; schematisch aantonen hoe de berekening van de Bézier representatie van deze kromme zou kunnen uitgevoerd worden (ondermeer opstellen van de \textit{inverse} van de Bézier basismatrix).}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		\vraag{\accentuate{(18,19)} constructie van een  \textit{benadering door lijnstukken} van een uniforme NURBS door toepassing van het algoritme van Lane \& Riesenfeld}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		\vraag{\accentuate{(20)} constructie van een \textit{triangulair schema} met behulp van het veralgemeend algoritme van Neville (voor een specifieke configuratie van inputgegevens), en berekening hieruit van de \textit{gewichtsfuncties} en de \textit{matrixrepresentatie}}{\begin{itemize} \item \todo{oplossen} \end{itemize}}
		
	\end{itemize}
	
\end{document}


