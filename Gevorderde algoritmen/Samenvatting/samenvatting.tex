\documentclass{report}
\usepackage{ugentstyle}

\begin{document}
	\maketitle{Gevorderde algoritmen}
	\tableofcontents
	\part{Gegevensstructuren II}
	\chapter{Efficiënte zoekbomen}
	Vooraleer efficiënte zoekbomen behandeld kunnen worden moet er eerst een fundamentele operatie besproken worden: \textbf{rotaties}. Rotaties wijzigen de vorm van de boom, maar behouden de inorder volgorde van de sleutels. Dit is nodig omdat de eigenschap van een binaire zoekboom steeds voldaan moet zijn, namelijk dat het linkerkind kleiner is, en het rechterkind groter, dan de ouder. Een rotatie is $O(1)$ omdat enkel pointers verplaatst moet worden.
	
	\begin{adjustbox}{valign=t}
		\begin{forest}
			for tree = {draw, circle, node options = {minimum width = 5ex}}
			[p
				[l
					[$\alpha$, rectangle]
					[$\beta$, rectangle]
				]
				[$\gamma$, rectangle]
			]	
		\end{forest}
	\end{adjustbox}\qquad
	\begin{adjustbox}{valign=c}
	$\Leftrightarrow$
	\end{adjustbox}\qquad
	\begin{adjustbox}{valign=t}
		\begin{forest}
			for tree = {draw, circle, node options = {minimum width = 5ex}}
			[l
				[$\alpha$, rectangle]
				[p
					[$\beta$, rectangle]
					[$\gamma$, rectangle]	
				]
			]	
		\end{forest}
	\end{adjustbox}
	
	


	\section{Rood-zwarte bomen}
	Een rood-zwarte boom is een \textbf{binaire zoekboom} waarbij bovendien:
	\begin{itemize}
		\item Elke knoop rood of zwart gekleurd is.
		\item Elke virtuele knoop zwart is. Een virtuele knoop is een ontbrekend kind (nullpointer), die geen gegevens bevatten maar wel een kleur hebben (zwart).
		\item De wortel zwart is (een rode wortel kan zonder problemen zwart gemaakt worden).
		\item Elke mogelijke weg vanuit een knoop naar een virtuele knoop evenveel zwarte knopen heeft \textbf{(zwarte diepte)}.
		\item De hoogte $h$, kan uit de voorgaande definities, afgeleidt worden aangezien elke deelboom met wortel $w$ en zwarte diepte $z$ tenminste $2^z - 1$ inwendige knopen bevat. 
		$$1 + 2 + ... + 2^{z - 1} = 2^z - 1$$ 
		$$n \geq 2^z - 1 \geq 2^{h/2} - 1$$
		$$h \leq 2\lg(n + 1)$$
	\end{itemize}
	\subsection{Operaties}

	\textbf{Zoeken} is equivalent met een gewone binaire boom en is dus $O(\lg n)$. De interessante operaties zijn toevoegen en verwijderen, die beiden zowel bottom-up als top-down kunnen gebeuren:
	\begin{itemize}
		\item \textbf{Bottom-up.}
			Een bottom-up rood-zwarte boom zal eerst een knoop toevoegen of verwijderen, en nadien de boom herstellen.
			\begin{itemize}
				\item \textbf{Toevoegen.}
				Een knoop toevoegen gebeurt op dezelfde manier als bij een normale binaire zoekboom. Een nieuwe toegevoegde knoop krijgt altijd een rode kleur, omdat de zwarte diepte herstellen moeilijker is. Bij het toevoegen van een knoop kunnen er zich zes gevallen voordoen, waarvan er drie het spiegelbeeld zijn van elkaar. Hier wordt veronderstelt dat de ouder $p$ van de toegevoegde knoop $c$ het linkerkind is van grootouder $g$, en dus de broer $b$ van $p$ het rechterkind is van $g$. 
				\begin{enumerate}
					\item Indien $b$ rood is, kan eenvoudig $p$ en $b$ zwart gemaakt worden, terwijl $g$ rood gemaakt wordt. Indien $g$ een zwarte ouder heeft is de situatie opgelost. Is dit niet het geval, wordt het probleem opgeschoven naar boven, alsof het lijkt dat $g$ de toegevoegde knoop is want die is nu rood. De ligging van $c$ ten opzichte van $p$ heeft in dit geval geen impact. 
					\item Indien $b$ zwart is, kunnen er zich twee gevallen voordoen:
					\begin{enumerate}
						\item Indien $c$ aan de uitwendige kant ligt van $p$, liggen de drie knopen $g$, $p$ en $c$ op een lijn en moet er een rotatie naar rechts uitgevoerd worden. Deze rotatie wordt gevolgd door $p$ zwart en $g$ rood te kleuren.
						\item Indien $c$ aan de inwendige kant ligt van $p$, dan moet enkel $p$ en $c$ naar links geroteerd worden, zodat we het vorige geval krijgen ($c$ is nu wel de ouder van $p$).
					\end{enumerate}
				\end{enumerate}
				\item \textbf{Verwijderen.} Ook wordt deze operatie eerst uitgevoerd zoals bij een normale binaire zoekboom. Indien de ffysisch te verwijderen knoop rood is, is verwijderen eenvoudig aangezien de zwarte hoogte ongewijzigd blijft.
			\end{itemize}
		
		\item \textbf{Top-down.}
			Een top-down rood-zwarte boom zal op de zoekweg ook al de boom herstellen.
			\begin{itemize}
				\item \textbf{Toevoegen.} Op de weg naar beneden mogen we geen rode broers toelaten, aangezien de nieuwe knoop kind van beide kan zijn. Wanneer er op de zoekweg een zwarte knoop $c$ met twee rode kinderen voorkomt, kan $c$ rood gemaakt worden en zijn kinderen zwart, indien de ouder $p$ van $c$ ook rood is, en $c$ ligt aan de butienkant, moet $p$ geroteerd worden, zodat $p$ de ouder is van $c$ en $g$, de oorspronkelijke ouder van $p$. Ligt $c$ aan de binnenkant, dan wordt eerst $c$ geroteerd, zodat deze de ouder wordt van $p$, gevolgd door een bijkomende rotatie rond $c$ zodat $c$ als kinderen $p$ en $g$ heeft. De knoop $c$ wordt terug zwart gemaakt en $g$ wordt rood gemaakt. 
				\item \textbf{Verwijderen.}
			\end{itemize}
	\end{itemize}

	\section{Splaybomen}
	Een splayboom is een normale binaire zoekboom, waarbij er een splayoperatie gedefinieerd is: een reeks van operaties zodat de meest recente opgevraagde knoop $\alpha$ in de wortel staat. Bij splaybomen heeft zoeken ook een bottom-up en top-down versie.
		\subsection{Operaties}
	\begin{itemize}
\item \textbf{Bottom-up.} De splayoperatie bij een bottom-up splayboom maakt gebruik van drie rotaties:
 \textbf{zig}, dat enkel uitgevoerd wordt indien de ouder $p$ van $\alpha$ de wortel is van de boom. Deze rotatie is een normale rotatie zodat $\alpha$ de wortel wordt, en $p$ één van de kinderen van $\alpha$, \textbf{zig-zig}, dat uitgevoerd wordt indien $p$ nog een ouder $g$ heeft en $\alpha$ aan de inwendige kant light. De eerste rotatie roteert $\alpha$ naar de buitenkant, zodat deze de ouder wordt van $p$, gevolgd door een rotatie die $\alpha$ de ouder maakt van $p$ en $g$ en \textbf{zig-zag}, dat uitgevoerd wordt indien $\alpha$, $p$ en $g$ op dezelfde lijn liggen (dus $\alpha$ is uitwendig). De eerst rotatie roteer $g$, zodat $p$ de ouder is van $\alpha$ en $g$, gevolgd door een rotatie die $c$ de ouder maakt van $p$ (die nog steeds $g$ als kind heeft).
	
			\begin{itemize}
				\item \textbf{Zoeken.} Bottom-up zoeken is equivalent met een normale binaire zoekboom, gevolgd door de splayoperatie die de gezochte knoop tot wortel maakt. Als de gezochte sleutel niet bestaat, wordt de splayoperatie uitgevoerd op zijn voorloper of opvolger.
				\item \textbf{Toevoegen.} Toevoegen zal eerst de fysische knoop toevoegen aan de boom. Deze toegevoegde knoop wordt dan met de splayoperatie tot wortel gemaakt.
				\item \textbf{Verwijderen.} Eerst wordt de fysisch te verwijderen knoop verwijdert. De ouder van deze knoop wordt nu via de splayoperatie tot wortel gemaakt. De ouder is ook de laatste knoop op de zoekweg, zodat indien de te verwijderen knoop niet bestaat, nog steeds deze ouder tot wortel gemaakt wordt.
			\end{itemize}
		\item \textbf{Top-down.} Een top-down splayboom maakt geen gebruik van rotaties, zodat er geen nood is aan ouderwijzers of stapels. De splayoperatie bij een top-down splayboom deelt de boom op in drie zoekbomen: $L$, die alle sleutels kleiner dan de sleutels in $M$ bevat, en $R$, die alle sleutels groter dan de sleutels in $M$ bevat. Initieël is $M$ de oorspronkelijke boom en zijn $R$ en $L$ ledig. De zoekweg begint bij de wortel van $M$, en er wordt voor gezorgt dat de huidige knoop op de zoekweg steeds de wortel van $M$ is ,zodat op het einde van het zoeken, de gezochte sleutel (of zijn voorloper of opvolger) de wortel is van de uiteindelijke splayboom.
		
		Top-down splaybomen kennen 6 operaties, waarvan er ook weer drie het spiegelbeeld zijn van elkaar. Veronderstel dat we vanuit een knoop $p$ (die op dat moment de wortel van $M$ is) naar het linkerkind $c$ moeten, dan kunnen volgende gevallen zich voordoen:
		\begin{enumerate}
			\item De knoop $c$ is de laatste knoop op de zoekweg. Dit komt enkel voor indien $c$ gezocht wordt, of als hij geen kind heeft in de richting dat gezocht moet worden. Knoop $p$, samen met zijn rechtste deelboom wordt het nieuwe kleinste element in $R$. De linkse deelboom van $p$ wordt de niewe $M$ met $c$ als wortel. Dit geval wordt ook weer \textbf{zig} genoemd, maar heeft dus wel een heel andere implementatie dan de zig bij bottom-up splaybomen.
			\item Linkerkind $c$ is niet de laatse knoop op de zoekweg. 
			\begin{enumerate}
				\item Indien afgedaald moet worden naar het linkerkind $l$ van $c$, dan wordt eerst $p$ en $c$ naar rechts geroteerd, daarna wordt $c$, samen met zijn rechtse deelboom, het nieuwe kleinste element in $R$. De linkse deelboom van $c$ wordt de nieuwe $M$. Dit geval heet ook opnieuw \textbf{zig-zig}, aangezien de knopen op één lijn liggen.
				\item Indien afgedaald moet worden naar het rechterkind $r$ van $c$, dan wordt $p$, samen met zijn rechtste deelboom, het nieuwste kleinste element van $R$. Daarna wordt $c$ het nieuwe grootste element in $L$, en de rechtste deelboom van $c$ wordt de nieuwe $M$. Dit geval heet \textbf{zig-zag}.
			\end{enumerate}
		\end{enumerate}
		Na deze operaties moeten de deelbomen nog samengevoegd worden, waarbij de wortel $c$ is. Alle sleutels in de linkerdeelboom van $c$ zijn groter dan die van $L$, dus kan $L$ deze linkerdeelboom opnemen. Analoog zijn alle sleutels in de rechterdeelboom van $c$ kleiner dan die van $R$, dus kan $R$ deze rechterdeelboom opnemen. Het linkerkind van $c$ wordt nu de wortel van $L$ en het rechterkind wordt de wortel van $R$.
		De operaties verlopen nu als volgt:
			\begin{itemize}
				\item \textbf{Zoeken.} Deze operatie maakt de gezochte sleutel tot wortel, of indien deze niet gevonden wordt, door zijn voorloper of opvolger.
				\item \textbf{Toevoegen.} De voorloper of opvolger van de nieuwe sleutel wordt wortel, en de nieuwe knoop krijgt als linkerkind de voorloper met zijn linkse deelboom en als rechterkind zijn rechtste deelboom. Of alternatief, de nieuwe knoop krijgt als rechterkind de opvolger met zijn rechtste deelbom en als linkerkind zijn linkse deelboom.
				\item \textbf{Verwijderen.} Eerst wordt de sleutel gezocht, zodat die wortel wordt. Daarna wordt deze wortel verwijderd en worden de twee deelbomen terug samengevoegd.
			\end{itemize}
	\end{itemize}
	\subsection{Performantie}
	\todo{dit is niet belangrijk voor de test.}
	\section{Randomized Search Trees}
	\accentuate{kans is klein dat hij dit vraagt}
	\chapter{Toepassingen van dynamisch programmeren}
	\section{Langste gemeenschappelijke deelsequentie}
 Voor twee strings $X = \langle x_0, x_1, ... x_{n - 1} \rangle$ en $Y = \langle y_0, y_1, ... y_{m - 1} \rangle$ waarbij $x_i$ en $y_i$ individuele karakters zijn, kan men de langste gemeenschappelijke deelsequentie bepalen door een stringelementen weg te laten, zodat beide strings gelijk zijn. Dit probleem heeft een optimale deelstructuur: de deelproblemen zijn paren prefixen van de twee strings. Stel $X_i$ de prefix met lengte i en $X_0$ de ledige prefix. Analoog geldt hetzelfde voor $Y$. Beschouw nu $Z = \langle z_0, z_1, ..., z_{k - 1} \rangle$, dan zijn er drie mogelijkheden:
 \begin{enumerate}
 	\item Als $n = 0$ of $m = 0$ dan is $k = 0$.
 	\item Als $x_{n - 1} = y_{m - 1}$ dan is $z_{k - 1} = x_{n - 1} = y_{m - 1}$, met gevolg dat $Z_{k - 1}$ een LGD is van $X_{n - 1}$ en $Y_{n - 1}$.
 	\item Als $x_{n - 1} \neq y_{m - 1}$ :
 	\begin{enumerate}
 		\item $Z$ is ofwel een LGD van $X_{n - 1}$ en $Y$ ,met $z_{k - 1} \neq x_{n - 1}$, of,
 		\item $Z$ is een LGD van $X$ en $Y_{m - 1}$, met $z_{k - 1} \neq y_{m - 1}$.
 	\end{enumerate}
  \end{enumerate}
 	Dit kan opgesteld worden als een recursieve vergelijking, waarbij $c[i, j]$ de lengte van de LGD voorstelt:
 	
 	$$c[i, j] = \begin{cases}
 	0 & \hbox{als i = 0 of j = 0}\\
 	c[i - 1][j - 1] & \hbox{als } i > 0 \hbox{ en } j > 0 \hbox{ en } x_i = y_j \\
 	max(c[i, j - 1], c[i - 1, j]) & \hbox{als } i > 0 \hbox{ en } j > 0 \hbox{ en } x_i \neq y_j
 	\end{cases}$$
 	Uitgewerkt op de woorden \textbf{LOUIS} en \textbf{ALOYSIUS}:
 	$$\begin{matrix} & & A & L & O & Y & S & I & U & S \\ & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ L & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\ O & 0 & 0 & 1 & 2 & 2 & 2 & 2 & 2 & 2\\ U & 0 & 0 & 1 & 2 & 2 & 2 & 2 & 3 & 3\\ I & 0 & 0 & 1 & 2 & 2 & 2 & 3 & 3 & 3\\ S & 0 & 0 & 1 & 2 & 2 & 3 & 3 & 3 & 4\\ \end{matrix}$$
 	\chapter{Uitwendige gegevensstructuren}
 	\section{B-trees}
 	Een B-tree is een uitwendige evenwichtige meerwegszoekboom met een zeer kleine hoogte waarbij elk blad op dezelfde diepte zit. Meestal wordt er geheugenruimte voorzien voor de wortel en de meest recent gebruikte knopen. Vooraleer knopen kunnen bewerkt worden moeten deze eerst ingeladen worden aan de hand van een welbepaalde paginaindex, en door de grootte van een knoop, bevat het geheugen best zo weinig mogelijk knopen. Overbodige knopen worden terug weggeschreven, indien deze gewijzigd werden, en uit het geheugen verwijderd.
 	\subsection{Definitie}
 	Een B-tree van orde $m$, waarbij $m > 2$, wordt als volgt gedefinieerd:
 	\begin{itemize}
 		\item Elke inwendige knoop heeft hoogsten $m$ kinderen.
 		\item Elke inwendige knoop, behalve de wortel, heeft minstens $\lceil m/2 \rceil$ kinderen, tenzij hij een blad is.
 		\item Elk blad zit op hetzelfde niveau
 	\end{itemize} 
    Elke knoop bevat dan:
    \begin{itemize}
    	\item Een getal $k = m - 1$ dat aanduidt hoeveel sleutels in de knoop zitten.
    	\item Een tabel met maximaal $k$ sleutels, die niet dalend gerangschikt zijn. Een tweede tabel van dezelfde grootte voor de informatie bij elke sleutel bij te houden. 
    	\item Een tabel voor maximaal $m$ wijzers naar de kinderen van de knoop. 
    	\item Een logische waarde $b$ die aanduidt of de knoop een blad is.
    \end{itemize}
	\subsection{Eigenschappen}
	Het minimaal aantal sleutels $n$ kan eenvoudig berekend worden. veronderstel een boom met hoogte $h$ en $g = \lceil m/2 \rceil$. De wortel van de minimale boom heeft slechts één sleutel en twee kinderen. Elk van die kinderen heeft minimaal $g$ kinderen, die op hun beurt ook minimaal $g$ kinderen hebben, enz. Het \textbf{aantal knopen} wordt dus:
	$$1 + 2g + ... + 2g^{h - 1} = 1 + 2 \sum_{i = 0}^{h - 1} g^i$$
	Aangezien elke knoop minstens $g - 1$ sleutels heeft, behalve de wortel, kan $n$ geschreven worden als (zie 2.3.3 Afschattingen met sommen Algoritmen I cursus):
	$$n \geq 1 + (g - 1)\bigg(\frac{g^h - 1}{g - 1}\bigg)$$
	$$n \geq 2g^h - 1$$
	$$h \leq log_{g} \frac{n + 1}{2}$$
	De hoogte is dus $O(\lg n)$.
	\subsection{Operaties}
	\subsubsection{Zoeken}
	Elke knoop op de zoekweg moet ingelezen worden. Allereerst wordt er nagegaan of de sleutel in deze knoop zit (via lineair of binair zoeken). Als de gezochte sleutel niet in de knoop zit, moet de volgende knoop ingeladen worden. De wijzer van de volgende knoop staat op dezelfde index in de kindtabel als waar de niet gevonden sleutel zou moeten zitten in de sleuteltabel. Is de huidige knoop een blad en zit de gezochte sleutel niet in dit blad, dan zit de sleutel niet in de boom. 
	\subsubsection{Toevoegen}
	Enkel de \textbf{bottom-up} methode wordt besproken aangezien de top-down versie minder vaak gebruikt wordt, maar wel handig is indien meerdere gebruikers aan de boom moeten, omdat knopen op de zoekweg dan vroeger worden vrijgegeven. Toevoegen gebeurt altijd in een blad en vormt geen probleem zolang dit blad nog plaats heeft. Is dit blad vol, wordt de knoop gesplitst rond de middelste sleutel van knoop. Sleutels die zich rechts van deze middelste sleutel bevinden, worden in een nieuwe knoop ondergebracht, dat ook een blad wordt. Sleutels die zich links van de middenste sleutel bevinden, blijven in het blad. De middelste sleutel zelf wordt nu verwijderd van de knoop, en toegevoegd bij de ouderknoop van de gesplitste knoop, zodat hetzelfde proces zich kan herhalen. Elke splitsing kost drie schijfoperaties. In het slechtste geval wordt het probleem helemaal tot de wortel opgeshoven, zodat er een nieuwe knoop wordt aangemaakt, met slechts één element, die nu de wortel wordt van de B-tree.
	\subsubsection{Verwijderen}
	Ook bij verwijderen wordt enkel de \textbf{bottom-up} methode besproken. Een sleutel wordt enkel maar verwijderd indien deze in een blad zit. Deze strategie moet dus de te verwijderen sleutel vervangen met zijn voorloper of opvolger omdat die altijd in een blad zitten, maar de meeste sleutels zitten in bladeren, zodat dit meestal geen probleem vormt. Wanneer een knoop te weinig sleutels heeft $< \lceil m/2 \rceil$ dan kan men proberen sleutels over te nemen van één van de twee broerknopen. De sleutel van de broer gaat naar zijn ouder, een sleutel van de ouder gaat naar de knoop, die ook een kindwijzer van de broer overneemt. Omdat hier drie knopen worden aangepast, is het beter om meerdere sleutels op die manier te roteren, zodat elke knoop evenveel sleutels heeft. Indien geen van beide broers een sleutel kan afstaan, wordt de knoop samengevoegd met een broer, zodat de ouder een kind verliest. De sleutel die ervoor zorgde dat deze knoop bereikbaar was, wordt toegevoegd aan de samengevoegde knoop en verwijderd uit de ouderknoop.
	\subsection{Varianten}
	\begin{itemize}
		\item \textbf{B$^{+}$-tree.} Deze variant zal enkel sleutels opslaan in de bladeren zodat inwendige knopen enkel gebruikt worden als index om deze sleutels te lokaliseren. Bovendien is er een gelinkte lijst van alle bladeren in stijgende sleutelvolgorde. Omdat inwendige knopen enkel dienen als index, moeten ze minder informatie bevatten. Bladeren moeten ook geen plaats reserveren voor kindwijzers, zodat ze meer gegevens kunnen bevatten.
		\item \textbf{Prefix B$^+$-tree.} Deze variant wordt gebruik indien de sleutels strings zijn. De inwendige knopen bevatten een zo kort mogelijke string, meestal een prefix van de te onderscheiden strings.
		\item \textbf{B$^*$-tree.} Deze variant zal bij de splitsoperatie de gegevens over drie knopen verdelen, in plaats van twee knopen. Beter gevulde knopen betekent een minder hoge boom.
	\end{itemize}
\section{Uitwendige Hashing}
\subsection{Extendible hashing}
Deze methode bevat een hashtabel in het geheugen. Deze tabel bevat wijzers naar de schfijpagina's, die maximaal $m$ sleutels met bijhorende gegevens kunnen bevatten. De hashwaarde zijn gehele getallen, met als bereik de breedte van een processorwoord $w$. De laatste $d$ bits worden gebruikt als indicies in de hashtabel, zodat de tabel $2^d$ elementen bevat. Deze $d$ is dan ook de globale diepte van de hashtabel en komt overeen met de langste prefix. Alle sleutels waarvan de hashwaarde op dezelfde $d$ bits eindig, komen in dezelfde pagina. Meerdere tabelelementen mogen naar dezelfde pagina verwijzen, daarom wordt er bij elke pagina ook de lokale diepte $k$ bijgehouden: het aantal bits waarmee al haar hashwaarden eindigen. Op die manier bevat elke pagina $2^{d - k}$ elementen.

\begin{itemize}
	\item \textbf{Zoeken.} Zoeken van de sleutel komt neer op het hashen van deze sleutel, en de overeenkomstige schijfpagina te vinden, en dan deze pagina sequentieel te doorzoeken. 
	\item \textbf{Toevoegen.} Toevoegen gebeurt analoog, waarbij gemiddeld de helft van de gegevens in een pagina moeten opschuiven. Indien de pagina vol geraakt moet er gesplitst worden. Deze splitsing gebeurt volgens de waarde van bit $k + 1$. Gegevens waarvoor die bit 1 is worden overgebracht naar een nieuwe gecreëerde pagina, beide met een $k$ dat één groter is als de oorspronkelijke pagina. Nu zijn er nog twee gevallen:
	\begin{itemize}
		\item[*] $k - 1 \leq d$: De helft van de wijzers naar de oude pagina moeten vervangen worden door de nieuwe pagina, maakt niet uit de welke.
		\item[*] $k - 1 = d$: Er was slechts één wijzer naar de oude pagina, en omdat $k$ nu groter is dan $d$, moet $d$ ook met één toenemen, en de grootte van de hashtabel moet verdubbelt worden. Elke index wordt nu één bit langer, zodat er twee nieuwe indices uit onstaan. De tabelelementen bij beide indicies moeten naar dezelfde pagina verwijzen als de oorspronkelijke index.
	\end{itemize}
	\item \textbf{Verwijderen.} Indien een pagina, na verwijdering van een element, samen met haar broer minder dan $m$ sleutels bevat, moeten deze samengevoegd worden.
\end{itemize}
\subsection{Linear hashing}
De $d$ eindbits worden niet meer als index in een hashtabel, maar rechtstreeks als adres van een pagina gebruikt.  


\chapter{Meerdimensionale gegevensstructuren}
Notatie: $k$ = aantal dimensies en $n$ = aantal punten.
\section{Projectie}
Deze methode gebruikt per dimensie een gegevensstructuur die alle punten gerangschikt bijhoudt volgens die dimensie. Zoeken gebeurt door een dimensie te kiezen, en alle punten te selecteren die binnen zijn zijde voor die dimensie vallen. Die punten worden dan sequentieel overlopen.
\section{Rasterstructuur}
Deze methode verdeelt de zoekruimte in regelmatige rastergebieden en kan geïmplementeerd worden met een meerdimensionale tabel. Elk rastergebied heeft een gelinkt lijst met punten die in dat gebied liggen, maar kan juist hierdoor onnodig veel geheugen innemen.
\section{Quadtrees}
Deze soort bomen verdeelt de zoekruimte in $2^k$ hyperrechthoeken en was origineel ontworpen voor 2 dimensies. Deze verdeling wordt opgeslagen in een $2^k$-wegsboom. Elke knoop staat voor een gebied, dat onderverdeeld wordt in de $2^k$ deelgebieden van zijn kinderen. Voor grote $k$ zijn quadtrees niet geschikt, daarom wordt enkel twee dimensies besproken.
\subsection{Point quadtrees}
In deze versie bevat elke knoop een punt. De coördinaten van dit punt delen het gebied op in 4 rechthoeken. De vorm is afhankelijk van de toevoegvolgorde, zodat slechtste geval $O(1)$ is. Zoeken naar een punt vergelijkt telkens het zoekpunt met de punten bij de opeenvolgende knopen, en daalt eventueel af naar het kind met het gepaste deelgebied.
\subsection{Point-Region quadtrees}
Deze vorm vereist dat de zoekruimte een rechthoek is omdat elke knoop de ruimte in vier gelijke rechthoeken verdeelt, zodat elk deel nul of één punt bevat. Inwendige knopen bevatten geen punten. Hier is de vorm onafhankelijk van de toevoegvolgorde, maar kan wel evenwichtig uitvallen. Het is onmogelijk om de hoogte en grootte in functie van het aantal punten uit te drukken.
\subsection{k-d trees}
Een k-d tree gebruikt een binaire boom, waarbij op elk niveau de dimensies afgewisselt wordt. Elke inwendige knoop bevat dan ook één punt, die de zoekruimte verdeelt in de dimensie voor dat niveau. Ideale opsplitsting bestaat uit gelijkmatige verdeling van de dimensies. In twee dimensies zal elk niveau dus afwisselend de x-dimensie en de y-dimensie beschouwen. 

\chapter{Samenvoegbare heaps}
\todo{k}

\part{Grafen II}
\chapter{Toepassingen van diepte-eerst zoeken}
\section{Enkelvoudige samenhang van grafen}
\subsection{Samenhangende componenten van een ongerichte graaf}
Een \textbf{samenhangende ongerichte graaf} is een graaf waarbij er een weg bestaat tussen elk paar knopen. Een \textbf{niet samenhangende ongerichte graaf} bestaat dan uit zo groot mogelijke samenhangende componenten.

\subsection{Sterk samenhangende componenten van een gerichte graaf}
Een \textbf{sterk samenhangende gerichte graaf} is een graaf waarbij er een weg tussen elk paar knopen in beide richtingen bestaat. Een \textbf{zwak samenhangende gerichte graaf} is een graaf die niet sterk, maar toch samenhangend is indien de richtingen buiten beschouwing gelaten worden. Een graaf die niet sterk samenhangend is, bestaat uit zo groot mogelijke sterk samenhangende componenten. 

Sommige algoritmen gaan ervan uit de een graaf sterk samenhangend is. Men moet dus eerst deze componenten bepalen, meestal via een \textbf{componentengraaf}, die een knoop heeft voor elk sterk samenhangend component, en een verbinding van knoop $a$ naar knoop $b$ indien er in de originele graaf een verbinding van één van de knopen van $a$ naar één van de knopen van $b$ is. 

De sterk samenhangende componenten kunnen bekomen worden met behulp van diepte-eerst zoeken:
\begin{enumerate}
	\item Stel de omgekeerde graaf op, door de richting van elke verbinding om te keren.
	\item Pas diepte-eerst zoeken toe op deze omgekeerde graaf, waarbij de knopen in postorder genummered worden.
	\item Pas diepte-eerst zoeken toe op de originele graaf, met als startknoop de resterende knoop met het hoogste postordernummer. Het resultaat is een diepte-eerst bos, waarvan de bomen sterk samenhangende componenten zijn.
\end{enumerate}
Diepte-eerst zoeken is $\Theta(n + m)$ voor ijle en $\Theta(n^2)$ voor dichte grafen. Het omkeren van de graaf is ook $\Theta(n + m)$ voor ijle en $\Theta(n^2)$ voor dichte grafen.
\section{Dubbele samenhang van ongerichte grafen}
Twee definities:
\begin{itemize}
	\item \textbf{Brug.} Een brug is een verbinding dat, indien deze wordt weggenomen, de graaf in twee deelgrafen opsplitst. Een graaf zonder bruggen noemt men \underline{dubbel lijnsamenhangend}; als er tussen elk paar knopen minstens twee onafhankelijke wegen bestaan, dan is een graaf zeker dubbel lijnsamenhangend.
	\item \textbf{Scharnierpunt.} Een scharnierpunt is een knoop dat, indien deze wordt weggenomen, de graaf in ten minste twee deelgrafen opsplitst. Een graaf zonder scharnierpunten noemt men \underline{dubbel knoopsamenhangend} (of dubbel samenhangend). Een graaf met scharnierpunten kan onderverdeeld worden in dubbel knoopsamenhangende componenten. Als er tussen elk paar knopen twee onafhankelijke wegen bestaan, dan is de graaf dubbel knoopsamenhangend.
\end{itemize}

Scharnierpunten, dubbel knoopsamenhangende componenten, bruggen en lijnsamenhangende componenten kunnen opnieuw via diepte-eerst zoeken gevonden worden:
\begin{enumerate}
	\item Stel de diepte-eerst boom op, waarbij de knopen in postorder genummerd worden. 
	\item Bepaal voor elke knoop $u$ de laagst genummerde knoop die vanuit $u$ kan bereikt worden via een weg bestaande uit nul of meer dalende boomtakken gevolgd door één terugverbinding. 
	\item Indien alle kinderen van een knoop op die manier een knoop kunnen bereiken die hoger in de boom ligt dan hemzelf, dan is de knoop zeker niet samenhangend. De wortel is een scharnierpunt indien hij meer dan één kind in heeft.
\end{enumerate}
Diepte-eerst zoeken is $\Theta(n + m)$ voor ijle en $\Theta(n^2)$ voor dichte grafen.
\section{Eulergraaf}
Een eulercircuit is een gesloten omloop in een graaf die alle verbindingen éénmaal bevat. Een eulergraaf is een graaf met een eulercircuit, die volgende eigenschappen heeft:
\begin{itemize}
	\item De graaf is knoopsamenhangend.
	\item De graad van elke knoop is even.
	\item De verbindingen kunnen onderverdeeld worden in lussen, waarbij elke verbinding slechts behoort tot één enkel lus.
\end{itemize}

\chapter{Kortste Afstanden II}
\section{Kortste afstanden vanuit één knoop}
\subsection{Algoritme van Bellman-Ford}
Dit algoritme werkt voor verbindingen met negatieve gewichten, iets wat het algoritme van Dijkstra niet kon \accentuate{(Dijkstra gebruikt het feit dat indien een pad naar A $\rightarrow$ C bestaat, er geen korter pad A $\rightarrow$ B $\rightarrow$ C kan zijn, daarom is het algoritme performant, maar er mogen dus geen negatieve verbindingen zijn)}.
\chapter{Stroomnetwerken}
\begin{itemize}
	\item Gerichte graaf met twee speciale knopen: \underline{producent} en \underline{verbruiker}.
	\item Producent levert een bepaald materiaal aan verbruiker via de gerichte verbindingen van de graaf.
	\item Elke verbinding heeft een capaciteit $c(i, j)$ dat positief is, en de stroom $s(i, j)$ dat er door loopt ($0 \leq s(i, j) \leq c(i, j)$). 
	\item Verbindingen die niet bestaan, worden toch voorgesteld als een verbinding, maar met $c = 0$, zodat er geen stroom kan doorlopen. Dit maakt implementaties eenvoudiger.
	\item Een knoop bevat geen capaciteit, en kunnen hierdoor niets opslaan.
\end{itemize}
\section{Maximalestroomprobleem}
= zoveel mogelijk materiaal van producent naar verbruiker laten stromen, zonder de capaciteit van de verbinding te overschrijden.
\begin{itemize}
	\item Methode van \textbf{Ford-Fulkerson} \accentuate{('methode' aangezien manier om vergrotende paden te zoeken ontbreekt).}
	\item Iteratieve methode. Bij elke iteratie neemt netstroom vanuit producent toe.
	\item Stel de verzameling van knopen $K$, dan is de totale nettostroom $f$ uit de producent $p$ \accentuate{(De som van het materiaal dat toekomt min het materiaal dat toekomt voor elke knoop)}. 
		$$f = \sum_{j \in K} (s(p, j) - s(j, p))$$
	\item De stroomverdeling is het geheel van alle stromen voor alle mogelijke knopenparen. 
	\item Het restnetwerk is een nieuw netwerk dat verkregen wordt door uit de huidige stroomverdeling een overzicht op te stellen van de mogelijke stroomtoename tussen elk paar knopen. Het restnetwerk bevat dezelfde knopen, maar niet noodzakelijk dezelfde verbindingen en capaciteit.
\end{itemize}
Het algoritme verloopt als volgt:
\begin{enumerate}
	\item Initiële stroomverdeling is nul. Het restnetwerk is initieël de volledige graaf.
	\item Bij elke iteratie wordt de huidige stroomverdeling en de verschillende capaciteiten gebruikt om een restnetwerk op te stellen.
	\item In dit restnetwerk wordt een vergrotend pad gezocht: een weg van producent naar verbruiker die nog meer stroom tussen beide toelaat.
	\item Als er geen vergrotende paden kunnen gevonden worden, stopt de iteratir, en zal de netwerkstroom maximaal zijn.
\end{enumerate}
https://www.youtube.com/watch?v=Tl90tNtKvxs



Hoe gaan we vergrotende weg zoeken? 
\begin{itemize}
	\item \textbf{Performantie afhankelijk van de capaciteiten}
		\begin{itemize}
			\item Stel dat alle capaciteiten geheel zijn en $C$ de grootste capaciteit voorstelt. Restnetwerk bepalen is $O(m)$, en daarin diepte-eerst of breedte-eerst zoeken naar een vergrotend pad is ook $O(m)$. Aantal iteraties in Ford-Fulkerson is $O(nC)$, dus totale performantie is $O(nmC)$, wat \underline{niet performant is voor grote $C$}.
			\item Neem de het vergrotend pad die de grootste stroomtoename mogelijk maakt, dan wordt het aantal iteraties $O(m\lg C)$ \accentuate{(zonder bewijs)}. Om die weg te vinden volstaat een kleine aanpassing aan het algoritme van Dijkstra: kortste afstand vervangen door grootste capaciteit, zodat de iteratiestap $O(m \lg n)$ \accentuate{(van Dijkstra)} is. De totale performantie is nu $O(m^2 \lg C \lg n)$
			\item Een vergrotende weg bepalen die een stroomtoename van minsten $c$, de cut-off, eenheden toelaat, of besluiten dat deze weg niet bestaat, kan in $O(m)$. Indien geen enkele weg meer gevonden wordt, dan is de minimale snedecapaciteit van het restnetwerk lager dan $mc$. Halveer $c$ en gaan opnieuw op zoek, maar nu naar verbindingen die de helft van de oorspronkelijke $c$ kunnen bevatten. Begin met ondergrens $c = 2^{\lfloor \lg C \rfloor}$, deze in elke fase halveren, en eindigen met één, dan wordt de maximale stroom bereikt met $O(m \lg C)$ iteraties.
		\end{itemize}
	\item \textbf{Performantie onafhankelijk van de capaciteiten}

		Deze methode is enkel \underline{interessant wanneer $C$ groot is}. Als de vergrotende weg steeds het minimum aantal verbindingen heeft, dan kan men aantonen \accentuate{(zonder bewijs)} dat de lengte van de vergrotende wegen na hoogsten $m$ iteraties stijg, en aangezien de maximale lengte $n - 1$ is, volstaan $O(nm)$ iteraties. Deze iteratiestep gebruikt ook breedte-eerst zoeken en is $O(m)$, zodat de totale performantie $O(nm^2)$ wordt.
\end{itemize}
\todo{tododo}

\chapter{Koppelen}
= een deelverzameling van de verbindingen waarin elke knoop hoogstens eenmaal voorkomt. Een maximale koppeling is een koppeling met het grootste aantal verbindingen. Soms hebben verbindingen ook een gewicht.
\section{Koppelen in tweeledige grafen}
Tweeledige graaf (of bipartiete graaf) = een ongerichte graaf waarbij de knopen in twee deelverzamelingen $L$ en $R$ kunnen verdeeld worden, zodat alle verbindingen steeds een knoop uit $L$ met een knoop uit $R$ verbinden.
\subsection{Ongewogen koppeling}
\begin{itemize}
\item Een knoop uit $L$ kan slechts met één knoop uit $R$ verbonden worden. Een maximale ongewogen koppeling zal zoveel mogelijk knopen uit $L$ met $R$ verbinden. 

\item Is eenvoudiger op te lossen met behulp van een stroomnetwerk. Daarom moet eerst de bipartiete graaf omgezet worden in een stroomnetwerk:
	\begin{itemize}
		\item Voer een producent $P$ in, die met alle knopen van $L$ verbonden wordt ($P \rightarrow L$).
		\item Voer een verbruiker $V$ in, die met alle knopen van $R$ verbonden wordt ($R \rightarrow V$).
		\item De oorspronkelijke verbindingen van de graaf krijgen nu een gerichte verbinding van $L$ naar $R$.
		\item De capaciteiten van elke verbinding wordt 1.
	\end{itemize}
	\begin{tikzpicture}[scale=1.5, every node/.style={circle, fill=blue!20},
		nocolor/.style={fill=none}
								 ]
		\node (L1) at (1, 0) {}; 
		\node (L2) at (1, -1) {};
		\node (L3) at (1, -2) {};
		\node (L4) at (1, -3) {};
		\node (L5) at (1, -4) {};

		\node (R1) at (2, 0) {}; 
		\node (R2) at (2, -1) {};
		\node (R3) at (2, -2) {};
		\node (R4) at (2, -3) {};
		\node (R5) at (2, -4) {};

		\draw (L1) -- (R2);
		\draw (L2) -- (R3);
		\draw (L3) -- (R1);
		\draw (L4) -- (R4);
		\draw (L5) -- (R5);

		\node (P) at (4, -2) {P};

		\node (A1) at (5, 0) {}; 
		\node (A2) at (5, -1) {};
		\node (A3) at (5, -2) {};
		\node (A4) at (5, -3) {};
		\node (A5) at (5, -4) {};

		\node (B1) at (6, 0) {}; 
		\node (B2) at (6, -1) {};
		\node (B3) at (6, -2) {};
		\node (B4) at (6, -3) {};
		\node (B5) at (6, -4) {};

		\node (V) at (7, -2) {V};

		\node (x) [nocolor] at (2.5, -2) {};
		\node (y) [nocolor] at (3.5, -2) {};

		\draw[->] (P) -- node[nocolor, yshift=1cm]{1} (A1);
		\draw[->] (P) -- node[nocolor , yshift=0.5cm]{1} (A2);
		\draw[->] (P) -- node[nocolor, yshift=0.2cm]{1} (A3);
		\draw[->] (P) -- node[nocolor , yshift=-0.5cm]{1} (A4);
		\draw[->] (P) -- node[nocolor , yshift=-1cm]{1} (A5);
		\draw[->] (A1) -- node[nocolor]{1} (B2);
		\draw[->] (A2) -- node[nocolor]{1} (B3);
		\draw[->] (A3) -- node[nocolor]{1} (B1);
		\draw[->] (A4) -- node[nocolor]{1} (B4);
		\draw[->] (A5) -- node[nocolor]{1} (B5);

		\draw[->] (B1)-- (V); 
		\draw[->] (B2) -- (V);
		\draw[->] (B3) -- (V);
		\draw[->] (B4) -- (V);
		\draw[->] (B5) -- (V);

		\draw[->] (x) -- (y);
	\end{tikzpicture}
\end{itemize}


\part{Strings}
\chapter{Gegevensstructuren voor strings}
\section{Digitale zoekbomen}
Deze zijn compleet analoog zoals gewone zoekbomen, op één verschil na: de juiste deelboom wordt niet bepaald door de zoeksleutel te vergelijken met de sleutel in de knoop, maar enkel door het volgende element van de zoeksleutel (van links naar rechts). Bij de wortel gebruiken we het eerst esleutelelement, een niveau dieper het tweede sleutelelement, enz...

De boom overlopen in \textbf{inorder} geeft de sleutels niet noodzakelijk in volgorde. De hoogte van de boom wordt beperkt tot het aantal bits van de grootste sleutel. Voor een groot aantal sleutels met relatief kleine bitlengte is de performantie in het slechtste geval veel beter dan die van een gewone binaire zoekboom, en vergelijkbaar met die van een rood-zwarte boom. In het gemiddelde geval is de kans op een volgend nul- of éénbit steeds gelijk, zodat er gemiddeld evenveel sleutels links als rechts komen. Daardoor is de gemiddelde hoogte van de boom $O(\lg n)$. De woordenboekoperaties zijn ook $O(\lg n)$.

De dikwijls beperkende voorwaarde is een efficiënte toegang tot de bits van de sleutels. Bovendien zijn er enkel woordenboekoperaties mogelijk.

\section{Tries}
Deze boom behoudt wel de sleutels in volgorde opslaat.
\subsection{Binaire tries}



\chapter{Zoeken in strings}
Symbolen die gebruikt worden:
\begin{table}[h]
	\centering
	\begin{tabular}{l l}
		\hline
		Symbool & Betekenis \\
		\hline 
		$\sum$ & Het gebruikte alfabet \\
		$\sum *$ & De verzameling strings van eindige lengte van letters uit $\sum$ \\
		$d$ & Aantal karakters in $\sum$ \\
		$P$ & Het patroon (naald) \\
		$p$ & Lengte van $P$ \\
		$T$ & De tekst (hooiberg) \\
		$t$ & Lengte van $T$ \\
		\hline 
	\end{tabular}
\end{table}
\section{Formele talen}
Formele taal over een alfabet = een verzameling eindige strings over dat alfabet. 

In de cursus wordt formele talentheorie beperkt tot wat in de praktijk handig is: generatieve grammatica's en reguliere uitdrukkingen.
\subsection{Generatieve grammatica's}
= Een startsymbool wordt getransformeerd tot een zin van de taal met behulp van substitutieregels. Hiervoor zijn \textbf{niet-terminale symbolen}, of kortweg niet-terminalen nodig met als notatie $\langle ... \rangle$.

$\Xi = $ De verzameling van alle strings van letters uit $\sum$ vermengd met niet-terminalen.

$\Xi* = $ de bijhorende verzameling strings.

\underline{Voorbeeld}: stel de volgende niet-terminalen (het symbool $::=$ staat voor "wordt herleidt tot"):
\begin{table}[ht]
	\centering
	\begin{tabular}{l l l}
		$\langle \textbf{S} \rangle$ & $::=$ & $\langle \textbf{AB} \rangle | \langle \textbf{CD} \rangle$ \\
		$\langle \textbf{AB} \rangle$ & $::=$ & $a\langle \textbf{AB} \rangle b | \epsilon$ \\
		$\langle \textbf{CD} \rangle$ & $::=$ & $c\langle \textbf{CD} \rangle d | \epsilon$ \\
	\end{tabular}
\end{table}
Deze grammatica definieert als formele taal de verzameling van alle strings ofwel bestaande uit een rij 'a's gevolgd door een even lange rij 'b's ofwel bestaande uit een rij 'c's gevolgd door een even lange rij 'd's. De afleiding van bijvoorbeeld de string "cccddd" wordt gegeven door
$$\langle \textbf{S} \rangle \Rightarrow  \langle \textbf{CD} \rangle  \Rightarrow  c\langle \textbf{CD} \rangle d
\Rightarrow  cc\langle \textbf{CD} \rangle dd \Rightarrow  ccc\langle \textbf{CD} \rangle ddd \Rightarrow  cccddd$$

\subsection{Reguliere uitdrukkingen}
(reguliere uitdrukking = regexp) = een string over het alfabet $\sum = \{\sigma_0, \sigma_1, ..., .\sigma_{d - 1}\}$ aangevuld met de symbolen $\emptyset$, $\epsilon$, $*$, $($, $)$ en $\underline{|}$ gedefinieerd door
\begin{table}[ht]
	\centering
	\begin{tabular}{l l l}
		$\langle \textbf{Regexp} \rangle$ & $::=$ & $\langle \textbf{basis} \rangle | \langle \textbf{samengesteld} \rangle$ \\
		$\langle \textbf{basis} \rangle$ & $::=$ & $\sigma_0 | ... | \sigma_{d - 1} | \emptyset | \epsilon$ \\
		$\langle \textbf{samengesteld} \rangle$ & $::=$ & $\langle \textbf{plus} \rangle  |  \langle \textbf{of} \rangle | \langle \textbf{ster} \rangle$ \\
		$\langle \textbf{plus} \rangle $ & $::=$ & $(\langle \textbf{Regexp} \rangle \langle \textbf{Regexp} \rangle)$ \\
		$\langle \textbf{of} \rangle $ & $::=$ & $(\langle \textbf{Regexp} \rangle \underline{|} \langle \textbf{Regexp} \rangle)$ \\
		$\langle \textbf{ster} \rangle $ & $::=$ & $(\langle \textbf{Regexp} \rangle)*$
	\end{tabular}
\end{table}
Een taal die door een regexp gedefinieerd kan worden heet een reguliere taal. 
\begin{enumerate}
	\item $\emptyset$ is een regexp, met als taal de lege verzameling.
	\item De lege string, voorgesteld als $\epsilon$, is een regexp met als taal Taal($\epsilon$) = \{$\epsilon$\}.
	\item Voor elke $a \in \sum$ is \textquotedblleft a\textquotedblright een regexp, met als taal Taal(\textquotedblleft a\textquotedblright ) = \{\textquotedblleft a \textquotedblright\}.
\end{enumerate}
\todo{p112-114}

\section{Variabele tekst}
\subsection{Eenvoudige methode}
= Voor elke positie $j$ nagaan of $P$ in $T$ voorkomt startend vanaf positie $j$, en de opeenvolgende $p$ posities.\accentuate{brol}

\subsection{Knuth-Morris-Pratt}
Eerst de definitie van een \textbf{deelstring} bepalen.

\begin{bytefield}{8}
	
	\bitbox{1}{} & \bitbox{1}{} & \bitbox{1}{} & \bitbox{1}{} & \bitbox{1}{} & \bitbox{1}{} & \bitbox{1}{} & \bitbox{1}{}
\end{bytefield}

Volgende code toont de werking van de prefixfunctie.
\begin{lstlisting}
q[0] = -1
q[1] = 0
for(i = 2; i <= p; i++){
	prev = q(i - 1)
	while(prev > 0 && P[i - 1] != P[prev]){
		prev = q[prev]
	}
	if(P[i - 1] == P[prev]){
		prev++
	}
	q[i] = prev
}
\end{lstlisting}

\end{document}


